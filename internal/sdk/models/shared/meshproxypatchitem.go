// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
	"github.com/kong/terraform-provider-kong-mesh/internal/sdk/internal/utils"
	"time"
)

// MeshProxyPatchItemType - the type of the resource
type MeshProxyPatchItemType string

const (
	MeshProxyPatchItemTypeMeshProxyPatch MeshProxyPatchItemType = "MeshProxyPatch"
)

func (e MeshProxyPatchItemType) ToPointer() *MeshProxyPatchItemType {
	return &e
}
func (e *MeshProxyPatchItemType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "MeshProxyPatch":
		*e = MeshProxyPatchItemType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshProxyPatchItemType: %v", v)
	}
}

// Op is a jsonpatch operation string.
type Op string

const (
	OpAdd     Op = "add"
	OpRemove  Op = "remove"
	OpReplace Op = "replace"
	OpMove    Op = "move"
	OpCopy    Op = "copy"
)

func (e Op) ToPointer() *Op {
	return &e
}
func (e *Op) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "add":
		fallthrough
	case "remove":
		fallthrough
	case "replace":
		fallthrough
	case "move":
		fallthrough
	case "copy":
		*e = Op(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Op: %v", v)
	}
}

// JSONPatches - JsonPatchBlock is one json patch operation block.
type JSONPatches struct {
	// From is a jsonpatch from string, used by move and copy operations.
	From *string `json:"from,omitempty"`
	// Op is a jsonpatch operation string.
	Op Op `json:"op"`
	// Path is a jsonpatch path string.
	Path string `json:"path"`
	// Value must be a valid json value used by replace and add operations.
	Value any `json:"value,omitempty"`
}

func (j *JSONPatches) GetFrom() *string {
	if j == nil {
		return nil
	}
	return j.From
}

func (j *JSONPatches) GetOp() Op {
	if j == nil {
		return Op("")
	}
	return j.Op
}

func (j *JSONPatches) GetPath() string {
	if j == nil {
		return ""
	}
	return j.Path
}

func (j *JSONPatches) GetValue() any {
	if j == nil {
		return nil
	}
	return j.Value
}

// MeshProxyPatchItemSpecDefaultAppendModificationsClusterMatch - Match is a set of conditions that have to be matched for modification operation to happen.
type MeshProxyPatchItemSpecDefaultAppendModificationsClusterMatch struct {
	// Name of the cluster to match.
	Name *string `json:"name,omitempty"`
	// Origin is the name of the component or plugin that generated the resource.
	//
	// Here is the list of well-known origins:
	// inbound - resources generated for handling incoming traffic.
	// outbound - resources generated for handling outgoing traffic.
	// transparent - resources generated for transparent proxy functionality.
	// prometheus - resources generated when Prometheus metrics are enabled.
	// direct-access - resources generated for Direct Access functionality.
	// ingress - resources generated for Zone Ingress.
	// egress - resources generated for Zone Egress.
	// gateway - resources generated for MeshGateway.
	//
	// The list is not complete, because policy plugins can introduce new resources.
	// For example MeshTrace plugin can create Cluster with "mesh-trace" origin.
	Origin *string `json:"origin,omitempty"`
}

func (m *MeshProxyPatchItemSpecDefaultAppendModificationsClusterMatch) GetName() *string {
	if m == nil {
		return nil
	}
	return m.Name
}

func (m *MeshProxyPatchItemSpecDefaultAppendModificationsClusterMatch) GetOrigin() *string {
	if m == nil {
		return nil
	}
	return m.Origin
}

// Operation to execute on matched cluster.
type Operation string

const (
	OperationAdd    Operation = "Add"
	OperationRemove Operation = "Remove"
	OperationPatch  Operation = "Patch"
)

func (e Operation) ToPointer() *Operation {
	return &e
}
func (e *Operation) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Add":
		fallthrough
	case "Remove":
		fallthrough
	case "Patch":
		*e = Operation(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Operation: %v", v)
	}
}

// Cluster is a modification of Envoy's Cluster resource.
type Cluster struct {
	// JsonPatches specifies list of jsonpatches to apply to on Envoy's Cluster
	// resource
	JSONPatches []JSONPatches `json:"jsonPatches,omitempty"`
	// Match is a set of conditions that have to be matched for modification operation to happen.
	Match *MeshProxyPatchItemSpecDefaultAppendModificationsClusterMatch `json:"match,omitempty"`
	// Operation to execute on matched cluster.
	Operation Operation `json:"operation"`
	// Value of xDS resource in YAML format to add or patch.
	Value *string `json:"value,omitempty"`
}

func (c *Cluster) GetJSONPatches() []JSONPatches {
	if c == nil {
		return nil
	}
	return c.JSONPatches
}

func (c *Cluster) GetMatch() *MeshProxyPatchItemSpecDefaultAppendModificationsClusterMatch {
	if c == nil {
		return nil
	}
	return c.Match
}

func (c *Cluster) GetOperation() Operation {
	if c == nil {
		return Operation("")
	}
	return c.Operation
}

func (c *Cluster) GetValue() *string {
	if c == nil {
		return nil
	}
	return c.Value
}

// MeshProxyPatchItemOp - Op is a jsonpatch operation string.
type MeshProxyPatchItemOp string

const (
	MeshProxyPatchItemOpAdd     MeshProxyPatchItemOp = "add"
	MeshProxyPatchItemOpRemove  MeshProxyPatchItemOp = "remove"
	MeshProxyPatchItemOpReplace MeshProxyPatchItemOp = "replace"
	MeshProxyPatchItemOpMove    MeshProxyPatchItemOp = "move"
	MeshProxyPatchItemOpCopy    MeshProxyPatchItemOp = "copy"
)

func (e MeshProxyPatchItemOp) ToPointer() *MeshProxyPatchItemOp {
	return &e
}
func (e *MeshProxyPatchItemOp) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "add":
		fallthrough
	case "remove":
		fallthrough
	case "replace":
		fallthrough
	case "move":
		fallthrough
	case "copy":
		*e = MeshProxyPatchItemOp(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshProxyPatchItemOp: %v", v)
	}
}

// MeshProxyPatchItemJSONPatches - JsonPatchBlock is one json patch operation block.
type MeshProxyPatchItemJSONPatches struct {
	// From is a jsonpatch from string, used by move and copy operations.
	From *string `json:"from,omitempty"`
	// Op is a jsonpatch operation string.
	Op MeshProxyPatchItemOp `json:"op"`
	// Path is a jsonpatch path string.
	Path string `json:"path"`
	// Value must be a valid json value used by replace and add operations.
	Value any `json:"value,omitempty"`
}

func (m *MeshProxyPatchItemJSONPatches) GetFrom() *string {
	if m == nil {
		return nil
	}
	return m.From
}

func (m *MeshProxyPatchItemJSONPatches) GetOp() MeshProxyPatchItemOp {
	if m == nil {
		return MeshProxyPatchItemOp("")
	}
	return m.Op
}

func (m *MeshProxyPatchItemJSONPatches) GetPath() string {
	if m == nil {
		return ""
	}
	return m.Path
}

func (m *MeshProxyPatchItemJSONPatches) GetValue() any {
	if m == nil {
		return nil
	}
	return m.Value
}

// MeshProxyPatchItemMatch - Match is a set of conditions that have to be matched for modification operation to happen.
type MeshProxyPatchItemMatch struct {
	// Name of the listener to match.
	ListenerName *string `json:"listenerName,omitempty"`
	// Listener tags available in Listener#Metadata#FilterMetadata[io.kuma.tags]
	ListenerTags map[string]string `json:"listenerTags,omitempty"`
	// Name of the HTTP filter. For example "envoy.filters.http.local_ratelimit"
	Name *string `json:"name,omitempty"`
	// Origin is the name of the component or plugin that generated the resource.
	//
	// Here is the list of well-known origins:
	// inbound - resources generated for handling incoming traffic.
	// outbound - resources generated for handling outgoing traffic.
	// transparent - resources generated for transparent proxy functionality.
	// prometheus - resources generated when Prometheus metrics are enabled.
	// direct-access - resources generated for Direct Access functionality.
	// ingress - resources generated for Zone Ingress.
	// egress - resources generated for Zone Egress.
	// gateway - resources generated for MeshGateway.
	//
	// The list is not complete, because policy plugins can introduce new resources.
	// For example MeshTrace plugin can create Cluster with "mesh-trace" origin.
	Origin *string `json:"origin,omitempty"`
}

func (m *MeshProxyPatchItemMatch) GetListenerName() *string {
	if m == nil {
		return nil
	}
	return m.ListenerName
}

func (m *MeshProxyPatchItemMatch) GetListenerTags() map[string]string {
	if m == nil {
		return nil
	}
	return m.ListenerTags
}

func (m *MeshProxyPatchItemMatch) GetName() *string {
	if m == nil {
		return nil
	}
	return m.Name
}

func (m *MeshProxyPatchItemMatch) GetOrigin() *string {
	if m == nil {
		return nil
	}
	return m.Origin
}

// MeshProxyPatchItemOperation - Operation to execute on matched listener.
type MeshProxyPatchItemOperation string

const (
	MeshProxyPatchItemOperationRemove    MeshProxyPatchItemOperation = "Remove"
	MeshProxyPatchItemOperationPatch     MeshProxyPatchItemOperation = "Patch"
	MeshProxyPatchItemOperationAddFirst  MeshProxyPatchItemOperation = "AddFirst"
	MeshProxyPatchItemOperationAddBefore MeshProxyPatchItemOperation = "AddBefore"
	MeshProxyPatchItemOperationAddAfter  MeshProxyPatchItemOperation = "AddAfter"
	MeshProxyPatchItemOperationAddLast   MeshProxyPatchItemOperation = "AddLast"
)

func (e MeshProxyPatchItemOperation) ToPointer() *MeshProxyPatchItemOperation {
	return &e
}
func (e *MeshProxyPatchItemOperation) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Remove":
		fallthrough
	case "Patch":
		fallthrough
	case "AddFirst":
		fallthrough
	case "AddBefore":
		fallthrough
	case "AddAfter":
		fallthrough
	case "AddLast":
		*e = MeshProxyPatchItemOperation(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshProxyPatchItemOperation: %v", v)
	}
}

// HTTPFilter is a modification of Envoy HTTP Filter
// available in HTTP Connection Manager in a Listener resource.
type HTTPFilter struct {
	// JsonPatches specifies list of jsonpatches to apply to on Envoy's
	// HTTP Filter available in HTTP Connection Manager in a Listener resource.
	JSONPatches []MeshProxyPatchItemJSONPatches `json:"jsonPatches,omitempty"`
	// Match is a set of conditions that have to be matched for modification operation to happen.
	Match *MeshProxyPatchItemMatch `json:"match,omitempty"`
	// Operation to execute on matched listener.
	Operation MeshProxyPatchItemOperation `json:"operation"`
	// Value of xDS resource in YAML format to add or patch.
	Value *string `json:"value,omitempty"`
}

func (h *HTTPFilter) GetJSONPatches() []MeshProxyPatchItemJSONPatches {
	if h == nil {
		return nil
	}
	return h.JSONPatches
}

func (h *HTTPFilter) GetMatch() *MeshProxyPatchItemMatch {
	if h == nil {
		return nil
	}
	return h.Match
}

func (h *HTTPFilter) GetOperation() MeshProxyPatchItemOperation {
	if h == nil {
		return MeshProxyPatchItemOperation("")
	}
	return h.Operation
}

func (h *HTTPFilter) GetValue() *string {
	if h == nil {
		return nil
	}
	return h.Value
}

// MeshProxyPatchItemSpecOp - Op is a jsonpatch operation string.
type MeshProxyPatchItemSpecOp string

const (
	MeshProxyPatchItemSpecOpAdd     MeshProxyPatchItemSpecOp = "add"
	MeshProxyPatchItemSpecOpRemove  MeshProxyPatchItemSpecOp = "remove"
	MeshProxyPatchItemSpecOpReplace MeshProxyPatchItemSpecOp = "replace"
	MeshProxyPatchItemSpecOpMove    MeshProxyPatchItemSpecOp = "move"
	MeshProxyPatchItemSpecOpCopy    MeshProxyPatchItemSpecOp = "copy"
)

func (e MeshProxyPatchItemSpecOp) ToPointer() *MeshProxyPatchItemSpecOp {
	return &e
}
func (e *MeshProxyPatchItemSpecOp) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "add":
		fallthrough
	case "remove":
		fallthrough
	case "replace":
		fallthrough
	case "move":
		fallthrough
	case "copy":
		*e = MeshProxyPatchItemSpecOp(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshProxyPatchItemSpecOp: %v", v)
	}
}

// MeshProxyPatchItemSpecJSONPatches - JsonPatchBlock is one json patch operation block.
type MeshProxyPatchItemSpecJSONPatches struct {
	// From is a jsonpatch from string, used by move and copy operations.
	From *string `json:"from,omitempty"`
	// Op is a jsonpatch operation string.
	Op MeshProxyPatchItemSpecOp `json:"op"`
	// Path is a jsonpatch path string.
	Path string `json:"path"`
	// Value must be a valid json value used by replace and add operations.
	Value any `json:"value,omitempty"`
}

func (m *MeshProxyPatchItemSpecJSONPatches) GetFrom() *string {
	if m == nil {
		return nil
	}
	return m.From
}

func (m *MeshProxyPatchItemSpecJSONPatches) GetOp() MeshProxyPatchItemSpecOp {
	if m == nil {
		return MeshProxyPatchItemSpecOp("")
	}
	return m.Op
}

func (m *MeshProxyPatchItemSpecJSONPatches) GetPath() string {
	if m == nil {
		return ""
	}
	return m.Path
}

func (m *MeshProxyPatchItemSpecJSONPatches) GetValue() any {
	if m == nil {
		return nil
	}
	return m.Value
}

// MeshProxyPatchItemSpecMatch - Match is a set of conditions that have to be matched for modification operation to happen.
type MeshProxyPatchItemSpecMatch struct {
	// Name of the listener to match.
	Name *string `json:"name,omitempty"`
	// Origin is the name of the component or plugin that generated the resource.
	//
	// Here is the list of well-known origins:
	// inbound - resources generated for handling incoming traffic.
	// outbound - resources generated for handling outgoing traffic.
	// transparent - resources generated for transparent proxy functionality.
	// prometheus - resources generated when Prometheus metrics are enabled.
	// direct-access - resources generated for Direct Access functionality.
	// ingress - resources generated for Zone Ingress.
	// egress - resources generated for Zone Egress.
	// gateway - resources generated for MeshGateway.
	//
	// The list is not complete, because policy plugins can introduce new resources.
	// For example MeshTrace plugin can create Cluster with "mesh-trace" origin.
	Origin *string `json:"origin,omitempty"`
	// Tags available in Listener#Metadata#FilterMetadata[io.kuma.tags]
	Tags map[string]string `json:"tags,omitempty"`
}

func (m *MeshProxyPatchItemSpecMatch) GetName() *string {
	if m == nil {
		return nil
	}
	return m.Name
}

func (m *MeshProxyPatchItemSpecMatch) GetOrigin() *string {
	if m == nil {
		return nil
	}
	return m.Origin
}

func (m *MeshProxyPatchItemSpecMatch) GetTags() map[string]string {
	if m == nil {
		return nil
	}
	return m.Tags
}

// MeshProxyPatchItemSpecOperation - Operation to execute on matched listener.
type MeshProxyPatchItemSpecOperation string

const (
	MeshProxyPatchItemSpecOperationAdd    MeshProxyPatchItemSpecOperation = "Add"
	MeshProxyPatchItemSpecOperationRemove MeshProxyPatchItemSpecOperation = "Remove"
	MeshProxyPatchItemSpecOperationPatch  MeshProxyPatchItemSpecOperation = "Patch"
)

func (e MeshProxyPatchItemSpecOperation) ToPointer() *MeshProxyPatchItemSpecOperation {
	return &e
}
func (e *MeshProxyPatchItemSpecOperation) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Add":
		fallthrough
	case "Remove":
		fallthrough
	case "Patch":
		*e = MeshProxyPatchItemSpecOperation(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshProxyPatchItemSpecOperation: %v", v)
	}
}

// Listener is a modification of Envoy's Listener resource.
type Listener struct {
	// JsonPatches specifies list of jsonpatches to apply to on Envoy's Listener
	// resource
	JSONPatches []MeshProxyPatchItemSpecJSONPatches `json:"jsonPatches,omitempty"`
	// Match is a set of conditions that have to be matched for modification operation to happen.
	Match *MeshProxyPatchItemSpecMatch `json:"match,omitempty"`
	// Operation to execute on matched listener.
	Operation MeshProxyPatchItemSpecOperation `json:"operation"`
	// Value of xDS resource in YAML format to add or patch.
	Value *string `json:"value,omitempty"`
}

func (l *Listener) GetJSONPatches() []MeshProxyPatchItemSpecJSONPatches {
	if l == nil {
		return nil
	}
	return l.JSONPatches
}

func (l *Listener) GetMatch() *MeshProxyPatchItemSpecMatch {
	if l == nil {
		return nil
	}
	return l.Match
}

func (l *Listener) GetOperation() MeshProxyPatchItemSpecOperation {
	if l == nil {
		return MeshProxyPatchItemSpecOperation("")
	}
	return l.Operation
}

func (l *Listener) GetValue() *string {
	if l == nil {
		return nil
	}
	return l.Value
}

// MeshProxyPatchItemSpecDefaultOp - Op is a jsonpatch operation string.
type MeshProxyPatchItemSpecDefaultOp string

const (
	MeshProxyPatchItemSpecDefaultOpAdd     MeshProxyPatchItemSpecDefaultOp = "add"
	MeshProxyPatchItemSpecDefaultOpRemove  MeshProxyPatchItemSpecDefaultOp = "remove"
	MeshProxyPatchItemSpecDefaultOpReplace MeshProxyPatchItemSpecDefaultOp = "replace"
	MeshProxyPatchItemSpecDefaultOpMove    MeshProxyPatchItemSpecDefaultOp = "move"
	MeshProxyPatchItemSpecDefaultOpCopy    MeshProxyPatchItemSpecDefaultOp = "copy"
)

func (e MeshProxyPatchItemSpecDefaultOp) ToPointer() *MeshProxyPatchItemSpecDefaultOp {
	return &e
}
func (e *MeshProxyPatchItemSpecDefaultOp) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "add":
		fallthrough
	case "remove":
		fallthrough
	case "replace":
		fallthrough
	case "move":
		fallthrough
	case "copy":
		*e = MeshProxyPatchItemSpecDefaultOp(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshProxyPatchItemSpecDefaultOp: %v", v)
	}
}

// MeshProxyPatchItemSpecDefaultJSONPatches - JsonPatchBlock is one json patch operation block.
type MeshProxyPatchItemSpecDefaultJSONPatches struct {
	// From is a jsonpatch from string, used by move and copy operations.
	From *string `json:"from,omitempty"`
	// Op is a jsonpatch operation string.
	Op MeshProxyPatchItemSpecDefaultOp `json:"op"`
	// Path is a jsonpatch path string.
	Path string `json:"path"`
	// Value must be a valid json value used by replace and add operations.
	Value any `json:"value,omitempty"`
}

func (m *MeshProxyPatchItemSpecDefaultJSONPatches) GetFrom() *string {
	if m == nil {
		return nil
	}
	return m.From
}

func (m *MeshProxyPatchItemSpecDefaultJSONPatches) GetOp() MeshProxyPatchItemSpecDefaultOp {
	if m == nil {
		return MeshProxyPatchItemSpecDefaultOp("")
	}
	return m.Op
}

func (m *MeshProxyPatchItemSpecDefaultJSONPatches) GetPath() string {
	if m == nil {
		return ""
	}
	return m.Path
}

func (m *MeshProxyPatchItemSpecDefaultJSONPatches) GetValue() any {
	if m == nil {
		return nil
	}
	return m.Value
}

// MeshProxyPatchItemSpecDefaultMatch - Match is a set of conditions that have to be matched for modification operation to happen.
type MeshProxyPatchItemSpecDefaultMatch struct {
	// Name of the listener to match.
	ListenerName *string `json:"listenerName,omitempty"`
	// Listener tags available in Listener#Metadata#FilterMetadata[io.kuma.tags]
	ListenerTags map[string]string `json:"listenerTags,omitempty"`
	// Name of the network filter. For example "envoy.filters.network.ratelimit"
	Name *string `json:"name,omitempty"`
	// Origin is the name of the component or plugin that generated the resource.
	//
	// Here is the list of well-known origins:
	// inbound - resources generated for handling incoming traffic.
	// outbound - resources generated for handling outgoing traffic.
	// transparent - resources generated for transparent proxy functionality.
	// prometheus - resources generated when Prometheus metrics are enabled.
	// direct-access - resources generated for Direct Access functionality.
	// ingress - resources generated for Zone Ingress.
	// egress - resources generated for Zone Egress.
	// gateway - resources generated for MeshGateway.
	//
	// The list is not complete, because policy plugins can introduce new resources.
	// For example MeshTrace plugin can create Cluster with "mesh-trace" origin.
	Origin *string `json:"origin,omitempty"`
}

func (m *MeshProxyPatchItemSpecDefaultMatch) GetListenerName() *string {
	if m == nil {
		return nil
	}
	return m.ListenerName
}

func (m *MeshProxyPatchItemSpecDefaultMatch) GetListenerTags() map[string]string {
	if m == nil {
		return nil
	}
	return m.ListenerTags
}

func (m *MeshProxyPatchItemSpecDefaultMatch) GetName() *string {
	if m == nil {
		return nil
	}
	return m.Name
}

func (m *MeshProxyPatchItemSpecDefaultMatch) GetOrigin() *string {
	if m == nil {
		return nil
	}
	return m.Origin
}

// MeshProxyPatchItemSpecDefaultOperation - Operation to execute on matched listener.
type MeshProxyPatchItemSpecDefaultOperation string

const (
	MeshProxyPatchItemSpecDefaultOperationRemove    MeshProxyPatchItemSpecDefaultOperation = "Remove"
	MeshProxyPatchItemSpecDefaultOperationPatch     MeshProxyPatchItemSpecDefaultOperation = "Patch"
	MeshProxyPatchItemSpecDefaultOperationAddFirst  MeshProxyPatchItemSpecDefaultOperation = "AddFirst"
	MeshProxyPatchItemSpecDefaultOperationAddBefore MeshProxyPatchItemSpecDefaultOperation = "AddBefore"
	MeshProxyPatchItemSpecDefaultOperationAddAfter  MeshProxyPatchItemSpecDefaultOperation = "AddAfter"
	MeshProxyPatchItemSpecDefaultOperationAddLast   MeshProxyPatchItemSpecDefaultOperation = "AddLast"
)

func (e MeshProxyPatchItemSpecDefaultOperation) ToPointer() *MeshProxyPatchItemSpecDefaultOperation {
	return &e
}
func (e *MeshProxyPatchItemSpecDefaultOperation) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Remove":
		fallthrough
	case "Patch":
		fallthrough
	case "AddFirst":
		fallthrough
	case "AddBefore":
		fallthrough
	case "AddAfter":
		fallthrough
	case "AddLast":
		*e = MeshProxyPatchItemSpecDefaultOperation(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshProxyPatchItemSpecDefaultOperation: %v", v)
	}
}

// NetworkFilter is a modification of Envoy Listener's filter.
type NetworkFilter struct {
	// JsonPatches specifies list of jsonpatches to apply to on Envoy Listener's
	// filter.
	JSONPatches []MeshProxyPatchItemSpecDefaultJSONPatches `json:"jsonPatches,omitempty"`
	// Match is a set of conditions that have to be matched for modification operation to happen.
	Match *MeshProxyPatchItemSpecDefaultMatch `json:"match,omitempty"`
	// Operation to execute on matched listener.
	Operation MeshProxyPatchItemSpecDefaultOperation `json:"operation"`
	// Value of xDS resource in YAML format to add or patch.
	Value *string `json:"value,omitempty"`
}

func (n *NetworkFilter) GetJSONPatches() []MeshProxyPatchItemSpecDefaultJSONPatches {
	if n == nil {
		return nil
	}
	return n.JSONPatches
}

func (n *NetworkFilter) GetMatch() *MeshProxyPatchItemSpecDefaultMatch {
	if n == nil {
		return nil
	}
	return n.Match
}

func (n *NetworkFilter) GetOperation() MeshProxyPatchItemSpecDefaultOperation {
	if n == nil {
		return MeshProxyPatchItemSpecDefaultOperation("")
	}
	return n.Operation
}

func (n *NetworkFilter) GetValue() *string {
	if n == nil {
		return nil
	}
	return n.Value
}

// MeshProxyPatchItemSpecDefaultAppendModificationsOp - Op is a jsonpatch operation string.
type MeshProxyPatchItemSpecDefaultAppendModificationsOp string

const (
	MeshProxyPatchItemSpecDefaultAppendModificationsOpAdd     MeshProxyPatchItemSpecDefaultAppendModificationsOp = "add"
	MeshProxyPatchItemSpecDefaultAppendModificationsOpRemove  MeshProxyPatchItemSpecDefaultAppendModificationsOp = "remove"
	MeshProxyPatchItemSpecDefaultAppendModificationsOpReplace MeshProxyPatchItemSpecDefaultAppendModificationsOp = "replace"
	MeshProxyPatchItemSpecDefaultAppendModificationsOpMove    MeshProxyPatchItemSpecDefaultAppendModificationsOp = "move"
	MeshProxyPatchItemSpecDefaultAppendModificationsOpCopy    MeshProxyPatchItemSpecDefaultAppendModificationsOp = "copy"
)

func (e MeshProxyPatchItemSpecDefaultAppendModificationsOp) ToPointer() *MeshProxyPatchItemSpecDefaultAppendModificationsOp {
	return &e
}
func (e *MeshProxyPatchItemSpecDefaultAppendModificationsOp) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "add":
		fallthrough
	case "remove":
		fallthrough
	case "replace":
		fallthrough
	case "move":
		fallthrough
	case "copy":
		*e = MeshProxyPatchItemSpecDefaultAppendModificationsOp(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshProxyPatchItemSpecDefaultAppendModificationsOp: %v", v)
	}
}

// MeshProxyPatchItemSpecDefaultAppendModificationsJSONPatches - JsonPatchBlock is one json patch operation block.
type MeshProxyPatchItemSpecDefaultAppendModificationsJSONPatches struct {
	// From is a jsonpatch from string, used by move and copy operations.
	From *string `json:"from,omitempty"`
	// Op is a jsonpatch operation string.
	Op MeshProxyPatchItemSpecDefaultAppendModificationsOp `json:"op"`
	// Path is a jsonpatch path string.
	Path string `json:"path"`
	// Value must be a valid json value used by replace and add operations.
	Value any `json:"value,omitempty"`
}

func (m *MeshProxyPatchItemSpecDefaultAppendModificationsJSONPatches) GetFrom() *string {
	if m == nil {
		return nil
	}
	return m.From
}

func (m *MeshProxyPatchItemSpecDefaultAppendModificationsJSONPatches) GetOp() MeshProxyPatchItemSpecDefaultAppendModificationsOp {
	if m == nil {
		return MeshProxyPatchItemSpecDefaultAppendModificationsOp("")
	}
	return m.Op
}

func (m *MeshProxyPatchItemSpecDefaultAppendModificationsJSONPatches) GetPath() string {
	if m == nil {
		return ""
	}
	return m.Path
}

func (m *MeshProxyPatchItemSpecDefaultAppendModificationsJSONPatches) GetValue() any {
	if m == nil {
		return nil
	}
	return m.Value
}

// MeshProxyPatchItemSpecDefaultAppendModificationsMatch - Match is a set of conditions that have to be matched for modification operation to happen.
type MeshProxyPatchItemSpecDefaultAppendModificationsMatch struct {
	// Name of the VirtualHost to match.
	Name *string `json:"name,omitempty"`
	// Origin is the name of the component or plugin that generated the resource.
	//
	// Here is the list of well-known origins:
	// inbound - resources generated for handling incoming traffic.
	// outbound - resources generated for handling outgoing traffic.
	// transparent - resources generated for transparent proxy functionality.
	// prometheus - resources generated when Prometheus metrics are enabled.
	// direct-access - resources generated for Direct Access functionality.
	// ingress - resources generated for Zone Ingress.
	// egress - resources generated for Zone Egress.
	// gateway - resources generated for MeshGateway.
	//
	// The list is not complete, because policy plugins can introduce new resources.
	// For example MeshTrace plugin can create Cluster with "mesh-trace" origin.
	Origin *string `json:"origin,omitempty"`
	// Name of the RouteConfiguration resource to match.
	RouteConfigurationName *string `json:"routeConfigurationName,omitempty"`
}

func (m *MeshProxyPatchItemSpecDefaultAppendModificationsMatch) GetName() *string {
	if m == nil {
		return nil
	}
	return m.Name
}

func (m *MeshProxyPatchItemSpecDefaultAppendModificationsMatch) GetOrigin() *string {
	if m == nil {
		return nil
	}
	return m.Origin
}

func (m *MeshProxyPatchItemSpecDefaultAppendModificationsMatch) GetRouteConfigurationName() *string {
	if m == nil {
		return nil
	}
	return m.RouteConfigurationName
}

// MeshProxyPatchItemSpecDefaultAppendModificationsOperation - Operation to execute on matched listener.
type MeshProxyPatchItemSpecDefaultAppendModificationsOperation string

const (
	MeshProxyPatchItemSpecDefaultAppendModificationsOperationAdd    MeshProxyPatchItemSpecDefaultAppendModificationsOperation = "Add"
	MeshProxyPatchItemSpecDefaultAppendModificationsOperationRemove MeshProxyPatchItemSpecDefaultAppendModificationsOperation = "Remove"
	MeshProxyPatchItemSpecDefaultAppendModificationsOperationPatch  MeshProxyPatchItemSpecDefaultAppendModificationsOperation = "Patch"
)

func (e MeshProxyPatchItemSpecDefaultAppendModificationsOperation) ToPointer() *MeshProxyPatchItemSpecDefaultAppendModificationsOperation {
	return &e
}
func (e *MeshProxyPatchItemSpecDefaultAppendModificationsOperation) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Add":
		fallthrough
	case "Remove":
		fallthrough
	case "Patch":
		*e = MeshProxyPatchItemSpecDefaultAppendModificationsOperation(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshProxyPatchItemSpecDefaultAppendModificationsOperation: %v", v)
	}
}

// VirtualHost is a modification of Envoy's VirtualHost
// referenced in HTTP Connection Manager in a Listener resource.
type VirtualHost struct {
	// JsonPatches specifies list of jsonpatches to apply to on Envoy's
	// VirtualHost resource
	JSONPatches []MeshProxyPatchItemSpecDefaultAppendModificationsJSONPatches `json:"jsonPatches,omitempty"`
	// Match is a set of conditions that have to be matched for modification operation to happen.
	Match MeshProxyPatchItemSpecDefaultAppendModificationsMatch `json:"match"`
	// Operation to execute on matched listener.
	Operation MeshProxyPatchItemSpecDefaultAppendModificationsOperation `json:"operation"`
	// Value of xDS resource in YAML format to add or patch.
	Value *string `json:"value,omitempty"`
}

func (v *VirtualHost) GetJSONPatches() []MeshProxyPatchItemSpecDefaultAppendModificationsJSONPatches {
	if v == nil {
		return nil
	}
	return v.JSONPatches
}

func (v *VirtualHost) GetMatch() MeshProxyPatchItemSpecDefaultAppendModificationsMatch {
	if v == nil {
		return MeshProxyPatchItemSpecDefaultAppendModificationsMatch{}
	}
	return v.Match
}

func (v *VirtualHost) GetOperation() MeshProxyPatchItemSpecDefaultAppendModificationsOperation {
	if v == nil {
		return MeshProxyPatchItemSpecDefaultAppendModificationsOperation("")
	}
	return v.Operation
}

func (v *VirtualHost) GetValue() *string {
	if v == nil {
		return nil
	}
	return v.Value
}

type AppendModifications struct {
	// Cluster is a modification of Envoy's Cluster resource.
	Cluster *Cluster `json:"cluster,omitempty"`
	// HTTPFilter is a modification of Envoy HTTP Filter
	// available in HTTP Connection Manager in a Listener resource.
	HTTPFilter *HTTPFilter `json:"httpFilter,omitempty"`
	// Listener is a modification of Envoy's Listener resource.
	Listener *Listener `json:"listener,omitempty"`
	// NetworkFilter is a modification of Envoy Listener's filter.
	NetworkFilter *NetworkFilter `json:"networkFilter,omitempty"`
	// VirtualHost is a modification of Envoy's VirtualHost
	// referenced in HTTP Connection Manager in a Listener resource.
	VirtualHost *VirtualHost `json:"virtualHost,omitempty"`
}

func (a *AppendModifications) GetCluster() *Cluster {
	if a == nil {
		return nil
	}
	return a.Cluster
}

func (a *AppendModifications) GetHTTPFilter() *HTTPFilter {
	if a == nil {
		return nil
	}
	return a.HTTPFilter
}

func (a *AppendModifications) GetListener() *Listener {
	if a == nil {
		return nil
	}
	return a.Listener
}

func (a *AppendModifications) GetNetworkFilter() *NetworkFilter {
	if a == nil {
		return nil
	}
	return a.NetworkFilter
}

func (a *AppendModifications) GetVirtualHost() *VirtualHost {
	if a == nil {
		return nil
	}
	return a.VirtualHost
}

// MeshProxyPatchItemDefault - Default is a configuration specific to the group of destinations
// referenced in 'targetRef'.
type MeshProxyPatchItemDefault struct {
	// AppendModifications is a list of modifications applied on the selected proxy.
	AppendModifications []AppendModifications `json:"appendModifications,omitempty"`
}

func (m *MeshProxyPatchItemDefault) GetAppendModifications() []AppendModifications {
	if m == nil {
		return nil
	}
	return m.AppendModifications
}

// MeshProxyPatchItemKind - Kind of the referenced resource
type MeshProxyPatchItemKind string

const (
	MeshProxyPatchItemKindMesh                 MeshProxyPatchItemKind = "Mesh"
	MeshProxyPatchItemKindMeshSubset           MeshProxyPatchItemKind = "MeshSubset"
	MeshProxyPatchItemKindMeshGateway          MeshProxyPatchItemKind = "MeshGateway"
	MeshProxyPatchItemKindMeshService          MeshProxyPatchItemKind = "MeshService"
	MeshProxyPatchItemKindMeshExternalService  MeshProxyPatchItemKind = "MeshExternalService"
	MeshProxyPatchItemKindMeshMultiZoneService MeshProxyPatchItemKind = "MeshMultiZoneService"
	MeshProxyPatchItemKindMeshServiceSubset    MeshProxyPatchItemKind = "MeshServiceSubset"
	MeshProxyPatchItemKindMeshHTTPRoute        MeshProxyPatchItemKind = "MeshHTTPRoute"
	MeshProxyPatchItemKindDataplane            MeshProxyPatchItemKind = "Dataplane"
)

func (e MeshProxyPatchItemKind) ToPointer() *MeshProxyPatchItemKind {
	return &e
}
func (e *MeshProxyPatchItemKind) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Mesh":
		fallthrough
	case "MeshSubset":
		fallthrough
	case "MeshGateway":
		fallthrough
	case "MeshService":
		fallthrough
	case "MeshExternalService":
		fallthrough
	case "MeshMultiZoneService":
		fallthrough
	case "MeshServiceSubset":
		fallthrough
	case "MeshHTTPRoute":
		fallthrough
	case "Dataplane":
		*e = MeshProxyPatchItemKind(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshProxyPatchItemKind: %v", v)
	}
}

type MeshProxyPatchItemProxyTypes string

const (
	MeshProxyPatchItemProxyTypesSidecar MeshProxyPatchItemProxyTypes = "Sidecar"
	MeshProxyPatchItemProxyTypesGateway MeshProxyPatchItemProxyTypes = "Gateway"
)

func (e MeshProxyPatchItemProxyTypes) ToPointer() *MeshProxyPatchItemProxyTypes {
	return &e
}
func (e *MeshProxyPatchItemProxyTypes) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Sidecar":
		fallthrough
	case "Gateway":
		*e = MeshProxyPatchItemProxyTypes(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshProxyPatchItemProxyTypes: %v", v)
	}
}

// MeshProxyPatchItemTargetRef - TargetRef is a reference to the resource the policy takes an effect on.
// The resource could be either a real store object or virtual resource
// defined inplace.
type MeshProxyPatchItemTargetRef struct {
	// Kind of the referenced resource
	Kind MeshProxyPatchItemKind `json:"kind"`
	// Labels are used to select group of MeshServices that match labels. Either Labels or
	// Name and Namespace can be used.
	Labels map[string]string `json:"labels,omitempty"`
	// Mesh is reserved for future use to identify cross mesh resources.
	Mesh *string `json:"mesh,omitempty"`
	// Name of the referenced resource. Can only be used with kinds: `MeshService`,
	// `MeshServiceSubset` and `MeshGatewayRoute`
	Name *string `json:"name,omitempty"`
	// Namespace specifies the namespace of target resource. If empty only resources in policy namespace
	// will be targeted.
	Namespace *string `json:"namespace,omitempty"`
	// ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
	// all data plane types are targeted by the policy.
	ProxyTypes []MeshProxyPatchItemProxyTypes `json:"proxyTypes,omitempty"`
	// SectionName is used to target specific section of resource.
	// For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected.
	SectionName *string `json:"sectionName,omitempty"`
	// Tags used to select a subset of proxies by tags. Can only be used with kinds
	// `MeshSubset` and `MeshServiceSubset`
	Tags map[string]string `json:"tags,omitempty"`
}

func (m *MeshProxyPatchItemTargetRef) GetKind() MeshProxyPatchItemKind {
	if m == nil {
		return MeshProxyPatchItemKind("")
	}
	return m.Kind
}

func (m *MeshProxyPatchItemTargetRef) GetLabels() map[string]string {
	if m == nil {
		return nil
	}
	return m.Labels
}

func (m *MeshProxyPatchItemTargetRef) GetMesh() *string {
	if m == nil {
		return nil
	}
	return m.Mesh
}

func (m *MeshProxyPatchItemTargetRef) GetName() *string {
	if m == nil {
		return nil
	}
	return m.Name
}

func (m *MeshProxyPatchItemTargetRef) GetNamespace() *string {
	if m == nil {
		return nil
	}
	return m.Namespace
}

func (m *MeshProxyPatchItemTargetRef) GetProxyTypes() []MeshProxyPatchItemProxyTypes {
	if m == nil {
		return nil
	}
	return m.ProxyTypes
}

func (m *MeshProxyPatchItemTargetRef) GetSectionName() *string {
	if m == nil {
		return nil
	}
	return m.SectionName
}

func (m *MeshProxyPatchItemTargetRef) GetTags() map[string]string {
	if m == nil {
		return nil
	}
	return m.Tags
}

// MeshProxyPatchItemSpec - Spec is the specification of the Kuma MeshProxyPatch resource.
type MeshProxyPatchItemSpec struct {
	// Default is a configuration specific to the group of destinations
	// referenced in 'targetRef'.
	Default MeshProxyPatchItemDefault `json:"default"`
	// TargetRef is a reference to the resource the policy takes an effect on.
	// The resource could be either a real store object or virtual resource
	// defined inplace.
	TargetRef *MeshProxyPatchItemTargetRef `json:"targetRef,omitempty"`
}

func (m *MeshProxyPatchItemSpec) GetDefault() MeshProxyPatchItemDefault {
	if m == nil {
		return MeshProxyPatchItemDefault{}
	}
	return m.Default
}

func (m *MeshProxyPatchItemSpec) GetTargetRef() *MeshProxyPatchItemTargetRef {
	if m == nil {
		return nil
	}
	return m.TargetRef
}

// MeshProxyPatchItem - Successful response
type MeshProxyPatchItem struct {
	// the type of the resource
	Type MeshProxyPatchItemType `json:"type"`
	// Mesh is the name of the Kuma mesh this resource belongs to. It may be omitted for cluster-scoped resources.
	Mesh *string `default:"default" json:"mesh"`
	// Name of the Kuma resource
	Name string `json:"name"`
	// The labels to help identity resources
	Labels map[string]string `json:"labels,omitempty"`
	// Spec is the specification of the Kuma MeshProxyPatch resource.
	Spec MeshProxyPatchItemSpec `json:"spec"`
	// Time at which the resource was created
	CreationTime *time.Time `json:"creationTime,omitempty"`
	// Time at which the resource was updated
	ModificationTime *time.Time `json:"modificationTime,omitempty"`
}

func (m MeshProxyPatchItem) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(m, "", false)
}

func (m *MeshProxyPatchItem) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &m, "", false, []string{"type", "name", "spec"}); err != nil {
		return err
	}
	return nil
}

func (m *MeshProxyPatchItem) GetType() MeshProxyPatchItemType {
	if m == nil {
		return MeshProxyPatchItemType("")
	}
	return m.Type
}

func (m *MeshProxyPatchItem) GetMesh() *string {
	if m == nil {
		return nil
	}
	return m.Mesh
}

func (m *MeshProxyPatchItem) GetName() string {
	if m == nil {
		return ""
	}
	return m.Name
}

func (m *MeshProxyPatchItem) GetLabels() map[string]string {
	if m == nil {
		return nil
	}
	return m.Labels
}

func (m *MeshProxyPatchItem) GetSpec() MeshProxyPatchItemSpec {
	if m == nil {
		return MeshProxyPatchItemSpec{}
	}
	return m.Spec
}

func (m *MeshProxyPatchItem) GetCreationTime() *time.Time {
	if m == nil {
		return nil
	}
	return m.CreationTime
}

func (m *MeshProxyPatchItem) GetModificationTime() *time.Time {
	if m == nil {
		return nil
	}
	return m.ModificationTime
}

type MeshProxyPatchItemInput struct {
	// the type of the resource
	Type MeshProxyPatchItemType `json:"type"`
	// Mesh is the name of the Kuma mesh this resource belongs to. It may be omitted for cluster-scoped resources.
	Mesh *string `default:"default" json:"mesh"`
	// Name of the Kuma resource
	Name string `json:"name"`
	// The labels to help identity resources
	Labels map[string]string `json:"labels,omitempty"`
	// Spec is the specification of the Kuma MeshProxyPatch resource.
	Spec MeshProxyPatchItemSpec `json:"spec"`
}

func (m MeshProxyPatchItemInput) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(m, "", false)
}

func (m *MeshProxyPatchItemInput) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &m, "", false, []string{"type", "name", "spec"}); err != nil {
		return err
	}
	return nil
}

func (m *MeshProxyPatchItemInput) GetType() MeshProxyPatchItemType {
	if m == nil {
		return MeshProxyPatchItemType("")
	}
	return m.Type
}

func (m *MeshProxyPatchItemInput) GetMesh() *string {
	if m == nil {
		return nil
	}
	return m.Mesh
}

func (m *MeshProxyPatchItemInput) GetName() string {
	if m == nil {
		return ""
	}
	return m.Name
}

func (m *MeshProxyPatchItemInput) GetLabels() map[string]string {
	if m == nil {
		return nil
	}
	return m.Labels
}

func (m *MeshProxyPatchItemInput) GetSpec() MeshProxyPatchItemSpec {
	if m == nil {
		return MeshProxyPatchItemSpec{}
	}
	return m.Spec
}
