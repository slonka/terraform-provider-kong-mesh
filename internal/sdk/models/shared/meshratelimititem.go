// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
	"github.com/kong/terraform-provider-kong-mesh/internal/sdk/internal/utils"
	"time"
)

// MeshRateLimitItemType - the type of the resource
type MeshRateLimitItemType string

const (
	MeshRateLimitItemTypeMeshRateLimit MeshRateLimitItemType = "MeshRateLimit"
)

func (e MeshRateLimitItemType) ToPointer() *MeshRateLimitItemType {
	return &e
}
func (e *MeshRateLimitItemType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "MeshRateLimit":
		*e = MeshRateLimitItemType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshRateLimitItemType: %v", v)
	}
}

type MeshRateLimitItemAdd struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

func (m *MeshRateLimitItemAdd) GetName() string {
	if m == nil {
		return ""
	}
	return m.Name
}

func (m *MeshRateLimitItemAdd) GetValue() string {
	if m == nil {
		return ""
	}
	return m.Value
}

type MeshRateLimitItemSet struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

func (m *MeshRateLimitItemSet) GetName() string {
	if m == nil {
		return ""
	}
	return m.Name
}

func (m *MeshRateLimitItemSet) GetValue() string {
	if m == nil {
		return ""
	}
	return m.Value
}

// MeshRateLimitItemHeaders - The Headers to be added to the HTTP response on a rate limit event
type MeshRateLimitItemHeaders struct {
	Add []MeshRateLimitItemAdd `json:"add,omitempty"`
	Set []MeshRateLimitItemSet `json:"set,omitempty"`
}

func (m *MeshRateLimitItemHeaders) GetAdd() []MeshRateLimitItemAdd {
	if m == nil {
		return nil
	}
	return m.Add
}

func (m *MeshRateLimitItemHeaders) GetSet() []MeshRateLimitItemSet {
	if m == nil {
		return nil
	}
	return m.Set
}

// MeshRateLimitItemSpecFromOnRateLimit - Describes the actions to take on a rate limit event
type MeshRateLimitItemSpecFromOnRateLimit struct {
	// The Headers to be added to the HTTP response on a rate limit event
	Headers *MeshRateLimitItemHeaders `json:"headers,omitempty"`
	// The HTTP status code to be set on a rate limit event
	Status *int `json:"status,omitempty"`
}

func (m *MeshRateLimitItemSpecFromOnRateLimit) GetHeaders() *MeshRateLimitItemHeaders {
	if m == nil {
		return nil
	}
	return m.Headers
}

func (m *MeshRateLimitItemSpecFromOnRateLimit) GetStatus() *int {
	if m == nil {
		return nil
	}
	return m.Status
}

// MeshRateLimitItemSpecFromRequestRate - Defines how many requests are allowed per interval.
type MeshRateLimitItemSpecFromRequestRate struct {
	// The interval the number of units is accounted for.
	Interval string `json:"interval"`
	// Number of units per interval (depending on usage it can be a number of requests,
	// or a number of connections).
	Num int `json:"num"`
}

func (m *MeshRateLimitItemSpecFromRequestRate) GetInterval() string {
	if m == nil {
		return ""
	}
	return m.Interval
}

func (m *MeshRateLimitItemSpecFromRequestRate) GetNum() int {
	if m == nil {
		return 0
	}
	return m.Num
}

// MeshRateLimitItemHTTP - LocalHTTP defines configuration of local HTTP rate limiting
// https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/local_rate_limit_filter
type MeshRateLimitItemHTTP struct {
	// Define if rate limiting should be disabled.
	Disabled *bool `json:"disabled,omitempty"`
	// Describes the actions to take on a rate limit event
	OnRateLimit *MeshRateLimitItemSpecFromOnRateLimit `json:"onRateLimit,omitempty"`
	// Defines how many requests are allowed per interval.
	RequestRate *MeshRateLimitItemSpecFromRequestRate `json:"requestRate,omitempty"`
}

func (m *MeshRateLimitItemHTTP) GetDisabled() *bool {
	if m == nil {
		return nil
	}
	return m.Disabled
}

func (m *MeshRateLimitItemHTTP) GetOnRateLimit() *MeshRateLimitItemSpecFromOnRateLimit {
	if m == nil {
		return nil
	}
	return m.OnRateLimit
}

func (m *MeshRateLimitItemHTTP) GetRequestRate() *MeshRateLimitItemSpecFromRequestRate {
	if m == nil {
		return nil
	}
	return m.RequestRate
}

// ConnectionRate - Defines how many connections are allowed per interval.
type ConnectionRate struct {
	// The interval the number of units is accounted for.
	Interval string `json:"interval"`
	// Number of units per interval (depending on usage it can be a number of requests,
	// or a number of connections).
	Num int `json:"num"`
}

func (c *ConnectionRate) GetInterval() string {
	if c == nil {
		return ""
	}
	return c.Interval
}

func (c *ConnectionRate) GetNum() int {
	if c == nil {
		return 0
	}
	return c.Num
}

// MeshRateLimitItemTCP - LocalTCP defines confguration of local TCP rate limiting
// https://www.envoyproxy.io/docs/envoy/latest/configuration/listeners/network_filters/local_rate_limit_filter
type MeshRateLimitItemTCP struct {
	// Defines how many connections are allowed per interval.
	ConnectionRate *ConnectionRate `json:"connectionRate,omitempty"`
	// Define if rate limiting should be disabled.
	// Default: false
	Disabled *bool `json:"disabled,omitempty"`
}

func (m *MeshRateLimitItemTCP) GetConnectionRate() *ConnectionRate {
	if m == nil {
		return nil
	}
	return m.ConnectionRate
}

func (m *MeshRateLimitItemTCP) GetDisabled() *bool {
	if m == nil {
		return nil
	}
	return m.Disabled
}

// Local - LocalConf defines local http or/and tcp rate limit configuration
type Local struct {
	// LocalHTTP defines configuration of local HTTP rate limiting
	// https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/local_rate_limit_filter
	HTTP *MeshRateLimitItemHTTP `json:"http,omitempty"`
	// LocalTCP defines confguration of local TCP rate limiting
	// https://www.envoyproxy.io/docs/envoy/latest/configuration/listeners/network_filters/local_rate_limit_filter
	TCP *MeshRateLimitItemTCP `json:"tcp,omitempty"`
}

func (l *Local) GetHTTP() *MeshRateLimitItemHTTP {
	if l == nil {
		return nil
	}
	return l.HTTP
}

func (l *Local) GetTCP() *MeshRateLimitItemTCP {
	if l == nil {
		return nil
	}
	return l.TCP
}

// MeshRateLimitItemDefault - Default is a configuration specific to the group of clients referenced in
// 'targetRef'
type MeshRateLimitItemDefault struct {
	// LocalConf defines local http or/and tcp rate limit configuration
	Local *Local `json:"local,omitempty"`
}

func (m *MeshRateLimitItemDefault) GetLocal() *Local {
	if m == nil {
		return nil
	}
	return m.Local
}

// MeshRateLimitItemSpecKind - Kind of the referenced resource
type MeshRateLimitItemSpecKind string

const (
	MeshRateLimitItemSpecKindMesh                 MeshRateLimitItemSpecKind = "Mesh"
	MeshRateLimitItemSpecKindMeshSubset           MeshRateLimitItemSpecKind = "MeshSubset"
	MeshRateLimitItemSpecKindMeshGateway          MeshRateLimitItemSpecKind = "MeshGateway"
	MeshRateLimitItemSpecKindMeshService          MeshRateLimitItemSpecKind = "MeshService"
	MeshRateLimitItemSpecKindMeshExternalService  MeshRateLimitItemSpecKind = "MeshExternalService"
	MeshRateLimitItemSpecKindMeshMultiZoneService MeshRateLimitItemSpecKind = "MeshMultiZoneService"
	MeshRateLimitItemSpecKindMeshServiceSubset    MeshRateLimitItemSpecKind = "MeshServiceSubset"
	MeshRateLimitItemSpecKindMeshHTTPRoute        MeshRateLimitItemSpecKind = "MeshHTTPRoute"
	MeshRateLimitItemSpecKindDataplane            MeshRateLimitItemSpecKind = "Dataplane"
)

func (e MeshRateLimitItemSpecKind) ToPointer() *MeshRateLimitItemSpecKind {
	return &e
}
func (e *MeshRateLimitItemSpecKind) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Mesh":
		fallthrough
	case "MeshSubset":
		fallthrough
	case "MeshGateway":
		fallthrough
	case "MeshService":
		fallthrough
	case "MeshExternalService":
		fallthrough
	case "MeshMultiZoneService":
		fallthrough
	case "MeshServiceSubset":
		fallthrough
	case "MeshHTTPRoute":
		fallthrough
	case "Dataplane":
		*e = MeshRateLimitItemSpecKind(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshRateLimitItemSpecKind: %v", v)
	}
}

type MeshRateLimitItemSpecProxyTypes string

const (
	MeshRateLimitItemSpecProxyTypesSidecar MeshRateLimitItemSpecProxyTypes = "Sidecar"
	MeshRateLimitItemSpecProxyTypesGateway MeshRateLimitItemSpecProxyTypes = "Gateway"
)

func (e MeshRateLimitItemSpecProxyTypes) ToPointer() *MeshRateLimitItemSpecProxyTypes {
	return &e
}
func (e *MeshRateLimitItemSpecProxyTypes) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Sidecar":
		fallthrough
	case "Gateway":
		*e = MeshRateLimitItemSpecProxyTypes(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshRateLimitItemSpecProxyTypes: %v", v)
	}
}

// MeshRateLimitItemSpecTargetRef - TargetRef is a reference to the resource that represents a group of
// clients.
type MeshRateLimitItemSpecTargetRef struct {
	// Kind of the referenced resource
	Kind MeshRateLimitItemSpecKind `json:"kind"`
	// Labels are used to select group of MeshServices that match labels. Either Labels or
	// Name and Namespace can be used.
	Labels map[string]string `json:"labels,omitempty"`
	// Mesh is reserved for future use to identify cross mesh resources.
	Mesh *string `json:"mesh,omitempty"`
	// Name of the referenced resource. Can only be used with kinds: `MeshService`,
	// `MeshServiceSubset` and `MeshGatewayRoute`
	Name *string `json:"name,omitempty"`
	// Namespace specifies the namespace of target resource. If empty only resources in policy namespace
	// will be targeted.
	Namespace *string `json:"namespace,omitempty"`
	// ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
	// all data plane types are targeted by the policy.
	ProxyTypes []MeshRateLimitItemSpecProxyTypes `json:"proxyTypes,omitempty"`
	// SectionName is used to target specific section of resource.
	// For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected.
	SectionName *string `json:"sectionName,omitempty"`
	// Tags used to select a subset of proxies by tags. Can only be used with kinds
	// `MeshSubset` and `MeshServiceSubset`
	Tags map[string]string `json:"tags,omitempty"`
}

func (m *MeshRateLimitItemSpecTargetRef) GetKind() MeshRateLimitItemSpecKind {
	if m == nil {
		return MeshRateLimitItemSpecKind("")
	}
	return m.Kind
}

func (m *MeshRateLimitItemSpecTargetRef) GetLabels() map[string]string {
	if m == nil {
		return nil
	}
	return m.Labels
}

func (m *MeshRateLimitItemSpecTargetRef) GetMesh() *string {
	if m == nil {
		return nil
	}
	return m.Mesh
}

func (m *MeshRateLimitItemSpecTargetRef) GetName() *string {
	if m == nil {
		return nil
	}
	return m.Name
}

func (m *MeshRateLimitItemSpecTargetRef) GetNamespace() *string {
	if m == nil {
		return nil
	}
	return m.Namespace
}

func (m *MeshRateLimitItemSpecTargetRef) GetProxyTypes() []MeshRateLimitItemSpecProxyTypes {
	if m == nil {
		return nil
	}
	return m.ProxyTypes
}

func (m *MeshRateLimitItemSpecTargetRef) GetSectionName() *string {
	if m == nil {
		return nil
	}
	return m.SectionName
}

func (m *MeshRateLimitItemSpecTargetRef) GetTags() map[string]string {
	if m == nil {
		return nil
	}
	return m.Tags
}

type MeshRateLimitItemFrom struct {
	// Default is a configuration specific to the group of clients referenced in
	// 'targetRef'
	Default *MeshRateLimitItemDefault `json:"default,omitempty"`
	// TargetRef is a reference to the resource that represents a group of
	// clients.
	TargetRef MeshRateLimitItemSpecTargetRef `json:"targetRef"`
}

func (m *MeshRateLimitItemFrom) GetDefault() *MeshRateLimitItemDefault {
	if m == nil {
		return nil
	}
	return m.Default
}

func (m *MeshRateLimitItemFrom) GetTargetRef() MeshRateLimitItemSpecTargetRef {
	if m == nil {
		return MeshRateLimitItemSpecTargetRef{}
	}
	return m.TargetRef
}

type MeshRateLimitItemSpecAdd struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

func (m *MeshRateLimitItemSpecAdd) GetName() string {
	if m == nil {
		return ""
	}
	return m.Name
}

func (m *MeshRateLimitItemSpecAdd) GetValue() string {
	if m == nil {
		return ""
	}
	return m.Value
}

type MeshRateLimitItemSpecSet struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

func (m *MeshRateLimitItemSpecSet) GetName() string {
	if m == nil {
		return ""
	}
	return m.Name
}

func (m *MeshRateLimitItemSpecSet) GetValue() string {
	if m == nil {
		return ""
	}
	return m.Value
}

// MeshRateLimitItemSpecHeaders - The Headers to be added to the HTTP response on a rate limit event
type MeshRateLimitItemSpecHeaders struct {
	Add []MeshRateLimitItemSpecAdd `json:"add,omitempty"`
	Set []MeshRateLimitItemSpecSet `json:"set,omitempty"`
}

func (m *MeshRateLimitItemSpecHeaders) GetAdd() []MeshRateLimitItemSpecAdd {
	if m == nil {
		return nil
	}
	return m.Add
}

func (m *MeshRateLimitItemSpecHeaders) GetSet() []MeshRateLimitItemSpecSet {
	if m == nil {
		return nil
	}
	return m.Set
}

// MeshRateLimitItemOnRateLimit - Describes the actions to take on a rate limit event
type MeshRateLimitItemOnRateLimit struct {
	// The Headers to be added to the HTTP response on a rate limit event
	Headers *MeshRateLimitItemSpecHeaders `json:"headers,omitempty"`
	// The HTTP status code to be set on a rate limit event
	Status *int `json:"status,omitempty"`
}

func (m *MeshRateLimitItemOnRateLimit) GetHeaders() *MeshRateLimitItemSpecHeaders {
	if m == nil {
		return nil
	}
	return m.Headers
}

func (m *MeshRateLimitItemOnRateLimit) GetStatus() *int {
	if m == nil {
		return nil
	}
	return m.Status
}

// MeshRateLimitItemRequestRate - Defines how many requests are allowed per interval.
type MeshRateLimitItemRequestRate struct {
	// The interval the number of units is accounted for.
	Interval string `json:"interval"`
	// Number of units per interval (depending on usage it can be a number of requests,
	// or a number of connections).
	Num int `json:"num"`
}

func (m *MeshRateLimitItemRequestRate) GetInterval() string {
	if m == nil {
		return ""
	}
	return m.Interval
}

func (m *MeshRateLimitItemRequestRate) GetNum() int {
	if m == nil {
		return 0
	}
	return m.Num
}

// MeshRateLimitItemSpecHTTP - LocalHTTP defines configuration of local HTTP rate limiting
// https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/local_rate_limit_filter
type MeshRateLimitItemSpecHTTP struct {
	// Define if rate limiting should be disabled.
	Disabled *bool `json:"disabled,omitempty"`
	// Describes the actions to take on a rate limit event
	OnRateLimit *MeshRateLimitItemOnRateLimit `json:"onRateLimit,omitempty"`
	// Defines how many requests are allowed per interval.
	RequestRate *MeshRateLimitItemRequestRate `json:"requestRate,omitempty"`
}

func (m *MeshRateLimitItemSpecHTTP) GetDisabled() *bool {
	if m == nil {
		return nil
	}
	return m.Disabled
}

func (m *MeshRateLimitItemSpecHTTP) GetOnRateLimit() *MeshRateLimitItemOnRateLimit {
	if m == nil {
		return nil
	}
	return m.OnRateLimit
}

func (m *MeshRateLimitItemSpecHTTP) GetRequestRate() *MeshRateLimitItemRequestRate {
	if m == nil {
		return nil
	}
	return m.RequestRate
}

// MeshRateLimitItemConnectionRate - Defines how many connections are allowed per interval.
type MeshRateLimitItemConnectionRate struct {
	// The interval the number of units is accounted for.
	Interval string `json:"interval"`
	// Number of units per interval (depending on usage it can be a number of requests,
	// or a number of connections).
	Num int `json:"num"`
}

func (m *MeshRateLimitItemConnectionRate) GetInterval() string {
	if m == nil {
		return ""
	}
	return m.Interval
}

func (m *MeshRateLimitItemConnectionRate) GetNum() int {
	if m == nil {
		return 0
	}
	return m.Num
}

// MeshRateLimitItemSpecTCP - LocalTCP defines confguration of local TCP rate limiting
// https://www.envoyproxy.io/docs/envoy/latest/configuration/listeners/network_filters/local_rate_limit_filter
type MeshRateLimitItemSpecTCP struct {
	// Defines how many connections are allowed per interval.
	ConnectionRate *MeshRateLimitItemConnectionRate `json:"connectionRate,omitempty"`
	// Define if rate limiting should be disabled.
	// Default: false
	Disabled *bool `json:"disabled,omitempty"`
}

func (m *MeshRateLimitItemSpecTCP) GetConnectionRate() *MeshRateLimitItemConnectionRate {
	if m == nil {
		return nil
	}
	return m.ConnectionRate
}

func (m *MeshRateLimitItemSpecTCP) GetDisabled() *bool {
	if m == nil {
		return nil
	}
	return m.Disabled
}

// MeshRateLimitItemLocal - LocalConf defines local http or/and tcp rate limit configuration
type MeshRateLimitItemLocal struct {
	// LocalHTTP defines configuration of local HTTP rate limiting
	// https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/local_rate_limit_filter
	HTTP *MeshRateLimitItemSpecHTTP `json:"http,omitempty"`
	// LocalTCP defines confguration of local TCP rate limiting
	// https://www.envoyproxy.io/docs/envoy/latest/configuration/listeners/network_filters/local_rate_limit_filter
	TCP *MeshRateLimitItemSpecTCP `json:"tcp,omitempty"`
}

func (m *MeshRateLimitItemLocal) GetHTTP() *MeshRateLimitItemSpecHTTP {
	if m == nil {
		return nil
	}
	return m.HTTP
}

func (m *MeshRateLimitItemLocal) GetTCP() *MeshRateLimitItemSpecTCP {
	if m == nil {
		return nil
	}
	return m.TCP
}

// MeshRateLimitItemSpecDefault - Default contains configuration of the inbound rate limits
type MeshRateLimitItemSpecDefault struct {
	// LocalConf defines local http or/and tcp rate limit configuration
	Local *MeshRateLimitItemLocal `json:"local,omitempty"`
}

func (m *MeshRateLimitItemSpecDefault) GetLocal() *MeshRateLimitItemLocal {
	if m == nil {
		return nil
	}
	return m.Local
}

type MeshRateLimitItemRules struct {
	// Default contains configuration of the inbound rate limits
	Default *MeshRateLimitItemSpecDefault `json:"default,omitempty"`
}

func (m *MeshRateLimitItemRules) GetDefault() *MeshRateLimitItemSpecDefault {
	if m == nil {
		return nil
	}
	return m.Default
}

// MeshRateLimitItemKind - Kind of the referenced resource
type MeshRateLimitItemKind string

const (
	MeshRateLimitItemKindMesh                 MeshRateLimitItemKind = "Mesh"
	MeshRateLimitItemKindMeshSubset           MeshRateLimitItemKind = "MeshSubset"
	MeshRateLimitItemKindMeshGateway          MeshRateLimitItemKind = "MeshGateway"
	MeshRateLimitItemKindMeshService          MeshRateLimitItemKind = "MeshService"
	MeshRateLimitItemKindMeshExternalService  MeshRateLimitItemKind = "MeshExternalService"
	MeshRateLimitItemKindMeshMultiZoneService MeshRateLimitItemKind = "MeshMultiZoneService"
	MeshRateLimitItemKindMeshServiceSubset    MeshRateLimitItemKind = "MeshServiceSubset"
	MeshRateLimitItemKindMeshHTTPRoute        MeshRateLimitItemKind = "MeshHTTPRoute"
	MeshRateLimitItemKindDataplane            MeshRateLimitItemKind = "Dataplane"
)

func (e MeshRateLimitItemKind) ToPointer() *MeshRateLimitItemKind {
	return &e
}
func (e *MeshRateLimitItemKind) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Mesh":
		fallthrough
	case "MeshSubset":
		fallthrough
	case "MeshGateway":
		fallthrough
	case "MeshService":
		fallthrough
	case "MeshExternalService":
		fallthrough
	case "MeshMultiZoneService":
		fallthrough
	case "MeshServiceSubset":
		fallthrough
	case "MeshHTTPRoute":
		fallthrough
	case "Dataplane":
		*e = MeshRateLimitItemKind(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshRateLimitItemKind: %v", v)
	}
}

type MeshRateLimitItemProxyTypes string

const (
	MeshRateLimitItemProxyTypesSidecar MeshRateLimitItemProxyTypes = "Sidecar"
	MeshRateLimitItemProxyTypesGateway MeshRateLimitItemProxyTypes = "Gateway"
)

func (e MeshRateLimitItemProxyTypes) ToPointer() *MeshRateLimitItemProxyTypes {
	return &e
}
func (e *MeshRateLimitItemProxyTypes) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Sidecar":
		fallthrough
	case "Gateway":
		*e = MeshRateLimitItemProxyTypes(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshRateLimitItemProxyTypes: %v", v)
	}
}

// MeshRateLimitItemTargetRef - TargetRef is a reference to the resource the policy takes an effect on.
// The resource could be either a real store object or virtual resource
// defined inplace.
type MeshRateLimitItemTargetRef struct {
	// Kind of the referenced resource
	Kind MeshRateLimitItemKind `json:"kind"`
	// Labels are used to select group of MeshServices that match labels. Either Labels or
	// Name and Namespace can be used.
	Labels map[string]string `json:"labels,omitempty"`
	// Mesh is reserved for future use to identify cross mesh resources.
	Mesh *string `json:"mesh,omitempty"`
	// Name of the referenced resource. Can only be used with kinds: `MeshService`,
	// `MeshServiceSubset` and `MeshGatewayRoute`
	Name *string `json:"name,omitempty"`
	// Namespace specifies the namespace of target resource. If empty only resources in policy namespace
	// will be targeted.
	Namespace *string `json:"namespace,omitempty"`
	// ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
	// all data plane types are targeted by the policy.
	ProxyTypes []MeshRateLimitItemProxyTypes `json:"proxyTypes,omitempty"`
	// SectionName is used to target specific section of resource.
	// For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected.
	SectionName *string `json:"sectionName,omitempty"`
	// Tags used to select a subset of proxies by tags. Can only be used with kinds
	// `MeshSubset` and `MeshServiceSubset`
	Tags map[string]string `json:"tags,omitempty"`
}

func (m *MeshRateLimitItemTargetRef) GetKind() MeshRateLimitItemKind {
	if m == nil {
		return MeshRateLimitItemKind("")
	}
	return m.Kind
}

func (m *MeshRateLimitItemTargetRef) GetLabels() map[string]string {
	if m == nil {
		return nil
	}
	return m.Labels
}

func (m *MeshRateLimitItemTargetRef) GetMesh() *string {
	if m == nil {
		return nil
	}
	return m.Mesh
}

func (m *MeshRateLimitItemTargetRef) GetName() *string {
	if m == nil {
		return nil
	}
	return m.Name
}

func (m *MeshRateLimitItemTargetRef) GetNamespace() *string {
	if m == nil {
		return nil
	}
	return m.Namespace
}

func (m *MeshRateLimitItemTargetRef) GetProxyTypes() []MeshRateLimitItemProxyTypes {
	if m == nil {
		return nil
	}
	return m.ProxyTypes
}

func (m *MeshRateLimitItemTargetRef) GetSectionName() *string {
	if m == nil {
		return nil
	}
	return m.SectionName
}

func (m *MeshRateLimitItemTargetRef) GetTags() map[string]string {
	if m == nil {
		return nil
	}
	return m.Tags
}

type MeshRateLimitItemSpecToAdd struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

func (m *MeshRateLimitItemSpecToAdd) GetName() string {
	if m == nil {
		return ""
	}
	return m.Name
}

func (m *MeshRateLimitItemSpecToAdd) GetValue() string {
	if m == nil {
		return ""
	}
	return m.Value
}

type MeshRateLimitItemSpecToSet struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

func (m *MeshRateLimitItemSpecToSet) GetName() string {
	if m == nil {
		return ""
	}
	return m.Name
}

func (m *MeshRateLimitItemSpecToSet) GetValue() string {
	if m == nil {
		return ""
	}
	return m.Value
}

// MeshRateLimitItemSpecToHeaders - The Headers to be added to the HTTP response on a rate limit event
type MeshRateLimitItemSpecToHeaders struct {
	Add []MeshRateLimitItemSpecToAdd `json:"add,omitempty"`
	Set []MeshRateLimitItemSpecToSet `json:"set,omitempty"`
}

func (m *MeshRateLimitItemSpecToHeaders) GetAdd() []MeshRateLimitItemSpecToAdd {
	if m == nil {
		return nil
	}
	return m.Add
}

func (m *MeshRateLimitItemSpecToHeaders) GetSet() []MeshRateLimitItemSpecToSet {
	if m == nil {
		return nil
	}
	return m.Set
}

// MeshRateLimitItemSpecOnRateLimit - Describes the actions to take on a rate limit event
type MeshRateLimitItemSpecOnRateLimit struct {
	// The Headers to be added to the HTTP response on a rate limit event
	Headers *MeshRateLimitItemSpecToHeaders `json:"headers,omitempty"`
	// The HTTP status code to be set on a rate limit event
	Status *int `json:"status,omitempty"`
}

func (m *MeshRateLimitItemSpecOnRateLimit) GetHeaders() *MeshRateLimitItemSpecToHeaders {
	if m == nil {
		return nil
	}
	return m.Headers
}

func (m *MeshRateLimitItemSpecOnRateLimit) GetStatus() *int {
	if m == nil {
		return nil
	}
	return m.Status
}

// MeshRateLimitItemSpecRequestRate - Defines how many requests are allowed per interval.
type MeshRateLimitItemSpecRequestRate struct {
	// The interval the number of units is accounted for.
	Interval string `json:"interval"`
	// Number of units per interval (depending on usage it can be a number of requests,
	// or a number of connections).
	Num int `json:"num"`
}

func (m *MeshRateLimitItemSpecRequestRate) GetInterval() string {
	if m == nil {
		return ""
	}
	return m.Interval
}

func (m *MeshRateLimitItemSpecRequestRate) GetNum() int {
	if m == nil {
		return 0
	}
	return m.Num
}

// MeshRateLimitItemSpecToHTTP - LocalHTTP defines configuration of local HTTP rate limiting
// https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/local_rate_limit_filter
type MeshRateLimitItemSpecToHTTP struct {
	// Define if rate limiting should be disabled.
	Disabled *bool `json:"disabled,omitempty"`
	// Describes the actions to take on a rate limit event
	OnRateLimit *MeshRateLimitItemSpecOnRateLimit `json:"onRateLimit,omitempty"`
	// Defines how many requests are allowed per interval.
	RequestRate *MeshRateLimitItemSpecRequestRate `json:"requestRate,omitempty"`
}

func (m *MeshRateLimitItemSpecToHTTP) GetDisabled() *bool {
	if m == nil {
		return nil
	}
	return m.Disabled
}

func (m *MeshRateLimitItemSpecToHTTP) GetOnRateLimit() *MeshRateLimitItemSpecOnRateLimit {
	if m == nil {
		return nil
	}
	return m.OnRateLimit
}

func (m *MeshRateLimitItemSpecToHTTP) GetRequestRate() *MeshRateLimitItemSpecRequestRate {
	if m == nil {
		return nil
	}
	return m.RequestRate
}

// MeshRateLimitItemSpecConnectionRate - Defines how many connections are allowed per interval.
type MeshRateLimitItemSpecConnectionRate struct {
	// The interval the number of units is accounted for.
	Interval string `json:"interval"`
	// Number of units per interval (depending on usage it can be a number of requests,
	// or a number of connections).
	Num int `json:"num"`
}

func (m *MeshRateLimitItemSpecConnectionRate) GetInterval() string {
	if m == nil {
		return ""
	}
	return m.Interval
}

func (m *MeshRateLimitItemSpecConnectionRate) GetNum() int {
	if m == nil {
		return 0
	}
	return m.Num
}

// MeshRateLimitItemSpecToTCP - LocalTCP defines confguration of local TCP rate limiting
// https://www.envoyproxy.io/docs/envoy/latest/configuration/listeners/network_filters/local_rate_limit_filter
type MeshRateLimitItemSpecToTCP struct {
	// Defines how many connections are allowed per interval.
	ConnectionRate *MeshRateLimitItemSpecConnectionRate `json:"connectionRate,omitempty"`
	// Define if rate limiting should be disabled.
	// Default: false
	Disabled *bool `json:"disabled,omitempty"`
}

func (m *MeshRateLimitItemSpecToTCP) GetConnectionRate() *MeshRateLimitItemSpecConnectionRate {
	if m == nil {
		return nil
	}
	return m.ConnectionRate
}

func (m *MeshRateLimitItemSpecToTCP) GetDisabled() *bool {
	if m == nil {
		return nil
	}
	return m.Disabled
}

// MeshRateLimitItemSpecLocal - LocalConf defines local http or/and tcp rate limit configuration
type MeshRateLimitItemSpecLocal struct {
	// LocalHTTP defines configuration of local HTTP rate limiting
	// https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/local_rate_limit_filter
	HTTP *MeshRateLimitItemSpecToHTTP `json:"http,omitempty"`
	// LocalTCP defines confguration of local TCP rate limiting
	// https://www.envoyproxy.io/docs/envoy/latest/configuration/listeners/network_filters/local_rate_limit_filter
	TCP *MeshRateLimitItemSpecToTCP `json:"tcp,omitempty"`
}

func (m *MeshRateLimitItemSpecLocal) GetHTTP() *MeshRateLimitItemSpecToHTTP {
	if m == nil {
		return nil
	}
	return m.HTTP
}

func (m *MeshRateLimitItemSpecLocal) GetTCP() *MeshRateLimitItemSpecToTCP {
	if m == nil {
		return nil
	}
	return m.TCP
}

// MeshRateLimitItemSpecToDefault - Default is a configuration specific to the group of clients referenced in
// 'targetRef'
type MeshRateLimitItemSpecToDefault struct {
	// LocalConf defines local http or/and tcp rate limit configuration
	Local *MeshRateLimitItemSpecLocal `json:"local,omitempty"`
}

func (m *MeshRateLimitItemSpecToDefault) GetLocal() *MeshRateLimitItemSpecLocal {
	if m == nil {
		return nil
	}
	return m.Local
}

// MeshRateLimitItemSpecToKind - Kind of the referenced resource
type MeshRateLimitItemSpecToKind string

const (
	MeshRateLimitItemSpecToKindMesh                 MeshRateLimitItemSpecToKind = "Mesh"
	MeshRateLimitItemSpecToKindMeshSubset           MeshRateLimitItemSpecToKind = "MeshSubset"
	MeshRateLimitItemSpecToKindMeshGateway          MeshRateLimitItemSpecToKind = "MeshGateway"
	MeshRateLimitItemSpecToKindMeshService          MeshRateLimitItemSpecToKind = "MeshService"
	MeshRateLimitItemSpecToKindMeshExternalService  MeshRateLimitItemSpecToKind = "MeshExternalService"
	MeshRateLimitItemSpecToKindMeshMultiZoneService MeshRateLimitItemSpecToKind = "MeshMultiZoneService"
	MeshRateLimitItemSpecToKindMeshServiceSubset    MeshRateLimitItemSpecToKind = "MeshServiceSubset"
	MeshRateLimitItemSpecToKindMeshHTTPRoute        MeshRateLimitItemSpecToKind = "MeshHTTPRoute"
	MeshRateLimitItemSpecToKindDataplane            MeshRateLimitItemSpecToKind = "Dataplane"
)

func (e MeshRateLimitItemSpecToKind) ToPointer() *MeshRateLimitItemSpecToKind {
	return &e
}
func (e *MeshRateLimitItemSpecToKind) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Mesh":
		fallthrough
	case "MeshSubset":
		fallthrough
	case "MeshGateway":
		fallthrough
	case "MeshService":
		fallthrough
	case "MeshExternalService":
		fallthrough
	case "MeshMultiZoneService":
		fallthrough
	case "MeshServiceSubset":
		fallthrough
	case "MeshHTTPRoute":
		fallthrough
	case "Dataplane":
		*e = MeshRateLimitItemSpecToKind(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshRateLimitItemSpecToKind: %v", v)
	}
}

type MeshRateLimitItemSpecToProxyTypes string

const (
	MeshRateLimitItemSpecToProxyTypesSidecar MeshRateLimitItemSpecToProxyTypes = "Sidecar"
	MeshRateLimitItemSpecToProxyTypesGateway MeshRateLimitItemSpecToProxyTypes = "Gateway"
)

func (e MeshRateLimitItemSpecToProxyTypes) ToPointer() *MeshRateLimitItemSpecToProxyTypes {
	return &e
}
func (e *MeshRateLimitItemSpecToProxyTypes) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Sidecar":
		fallthrough
	case "Gateway":
		*e = MeshRateLimitItemSpecToProxyTypes(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshRateLimitItemSpecToProxyTypes: %v", v)
	}
}

// MeshRateLimitItemSpecToTargetRef - TargetRef is a reference to the resource that represents a group of
// clients.
type MeshRateLimitItemSpecToTargetRef struct {
	// Kind of the referenced resource
	Kind MeshRateLimitItemSpecToKind `json:"kind"`
	// Labels are used to select group of MeshServices that match labels. Either Labels or
	// Name and Namespace can be used.
	Labels map[string]string `json:"labels,omitempty"`
	// Mesh is reserved for future use to identify cross mesh resources.
	Mesh *string `json:"mesh,omitempty"`
	// Name of the referenced resource. Can only be used with kinds: `MeshService`,
	// `MeshServiceSubset` and `MeshGatewayRoute`
	Name *string `json:"name,omitempty"`
	// Namespace specifies the namespace of target resource. If empty only resources in policy namespace
	// will be targeted.
	Namespace *string `json:"namespace,omitempty"`
	// ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
	// all data plane types are targeted by the policy.
	ProxyTypes []MeshRateLimitItemSpecToProxyTypes `json:"proxyTypes,omitempty"`
	// SectionName is used to target specific section of resource.
	// For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected.
	SectionName *string `json:"sectionName,omitempty"`
	// Tags used to select a subset of proxies by tags. Can only be used with kinds
	// `MeshSubset` and `MeshServiceSubset`
	Tags map[string]string `json:"tags,omitempty"`
}

func (m *MeshRateLimitItemSpecToTargetRef) GetKind() MeshRateLimitItemSpecToKind {
	if m == nil {
		return MeshRateLimitItemSpecToKind("")
	}
	return m.Kind
}

func (m *MeshRateLimitItemSpecToTargetRef) GetLabels() map[string]string {
	if m == nil {
		return nil
	}
	return m.Labels
}

func (m *MeshRateLimitItemSpecToTargetRef) GetMesh() *string {
	if m == nil {
		return nil
	}
	return m.Mesh
}

func (m *MeshRateLimitItemSpecToTargetRef) GetName() *string {
	if m == nil {
		return nil
	}
	return m.Name
}

func (m *MeshRateLimitItemSpecToTargetRef) GetNamespace() *string {
	if m == nil {
		return nil
	}
	return m.Namespace
}

func (m *MeshRateLimitItemSpecToTargetRef) GetProxyTypes() []MeshRateLimitItemSpecToProxyTypes {
	if m == nil {
		return nil
	}
	return m.ProxyTypes
}

func (m *MeshRateLimitItemSpecToTargetRef) GetSectionName() *string {
	if m == nil {
		return nil
	}
	return m.SectionName
}

func (m *MeshRateLimitItemSpecToTargetRef) GetTags() map[string]string {
	if m == nil {
		return nil
	}
	return m.Tags
}

type MeshRateLimitItemTo struct {
	// Default is a configuration specific to the group of clients referenced in
	// 'targetRef'
	Default *MeshRateLimitItemSpecToDefault `json:"default,omitempty"`
	// TargetRef is a reference to the resource that represents a group of
	// clients.
	TargetRef MeshRateLimitItemSpecToTargetRef `json:"targetRef"`
}

func (m *MeshRateLimitItemTo) GetDefault() *MeshRateLimitItemSpecToDefault {
	if m == nil {
		return nil
	}
	return m.Default
}

func (m *MeshRateLimitItemTo) GetTargetRef() MeshRateLimitItemSpecToTargetRef {
	if m == nil {
		return MeshRateLimitItemSpecToTargetRef{}
	}
	return m.TargetRef
}

// MeshRateLimitItemSpec - Spec is the specification of the Kuma MeshRateLimit resource.
type MeshRateLimitItemSpec struct {
	// From list makes a match between clients and corresponding configurations
	From []MeshRateLimitItemFrom `json:"from,omitempty"`
	// Rules defines inbound rate limiting configurations. Currently limited to
	// selecting all inbound traffic, as L7 matching is not yet implemented.
	Rules []MeshRateLimitItemRules `json:"rules,omitempty"`
	// TargetRef is a reference to the resource the policy takes an effect on.
	// The resource could be either a real store object or virtual resource
	// defined inplace.
	TargetRef *MeshRateLimitItemTargetRef `json:"targetRef,omitempty"`
	// To list makes a match between clients and corresponding configurations
	To []MeshRateLimitItemTo `json:"to,omitempty"`
}

func (m *MeshRateLimitItemSpec) GetFrom() []MeshRateLimitItemFrom {
	if m == nil {
		return nil
	}
	return m.From
}

func (m *MeshRateLimitItemSpec) GetRules() []MeshRateLimitItemRules {
	if m == nil {
		return nil
	}
	return m.Rules
}

func (m *MeshRateLimitItemSpec) GetTargetRef() *MeshRateLimitItemTargetRef {
	if m == nil {
		return nil
	}
	return m.TargetRef
}

func (m *MeshRateLimitItemSpec) GetTo() []MeshRateLimitItemTo {
	if m == nil {
		return nil
	}
	return m.To
}

// MeshRateLimitItem - Successful response
type MeshRateLimitItem struct {
	// the type of the resource
	Type MeshRateLimitItemType `json:"type"`
	// Mesh is the name of the Kuma mesh this resource belongs to. It may be omitted for cluster-scoped resources.
	Mesh *string `default:"default" json:"mesh"`
	// Name of the Kuma resource
	Name string `json:"name"`
	// The labels to help identity resources
	Labels map[string]string `json:"labels,omitempty"`
	// Spec is the specification of the Kuma MeshRateLimit resource.
	Spec MeshRateLimitItemSpec `json:"spec"`
	// Time at which the resource was created
	CreationTime *time.Time `json:"creationTime,omitempty"`
	// Time at which the resource was updated
	ModificationTime *time.Time `json:"modificationTime,omitempty"`
}

func (m MeshRateLimitItem) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(m, "", false)
}

func (m *MeshRateLimitItem) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &m, "", false, []string{"type", "name", "spec"}); err != nil {
		return err
	}
	return nil
}

func (m *MeshRateLimitItem) GetType() MeshRateLimitItemType {
	if m == nil {
		return MeshRateLimitItemType("")
	}
	return m.Type
}

func (m *MeshRateLimitItem) GetMesh() *string {
	if m == nil {
		return nil
	}
	return m.Mesh
}

func (m *MeshRateLimitItem) GetName() string {
	if m == nil {
		return ""
	}
	return m.Name
}

func (m *MeshRateLimitItem) GetLabels() map[string]string {
	if m == nil {
		return nil
	}
	return m.Labels
}

func (m *MeshRateLimitItem) GetSpec() MeshRateLimitItemSpec {
	if m == nil {
		return MeshRateLimitItemSpec{}
	}
	return m.Spec
}

func (m *MeshRateLimitItem) GetCreationTime() *time.Time {
	if m == nil {
		return nil
	}
	return m.CreationTime
}

func (m *MeshRateLimitItem) GetModificationTime() *time.Time {
	if m == nil {
		return nil
	}
	return m.ModificationTime
}

type MeshRateLimitItemInput struct {
	// the type of the resource
	Type MeshRateLimitItemType `json:"type"`
	// Mesh is the name of the Kuma mesh this resource belongs to. It may be omitted for cluster-scoped resources.
	Mesh *string `default:"default" json:"mesh"`
	// Name of the Kuma resource
	Name string `json:"name"`
	// The labels to help identity resources
	Labels map[string]string `json:"labels,omitempty"`
	// Spec is the specification of the Kuma MeshRateLimit resource.
	Spec MeshRateLimitItemSpec `json:"spec"`
}

func (m MeshRateLimitItemInput) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(m, "", false)
}

func (m *MeshRateLimitItemInput) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &m, "", false, []string{"type", "name", "spec"}); err != nil {
		return err
	}
	return nil
}

func (m *MeshRateLimitItemInput) GetType() MeshRateLimitItemType {
	if m == nil {
		return MeshRateLimitItemType("")
	}
	return m.Type
}

func (m *MeshRateLimitItemInput) GetMesh() *string {
	if m == nil {
		return nil
	}
	return m.Mesh
}

func (m *MeshRateLimitItemInput) GetName() string {
	if m == nil {
		return ""
	}
	return m.Name
}

func (m *MeshRateLimitItemInput) GetLabels() map[string]string {
	if m == nil {
		return nil
	}
	return m.Labels
}

func (m *MeshRateLimitItemInput) GetSpec() MeshRateLimitItemSpec {
	if m == nil {
		return MeshRateLimitItemSpec{}
	}
	return m.Spec
}
