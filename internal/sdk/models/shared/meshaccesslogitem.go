// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
	"github.com/kong/terraform-provider-kong-mesh/internal/sdk/internal/utils"
	"time"
)

// Type - the type of the resource
type Type string

const (
	TypeMeshAccessLog Type = "MeshAccessLog"
)

func (e Type) ToPointer() *Type {
	return &e
}
func (e *Type) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "MeshAccessLog":
		*e = Type(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Type: %v", v)
	}
}

type JSON struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

func (j *JSON) GetKey() string {
	if j == nil {
		return ""
	}
	return j.Key
}

func (j *JSON) GetValue() string {
	if j == nil {
		return ""
	}
	return j.Value
}

type MeshAccessLogItemSpecFromType string

const (
	MeshAccessLogItemSpecFromTypePlain MeshAccessLogItemSpecFromType = "Plain"
	MeshAccessLogItemSpecFromTypeJSON  MeshAccessLogItemSpecFromType = "Json"
)

func (e MeshAccessLogItemSpecFromType) ToPointer() *MeshAccessLogItemSpecFromType {
	return &e
}
func (e *MeshAccessLogItemSpecFromType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Plain":
		fallthrough
	case "Json":
		*e = MeshAccessLogItemSpecFromType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshAccessLogItemSpecFromType: %v", v)
	}
}

// Format of access logs. Placeholders available on
// https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators
type Format struct {
	JSON            []JSON                        `json:"json,omitempty"`
	OmitEmptyValues *bool                         `default:"false" json:"omitEmptyValues"`
	Plain           *string                       `json:"plain,omitempty"`
	Type            MeshAccessLogItemSpecFromType `json:"type"`
}

func (f Format) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(f, "", false)
}

func (f *Format) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &f, "", false, []string{"type"}); err != nil {
		return err
	}
	return nil
}

func (f *Format) GetJSON() []JSON {
	if f == nil {
		return nil
	}
	return f.JSON
}

func (f *Format) GetOmitEmptyValues() *bool {
	if f == nil {
		return nil
	}
	return f.OmitEmptyValues
}

func (f *Format) GetPlain() *string {
	if f == nil {
		return nil
	}
	return f.Plain
}

func (f *Format) GetType() MeshAccessLogItemSpecFromType {
	if f == nil {
		return MeshAccessLogItemSpecFromType("")
	}
	return f.Type
}

// File - FileBackend defines configuration for file based access logs
type File struct {
	// Format of access logs. Placeholders available on
	// https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators
	Format *Format `json:"format,omitempty"`
	// Path to a file that logs will be written to
	Path string `json:"path"`
}

func (f *File) GetFormat() *Format {
	if f == nil {
		return nil
	}
	return f.Format
}

func (f *File) GetPath() string {
	if f == nil {
		return ""
	}
	return f.Path
}

type Attributes struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

func (a *Attributes) GetKey() string {
	if a == nil {
		return ""
	}
	return a.Key
}

func (a *Attributes) GetValue() string {
	if a == nil {
		return ""
	}
	return a.Value
}

// MeshAccessLogItemSpecFromOpenTelemetry - Defines an OpenTelemetry logging backend.
type MeshAccessLogItemSpecFromOpenTelemetry struct {
	// Attributes can contain placeholders available on
	// https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators
	Attributes []Attributes `json:"attributes,omitempty"`
	// Body is a raw string or an OTLP any value as described at
	// https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/logs/data-model.md#field-body
	// It can contain placeholders available on
	// https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators
	Body any `json:"body,omitempty"`
	// Endpoint of OpenTelemetry collector. An empty port defaults to 4317.
	Endpoint string `json:"endpoint"`
}

func (m *MeshAccessLogItemSpecFromOpenTelemetry) GetAttributes() []Attributes {
	if m == nil {
		return nil
	}
	return m.Attributes
}

func (m *MeshAccessLogItemSpecFromOpenTelemetry) GetBody() any {
	if m == nil {
		return nil
	}
	return m.Body
}

func (m *MeshAccessLogItemSpecFromOpenTelemetry) GetEndpoint() string {
	if m == nil {
		return ""
	}
	return m.Endpoint
}

type MeshAccessLogItemJSON struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

func (m *MeshAccessLogItemJSON) GetKey() string {
	if m == nil {
		return ""
	}
	return m.Key
}

func (m *MeshAccessLogItemJSON) GetValue() string {
	if m == nil {
		return ""
	}
	return m.Value
}

type MeshAccessLogItemSpecFromDefaultType string

const (
	MeshAccessLogItemSpecFromDefaultTypePlain MeshAccessLogItemSpecFromDefaultType = "Plain"
	MeshAccessLogItemSpecFromDefaultTypeJSON  MeshAccessLogItemSpecFromDefaultType = "Json"
)

func (e MeshAccessLogItemSpecFromDefaultType) ToPointer() *MeshAccessLogItemSpecFromDefaultType {
	return &e
}
func (e *MeshAccessLogItemSpecFromDefaultType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Plain":
		fallthrough
	case "Json":
		*e = MeshAccessLogItemSpecFromDefaultType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshAccessLogItemSpecFromDefaultType: %v", v)
	}
}

// MeshAccessLogItemFormat - Format of access logs. Placeholders available on
// https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators
type MeshAccessLogItemFormat struct {
	JSON            []MeshAccessLogItemJSON              `json:"json,omitempty"`
	OmitEmptyValues *bool                                `default:"false" json:"omitEmptyValues"`
	Plain           *string                              `json:"plain,omitempty"`
	Type            MeshAccessLogItemSpecFromDefaultType `json:"type"`
}

func (m MeshAccessLogItemFormat) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(m, "", false)
}

func (m *MeshAccessLogItemFormat) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &m, "", false, []string{"type"}); err != nil {
		return err
	}
	return nil
}

func (m *MeshAccessLogItemFormat) GetJSON() []MeshAccessLogItemJSON {
	if m == nil {
		return nil
	}
	return m.JSON
}

func (m *MeshAccessLogItemFormat) GetOmitEmptyValues() *bool {
	if m == nil {
		return nil
	}
	return m.OmitEmptyValues
}

func (m *MeshAccessLogItemFormat) GetPlain() *string {
	if m == nil {
		return nil
	}
	return m.Plain
}

func (m *MeshAccessLogItemFormat) GetType() MeshAccessLogItemSpecFromDefaultType {
	if m == nil {
		return MeshAccessLogItemSpecFromDefaultType("")
	}
	return m.Type
}

// MeshAccessLogItemSpecFromTCP - TCPBackend defines a TCP logging backend.
type MeshAccessLogItemSpecFromTCP struct {
	// Address of the TCP logging backend
	Address string `json:"address"`
	// Format of access logs. Placeholders available on
	// https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators
	Format *MeshAccessLogItemFormat `json:"format,omitempty"`
}

func (m *MeshAccessLogItemSpecFromTCP) GetAddress() string {
	if m == nil {
		return ""
	}
	return m.Address
}

func (m *MeshAccessLogItemSpecFromTCP) GetFormat() *MeshAccessLogItemFormat {
	if m == nil {
		return nil
	}
	return m.Format
}

type MeshAccessLogItemType string

const (
	MeshAccessLogItemTypeTCP           MeshAccessLogItemType = "Tcp"
	MeshAccessLogItemTypeFile          MeshAccessLogItemType = "File"
	MeshAccessLogItemTypeOpenTelemetry MeshAccessLogItemType = "OpenTelemetry"
)

func (e MeshAccessLogItemType) ToPointer() *MeshAccessLogItemType {
	return &e
}
func (e *MeshAccessLogItemType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Tcp":
		fallthrough
	case "File":
		fallthrough
	case "OpenTelemetry":
		*e = MeshAccessLogItemType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshAccessLogItemType: %v", v)
	}
}

type MeshAccessLogItemSpecFromBackends struct {
	// FileBackend defines configuration for file based access logs
	File *File `json:"file,omitempty"`
	// Defines an OpenTelemetry logging backend.
	OpenTelemetry *MeshAccessLogItemSpecFromOpenTelemetry `json:"openTelemetry,omitempty"`
	// TCPBackend defines a TCP logging backend.
	TCP  *MeshAccessLogItemSpecFromTCP `json:"tcp,omitempty"`
	Type MeshAccessLogItemType         `json:"type"`
}

func (m *MeshAccessLogItemSpecFromBackends) GetFile() *File {
	if m == nil {
		return nil
	}
	return m.File
}

func (m *MeshAccessLogItemSpecFromBackends) GetOpenTelemetry() *MeshAccessLogItemSpecFromOpenTelemetry {
	if m == nil {
		return nil
	}
	return m.OpenTelemetry
}

func (m *MeshAccessLogItemSpecFromBackends) GetTCP() *MeshAccessLogItemSpecFromTCP {
	if m == nil {
		return nil
	}
	return m.TCP
}

func (m *MeshAccessLogItemSpecFromBackends) GetType() MeshAccessLogItemType {
	if m == nil {
		return MeshAccessLogItemType("")
	}
	return m.Type
}

// MeshAccessLogItemSpecFromDefault - Default is a configuration specific to the group of clients referenced in
// 'targetRef'
type MeshAccessLogItemSpecFromDefault struct {
	Backends []MeshAccessLogItemSpecFromBackends `json:"backends,omitempty"`
}

func (m *MeshAccessLogItemSpecFromDefault) GetBackends() []MeshAccessLogItemSpecFromBackends {
	if m == nil {
		return nil
	}
	return m.Backends
}

// MeshAccessLogItemKind - Kind of the referenced resource
type MeshAccessLogItemKind string

const (
	MeshAccessLogItemKindMesh                 MeshAccessLogItemKind = "Mesh"
	MeshAccessLogItemKindMeshSubset           MeshAccessLogItemKind = "MeshSubset"
	MeshAccessLogItemKindMeshGateway          MeshAccessLogItemKind = "MeshGateway"
	MeshAccessLogItemKindMeshService          MeshAccessLogItemKind = "MeshService"
	MeshAccessLogItemKindMeshExternalService  MeshAccessLogItemKind = "MeshExternalService"
	MeshAccessLogItemKindMeshMultiZoneService MeshAccessLogItemKind = "MeshMultiZoneService"
	MeshAccessLogItemKindMeshServiceSubset    MeshAccessLogItemKind = "MeshServiceSubset"
	MeshAccessLogItemKindMeshHTTPRoute        MeshAccessLogItemKind = "MeshHTTPRoute"
	MeshAccessLogItemKindDataplane            MeshAccessLogItemKind = "Dataplane"
)

func (e MeshAccessLogItemKind) ToPointer() *MeshAccessLogItemKind {
	return &e
}
func (e *MeshAccessLogItemKind) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Mesh":
		fallthrough
	case "MeshSubset":
		fallthrough
	case "MeshGateway":
		fallthrough
	case "MeshService":
		fallthrough
	case "MeshExternalService":
		fallthrough
	case "MeshMultiZoneService":
		fallthrough
	case "MeshServiceSubset":
		fallthrough
	case "MeshHTTPRoute":
		fallthrough
	case "Dataplane":
		*e = MeshAccessLogItemKind(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshAccessLogItemKind: %v", v)
	}
}

type MeshAccessLogItemProxyTypes string

const (
	MeshAccessLogItemProxyTypesSidecar MeshAccessLogItemProxyTypes = "Sidecar"
	MeshAccessLogItemProxyTypesGateway MeshAccessLogItemProxyTypes = "Gateway"
)

func (e MeshAccessLogItemProxyTypes) ToPointer() *MeshAccessLogItemProxyTypes {
	return &e
}
func (e *MeshAccessLogItemProxyTypes) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Sidecar":
		fallthrough
	case "Gateway":
		*e = MeshAccessLogItemProxyTypes(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshAccessLogItemProxyTypes: %v", v)
	}
}

// MeshAccessLogItemTargetRef - TargetRef is a reference to the resource that represents a group of
// clients.
type MeshAccessLogItemTargetRef struct {
	// Kind of the referenced resource
	Kind MeshAccessLogItemKind `json:"kind"`
	// Labels are used to select group of MeshServices that match labels. Either Labels or
	// Name and Namespace can be used.
	Labels map[string]string `json:"labels,omitempty"`
	// Mesh is reserved for future use to identify cross mesh resources.
	Mesh *string `json:"mesh,omitempty"`
	// Name of the referenced resource. Can only be used with kinds: `MeshService`,
	// `MeshServiceSubset` and `MeshGatewayRoute`
	Name *string `json:"name,omitempty"`
	// Namespace specifies the namespace of target resource. If empty only resources in policy namespace
	// will be targeted.
	Namespace *string `json:"namespace,omitempty"`
	// ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
	// all data plane types are targeted by the policy.
	ProxyTypes []MeshAccessLogItemProxyTypes `json:"proxyTypes,omitempty"`
	// SectionName is used to target specific section of resource.
	// For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected.
	SectionName *string `json:"sectionName,omitempty"`
	// Tags used to select a subset of proxies by tags. Can only be used with kinds
	// `MeshSubset` and `MeshServiceSubset`
	Tags map[string]string `json:"tags,omitempty"`
}

func (m *MeshAccessLogItemTargetRef) GetKind() MeshAccessLogItemKind {
	if m == nil {
		return MeshAccessLogItemKind("")
	}
	return m.Kind
}

func (m *MeshAccessLogItemTargetRef) GetLabels() map[string]string {
	if m == nil {
		return nil
	}
	return m.Labels
}

func (m *MeshAccessLogItemTargetRef) GetMesh() *string {
	if m == nil {
		return nil
	}
	return m.Mesh
}

func (m *MeshAccessLogItemTargetRef) GetName() *string {
	if m == nil {
		return nil
	}
	return m.Name
}

func (m *MeshAccessLogItemTargetRef) GetNamespace() *string {
	if m == nil {
		return nil
	}
	return m.Namespace
}

func (m *MeshAccessLogItemTargetRef) GetProxyTypes() []MeshAccessLogItemProxyTypes {
	if m == nil {
		return nil
	}
	return m.ProxyTypes
}

func (m *MeshAccessLogItemTargetRef) GetSectionName() *string {
	if m == nil {
		return nil
	}
	return m.SectionName
}

func (m *MeshAccessLogItemTargetRef) GetTags() map[string]string {
	if m == nil {
		return nil
	}
	return m.Tags
}

type From struct {
	// Default is a configuration specific to the group of clients referenced in
	// 'targetRef'
	Default MeshAccessLogItemSpecFromDefault `json:"default"`
	// TargetRef is a reference to the resource that represents a group of
	// clients.
	TargetRef MeshAccessLogItemTargetRef `json:"targetRef"`
}

func (f *From) GetDefault() MeshAccessLogItemSpecFromDefault {
	if f == nil {
		return MeshAccessLogItemSpecFromDefault{}
	}
	return f.Default
}

func (f *From) GetTargetRef() MeshAccessLogItemTargetRef {
	if f == nil {
		return MeshAccessLogItemTargetRef{}
	}
	return f.TargetRef
}

type MeshAccessLogItemSpecJSON struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

func (m *MeshAccessLogItemSpecJSON) GetKey() string {
	if m == nil {
		return ""
	}
	return m.Key
}

func (m *MeshAccessLogItemSpecJSON) GetValue() string {
	if m == nil {
		return ""
	}
	return m.Value
}

type MeshAccessLogItemSpecRulesType string

const (
	MeshAccessLogItemSpecRulesTypePlain MeshAccessLogItemSpecRulesType = "Plain"
	MeshAccessLogItemSpecRulesTypeJSON  MeshAccessLogItemSpecRulesType = "Json"
)

func (e MeshAccessLogItemSpecRulesType) ToPointer() *MeshAccessLogItemSpecRulesType {
	return &e
}
func (e *MeshAccessLogItemSpecRulesType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Plain":
		fallthrough
	case "Json":
		*e = MeshAccessLogItemSpecRulesType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshAccessLogItemSpecRulesType: %v", v)
	}
}

// MeshAccessLogItemSpecFormat - Format of access logs. Placeholders available on
// https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators
type MeshAccessLogItemSpecFormat struct {
	JSON            []MeshAccessLogItemSpecJSON    `json:"json,omitempty"`
	OmitEmptyValues *bool                          `default:"false" json:"omitEmptyValues"`
	Plain           *string                        `json:"plain,omitempty"`
	Type            MeshAccessLogItemSpecRulesType `json:"type"`
}

func (m MeshAccessLogItemSpecFormat) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(m, "", false)
}

func (m *MeshAccessLogItemSpecFormat) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &m, "", false, []string{"type"}); err != nil {
		return err
	}
	return nil
}

func (m *MeshAccessLogItemSpecFormat) GetJSON() []MeshAccessLogItemSpecJSON {
	if m == nil {
		return nil
	}
	return m.JSON
}

func (m *MeshAccessLogItemSpecFormat) GetOmitEmptyValues() *bool {
	if m == nil {
		return nil
	}
	return m.OmitEmptyValues
}

func (m *MeshAccessLogItemSpecFormat) GetPlain() *string {
	if m == nil {
		return nil
	}
	return m.Plain
}

func (m *MeshAccessLogItemSpecFormat) GetType() MeshAccessLogItemSpecRulesType {
	if m == nil {
		return MeshAccessLogItemSpecRulesType("")
	}
	return m.Type
}

// MeshAccessLogItemFile - FileBackend defines configuration for file based access logs
type MeshAccessLogItemFile struct {
	// Format of access logs. Placeholders available on
	// https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators
	Format *MeshAccessLogItemSpecFormat `json:"format,omitempty"`
	// Path to a file that logs will be written to
	Path string `json:"path"`
}

func (m *MeshAccessLogItemFile) GetFormat() *MeshAccessLogItemSpecFormat {
	if m == nil {
		return nil
	}
	return m.Format
}

func (m *MeshAccessLogItemFile) GetPath() string {
	if m == nil {
		return ""
	}
	return m.Path
}

type MeshAccessLogItemAttributes struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

func (m *MeshAccessLogItemAttributes) GetKey() string {
	if m == nil {
		return ""
	}
	return m.Key
}

func (m *MeshAccessLogItemAttributes) GetValue() string {
	if m == nil {
		return ""
	}
	return m.Value
}

// MeshAccessLogItemOpenTelemetry - Defines an OpenTelemetry logging backend.
type MeshAccessLogItemOpenTelemetry struct {
	// Attributes can contain placeholders available on
	// https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators
	Attributes []MeshAccessLogItemAttributes `json:"attributes,omitempty"`
	// Body is a raw string or an OTLP any value as described at
	// https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/logs/data-model.md#field-body
	// It can contain placeholders available on
	// https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators
	Body any `json:"body,omitempty"`
	// Endpoint of OpenTelemetry collector. An empty port defaults to 4317.
	Endpoint string `json:"endpoint"`
}

func (m *MeshAccessLogItemOpenTelemetry) GetAttributes() []MeshAccessLogItemAttributes {
	if m == nil {
		return nil
	}
	return m.Attributes
}

func (m *MeshAccessLogItemOpenTelemetry) GetBody() any {
	if m == nil {
		return nil
	}
	return m.Body
}

func (m *MeshAccessLogItemOpenTelemetry) GetEndpoint() string {
	if m == nil {
		return ""
	}
	return m.Endpoint
}

type MeshAccessLogItemSpecRulesJSON struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

func (m *MeshAccessLogItemSpecRulesJSON) GetKey() string {
	if m == nil {
		return ""
	}
	return m.Key
}

func (m *MeshAccessLogItemSpecRulesJSON) GetValue() string {
	if m == nil {
		return ""
	}
	return m.Value
}

type MeshAccessLogItemSpecRulesDefaultType string

const (
	MeshAccessLogItemSpecRulesDefaultTypePlain MeshAccessLogItemSpecRulesDefaultType = "Plain"
	MeshAccessLogItemSpecRulesDefaultTypeJSON  MeshAccessLogItemSpecRulesDefaultType = "Json"
)

func (e MeshAccessLogItemSpecRulesDefaultType) ToPointer() *MeshAccessLogItemSpecRulesDefaultType {
	return &e
}
func (e *MeshAccessLogItemSpecRulesDefaultType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Plain":
		fallthrough
	case "Json":
		*e = MeshAccessLogItemSpecRulesDefaultType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshAccessLogItemSpecRulesDefaultType: %v", v)
	}
}

// MeshAccessLogItemSpecRulesFormat - Format of access logs. Placeholders available on
// https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators
type MeshAccessLogItemSpecRulesFormat struct {
	JSON            []MeshAccessLogItemSpecRulesJSON      `json:"json,omitempty"`
	OmitEmptyValues *bool                                 `default:"false" json:"omitEmptyValues"`
	Plain           *string                               `json:"plain,omitempty"`
	Type            MeshAccessLogItemSpecRulesDefaultType `json:"type"`
}

func (m MeshAccessLogItemSpecRulesFormat) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(m, "", false)
}

func (m *MeshAccessLogItemSpecRulesFormat) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &m, "", false, []string{"type"}); err != nil {
		return err
	}
	return nil
}

func (m *MeshAccessLogItemSpecRulesFormat) GetJSON() []MeshAccessLogItemSpecRulesJSON {
	if m == nil {
		return nil
	}
	return m.JSON
}

func (m *MeshAccessLogItemSpecRulesFormat) GetOmitEmptyValues() *bool {
	if m == nil {
		return nil
	}
	return m.OmitEmptyValues
}

func (m *MeshAccessLogItemSpecRulesFormat) GetPlain() *string {
	if m == nil {
		return nil
	}
	return m.Plain
}

func (m *MeshAccessLogItemSpecRulesFormat) GetType() MeshAccessLogItemSpecRulesDefaultType {
	if m == nil {
		return MeshAccessLogItemSpecRulesDefaultType("")
	}
	return m.Type
}

// MeshAccessLogItemTCP - TCPBackend defines a TCP logging backend.
type MeshAccessLogItemTCP struct {
	// Address of the TCP logging backend
	Address string `json:"address"`
	// Format of access logs. Placeholders available on
	// https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators
	Format *MeshAccessLogItemSpecRulesFormat `json:"format,omitempty"`
}

func (m *MeshAccessLogItemTCP) GetAddress() string {
	if m == nil {
		return ""
	}
	return m.Address
}

func (m *MeshAccessLogItemTCP) GetFormat() *MeshAccessLogItemSpecRulesFormat {
	if m == nil {
		return nil
	}
	return m.Format
}

type MeshAccessLogItemSpecType string

const (
	MeshAccessLogItemSpecTypeTCP           MeshAccessLogItemSpecType = "Tcp"
	MeshAccessLogItemSpecTypeFile          MeshAccessLogItemSpecType = "File"
	MeshAccessLogItemSpecTypeOpenTelemetry MeshAccessLogItemSpecType = "OpenTelemetry"
)

func (e MeshAccessLogItemSpecType) ToPointer() *MeshAccessLogItemSpecType {
	return &e
}
func (e *MeshAccessLogItemSpecType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Tcp":
		fallthrough
	case "File":
		fallthrough
	case "OpenTelemetry":
		*e = MeshAccessLogItemSpecType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshAccessLogItemSpecType: %v", v)
	}
}

type MeshAccessLogItemBackends struct {
	// FileBackend defines configuration for file based access logs
	File *MeshAccessLogItemFile `json:"file,omitempty"`
	// Defines an OpenTelemetry logging backend.
	OpenTelemetry *MeshAccessLogItemOpenTelemetry `json:"openTelemetry,omitempty"`
	// TCPBackend defines a TCP logging backend.
	TCP  *MeshAccessLogItemTCP     `json:"tcp,omitempty"`
	Type MeshAccessLogItemSpecType `json:"type"`
}

func (m *MeshAccessLogItemBackends) GetFile() *MeshAccessLogItemFile {
	if m == nil {
		return nil
	}
	return m.File
}

func (m *MeshAccessLogItemBackends) GetOpenTelemetry() *MeshAccessLogItemOpenTelemetry {
	if m == nil {
		return nil
	}
	return m.OpenTelemetry
}

func (m *MeshAccessLogItemBackends) GetTCP() *MeshAccessLogItemTCP {
	if m == nil {
		return nil
	}
	return m.TCP
}

func (m *MeshAccessLogItemBackends) GetType() MeshAccessLogItemSpecType {
	if m == nil {
		return MeshAccessLogItemSpecType("")
	}
	return m.Type
}

// MeshAccessLogItemDefault - Default contains configuration of the inbound access logging
type MeshAccessLogItemDefault struct {
	Backends []MeshAccessLogItemBackends `json:"backends,omitempty"`
}

func (m *MeshAccessLogItemDefault) GetBackends() []MeshAccessLogItemBackends {
	if m == nil {
		return nil
	}
	return m.Backends
}

type Rules struct {
	// Default contains configuration of the inbound access logging
	Default MeshAccessLogItemDefault `json:"default"`
}

func (r *Rules) GetDefault() MeshAccessLogItemDefault {
	if r == nil {
		return MeshAccessLogItemDefault{}
	}
	return r.Default
}

// Kind of the referenced resource
type Kind string

const (
	KindMesh                 Kind = "Mesh"
	KindMeshSubset           Kind = "MeshSubset"
	KindMeshGateway          Kind = "MeshGateway"
	KindMeshService          Kind = "MeshService"
	KindMeshExternalService  Kind = "MeshExternalService"
	KindMeshMultiZoneService Kind = "MeshMultiZoneService"
	KindMeshServiceSubset    Kind = "MeshServiceSubset"
	KindMeshHTTPRoute        Kind = "MeshHTTPRoute"
	KindDataplane            Kind = "Dataplane"
)

func (e Kind) ToPointer() *Kind {
	return &e
}
func (e *Kind) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Mesh":
		fallthrough
	case "MeshSubset":
		fallthrough
	case "MeshGateway":
		fallthrough
	case "MeshService":
		fallthrough
	case "MeshExternalService":
		fallthrough
	case "MeshMultiZoneService":
		fallthrough
	case "MeshServiceSubset":
		fallthrough
	case "MeshHTTPRoute":
		fallthrough
	case "Dataplane":
		*e = Kind(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Kind: %v", v)
	}
}

type ProxyTypes string

const (
	ProxyTypesSidecar ProxyTypes = "Sidecar"
	ProxyTypesGateway ProxyTypes = "Gateway"
)

func (e ProxyTypes) ToPointer() *ProxyTypes {
	return &e
}
func (e *ProxyTypes) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Sidecar":
		fallthrough
	case "Gateway":
		*e = ProxyTypes(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ProxyTypes: %v", v)
	}
}

// TargetRef is a reference to the resource the policy takes an effect on.
// The resource could be either a real store object or virtual resource
// defined in-place.
type TargetRef struct {
	// Kind of the referenced resource
	Kind Kind `json:"kind"`
	// Labels are used to select group of MeshServices that match labels. Either Labels or
	// Name and Namespace can be used.
	Labels map[string]string `json:"labels,omitempty"`
	// Mesh is reserved for future use to identify cross mesh resources.
	Mesh *string `json:"mesh,omitempty"`
	// Name of the referenced resource. Can only be used with kinds: `MeshService`,
	// `MeshServiceSubset` and `MeshGatewayRoute`
	Name *string `json:"name,omitempty"`
	// Namespace specifies the namespace of target resource. If empty only resources in policy namespace
	// will be targeted.
	Namespace *string `json:"namespace,omitempty"`
	// ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
	// all data plane types are targeted by the policy.
	ProxyTypes []ProxyTypes `json:"proxyTypes,omitempty"`
	// SectionName is used to target specific section of resource.
	// For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected.
	SectionName *string `json:"sectionName,omitempty"`
	// Tags used to select a subset of proxies by tags. Can only be used with kinds
	// `MeshSubset` and `MeshServiceSubset`
	Tags map[string]string `json:"tags,omitempty"`
}

func (t *TargetRef) GetKind() Kind {
	if t == nil {
		return Kind("")
	}
	return t.Kind
}

func (t *TargetRef) GetLabels() map[string]string {
	if t == nil {
		return nil
	}
	return t.Labels
}

func (t *TargetRef) GetMesh() *string {
	if t == nil {
		return nil
	}
	return t.Mesh
}

func (t *TargetRef) GetName() *string {
	if t == nil {
		return nil
	}
	return t.Name
}

func (t *TargetRef) GetNamespace() *string {
	if t == nil {
		return nil
	}
	return t.Namespace
}

func (t *TargetRef) GetProxyTypes() []ProxyTypes {
	if t == nil {
		return nil
	}
	return t.ProxyTypes
}

func (t *TargetRef) GetSectionName() *string {
	if t == nil {
		return nil
	}
	return t.SectionName
}

func (t *TargetRef) GetTags() map[string]string {
	if t == nil {
		return nil
	}
	return t.Tags
}

type MeshAccessLogItemSpecToJSON struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

func (m *MeshAccessLogItemSpecToJSON) GetKey() string {
	if m == nil {
		return ""
	}
	return m.Key
}

func (m *MeshAccessLogItemSpecToJSON) GetValue() string {
	if m == nil {
		return ""
	}
	return m.Value
}

type MeshAccessLogItemSpecToDefaultBackendsType string

const (
	MeshAccessLogItemSpecToDefaultBackendsTypePlain MeshAccessLogItemSpecToDefaultBackendsType = "Plain"
	MeshAccessLogItemSpecToDefaultBackendsTypeJSON  MeshAccessLogItemSpecToDefaultBackendsType = "Json"
)

func (e MeshAccessLogItemSpecToDefaultBackendsType) ToPointer() *MeshAccessLogItemSpecToDefaultBackendsType {
	return &e
}
func (e *MeshAccessLogItemSpecToDefaultBackendsType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Plain":
		fallthrough
	case "Json":
		*e = MeshAccessLogItemSpecToDefaultBackendsType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshAccessLogItemSpecToDefaultBackendsType: %v", v)
	}
}

// MeshAccessLogItemSpecToFormat - Format of access logs. Placeholders available on
// https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators
type MeshAccessLogItemSpecToFormat struct {
	JSON            []MeshAccessLogItemSpecToJSON              `json:"json,omitempty"`
	OmitEmptyValues *bool                                      `default:"false" json:"omitEmptyValues"`
	Plain           *string                                    `json:"plain,omitempty"`
	Type            MeshAccessLogItemSpecToDefaultBackendsType `json:"type"`
}

func (m MeshAccessLogItemSpecToFormat) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(m, "", false)
}

func (m *MeshAccessLogItemSpecToFormat) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &m, "", false, []string{"type"}); err != nil {
		return err
	}
	return nil
}

func (m *MeshAccessLogItemSpecToFormat) GetJSON() []MeshAccessLogItemSpecToJSON {
	if m == nil {
		return nil
	}
	return m.JSON
}

func (m *MeshAccessLogItemSpecToFormat) GetOmitEmptyValues() *bool {
	if m == nil {
		return nil
	}
	return m.OmitEmptyValues
}

func (m *MeshAccessLogItemSpecToFormat) GetPlain() *string {
	if m == nil {
		return nil
	}
	return m.Plain
}

func (m *MeshAccessLogItemSpecToFormat) GetType() MeshAccessLogItemSpecToDefaultBackendsType {
	if m == nil {
		return MeshAccessLogItemSpecToDefaultBackendsType("")
	}
	return m.Type
}

// MeshAccessLogItemSpecFile - FileBackend defines configuration for file based access logs
type MeshAccessLogItemSpecFile struct {
	// Format of access logs. Placeholders available on
	// https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators
	Format *MeshAccessLogItemSpecToFormat `json:"format,omitempty"`
	// Path to a file that logs will be written to
	Path string `json:"path"`
}

func (m *MeshAccessLogItemSpecFile) GetFormat() *MeshAccessLogItemSpecToFormat {
	if m == nil {
		return nil
	}
	return m.Format
}

func (m *MeshAccessLogItemSpecFile) GetPath() string {
	if m == nil {
		return ""
	}
	return m.Path
}

type MeshAccessLogItemSpecAttributes struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

func (m *MeshAccessLogItemSpecAttributes) GetKey() string {
	if m == nil {
		return ""
	}
	return m.Key
}

func (m *MeshAccessLogItemSpecAttributes) GetValue() string {
	if m == nil {
		return ""
	}
	return m.Value
}

// MeshAccessLogItemSpecOpenTelemetry - Defines an OpenTelemetry logging backend.
type MeshAccessLogItemSpecOpenTelemetry struct {
	// Attributes can contain placeholders available on
	// https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators
	Attributes []MeshAccessLogItemSpecAttributes `json:"attributes,omitempty"`
	// Body is a raw string or an OTLP any value as described at
	// https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/logs/data-model.md#field-body
	// It can contain placeholders available on
	// https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators
	Body any `json:"body,omitempty"`
	// Endpoint of OpenTelemetry collector. An empty port defaults to 4317.
	Endpoint string `json:"endpoint"`
}

func (m *MeshAccessLogItemSpecOpenTelemetry) GetAttributes() []MeshAccessLogItemSpecAttributes {
	if m == nil {
		return nil
	}
	return m.Attributes
}

func (m *MeshAccessLogItemSpecOpenTelemetry) GetBody() any {
	if m == nil {
		return nil
	}
	return m.Body
}

func (m *MeshAccessLogItemSpecOpenTelemetry) GetEndpoint() string {
	if m == nil {
		return ""
	}
	return m.Endpoint
}

type MeshAccessLogItemSpecToDefaultJSON struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

func (m *MeshAccessLogItemSpecToDefaultJSON) GetKey() string {
	if m == nil {
		return ""
	}
	return m.Key
}

func (m *MeshAccessLogItemSpecToDefaultJSON) GetValue() string {
	if m == nil {
		return ""
	}
	return m.Value
}

type MeshAccessLogItemSpecToDefaultType string

const (
	MeshAccessLogItemSpecToDefaultTypePlain MeshAccessLogItemSpecToDefaultType = "Plain"
	MeshAccessLogItemSpecToDefaultTypeJSON  MeshAccessLogItemSpecToDefaultType = "Json"
)

func (e MeshAccessLogItemSpecToDefaultType) ToPointer() *MeshAccessLogItemSpecToDefaultType {
	return &e
}
func (e *MeshAccessLogItemSpecToDefaultType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Plain":
		fallthrough
	case "Json":
		*e = MeshAccessLogItemSpecToDefaultType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshAccessLogItemSpecToDefaultType: %v", v)
	}
}

// MeshAccessLogItemSpecToDefaultFormat - Format of access logs. Placeholders available on
// https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators
type MeshAccessLogItemSpecToDefaultFormat struct {
	JSON            []MeshAccessLogItemSpecToDefaultJSON `json:"json,omitempty"`
	OmitEmptyValues *bool                                `default:"false" json:"omitEmptyValues"`
	Plain           *string                              `json:"plain,omitempty"`
	Type            MeshAccessLogItemSpecToDefaultType   `json:"type"`
}

func (m MeshAccessLogItemSpecToDefaultFormat) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(m, "", false)
}

func (m *MeshAccessLogItemSpecToDefaultFormat) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &m, "", false, []string{"type"}); err != nil {
		return err
	}
	return nil
}

func (m *MeshAccessLogItemSpecToDefaultFormat) GetJSON() []MeshAccessLogItemSpecToDefaultJSON {
	if m == nil {
		return nil
	}
	return m.JSON
}

func (m *MeshAccessLogItemSpecToDefaultFormat) GetOmitEmptyValues() *bool {
	if m == nil {
		return nil
	}
	return m.OmitEmptyValues
}

func (m *MeshAccessLogItemSpecToDefaultFormat) GetPlain() *string {
	if m == nil {
		return nil
	}
	return m.Plain
}

func (m *MeshAccessLogItemSpecToDefaultFormat) GetType() MeshAccessLogItemSpecToDefaultType {
	if m == nil {
		return MeshAccessLogItemSpecToDefaultType("")
	}
	return m.Type
}

// MeshAccessLogItemSpecTCP - TCPBackend defines a TCP logging backend.
type MeshAccessLogItemSpecTCP struct {
	// Address of the TCP logging backend
	Address string `json:"address"`
	// Format of access logs. Placeholders available on
	// https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators
	Format *MeshAccessLogItemSpecToDefaultFormat `json:"format,omitempty"`
}

func (m *MeshAccessLogItemSpecTCP) GetAddress() string {
	if m == nil {
		return ""
	}
	return m.Address
}

func (m *MeshAccessLogItemSpecTCP) GetFormat() *MeshAccessLogItemSpecToDefaultFormat {
	if m == nil {
		return nil
	}
	return m.Format
}

type MeshAccessLogItemSpecToType string

const (
	MeshAccessLogItemSpecToTypeTCP           MeshAccessLogItemSpecToType = "Tcp"
	MeshAccessLogItemSpecToTypeFile          MeshAccessLogItemSpecToType = "File"
	MeshAccessLogItemSpecToTypeOpenTelemetry MeshAccessLogItemSpecToType = "OpenTelemetry"
)

func (e MeshAccessLogItemSpecToType) ToPointer() *MeshAccessLogItemSpecToType {
	return &e
}
func (e *MeshAccessLogItemSpecToType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Tcp":
		fallthrough
	case "File":
		fallthrough
	case "OpenTelemetry":
		*e = MeshAccessLogItemSpecToType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshAccessLogItemSpecToType: %v", v)
	}
}

type MeshAccessLogItemSpecBackends struct {
	// FileBackend defines configuration for file based access logs
	File *MeshAccessLogItemSpecFile `json:"file,omitempty"`
	// Defines an OpenTelemetry logging backend.
	OpenTelemetry *MeshAccessLogItemSpecOpenTelemetry `json:"openTelemetry,omitempty"`
	// TCPBackend defines a TCP logging backend.
	TCP  *MeshAccessLogItemSpecTCP   `json:"tcp,omitempty"`
	Type MeshAccessLogItemSpecToType `json:"type"`
}

func (m *MeshAccessLogItemSpecBackends) GetFile() *MeshAccessLogItemSpecFile {
	if m == nil {
		return nil
	}
	return m.File
}

func (m *MeshAccessLogItemSpecBackends) GetOpenTelemetry() *MeshAccessLogItemSpecOpenTelemetry {
	if m == nil {
		return nil
	}
	return m.OpenTelemetry
}

func (m *MeshAccessLogItemSpecBackends) GetTCP() *MeshAccessLogItemSpecTCP {
	if m == nil {
		return nil
	}
	return m.TCP
}

func (m *MeshAccessLogItemSpecBackends) GetType() MeshAccessLogItemSpecToType {
	if m == nil {
		return MeshAccessLogItemSpecToType("")
	}
	return m.Type
}

// MeshAccessLogItemSpecDefault - Default is a configuration specific to the group of destinations referenced in
// 'targetRef'
type MeshAccessLogItemSpecDefault struct {
	Backends []MeshAccessLogItemSpecBackends `json:"backends,omitempty"`
}

func (m *MeshAccessLogItemSpecDefault) GetBackends() []MeshAccessLogItemSpecBackends {
	if m == nil {
		return nil
	}
	return m.Backends
}

// MeshAccessLogItemSpecKind - Kind of the referenced resource
type MeshAccessLogItemSpecKind string

const (
	MeshAccessLogItemSpecKindMesh                 MeshAccessLogItemSpecKind = "Mesh"
	MeshAccessLogItemSpecKindMeshSubset           MeshAccessLogItemSpecKind = "MeshSubset"
	MeshAccessLogItemSpecKindMeshGateway          MeshAccessLogItemSpecKind = "MeshGateway"
	MeshAccessLogItemSpecKindMeshService          MeshAccessLogItemSpecKind = "MeshService"
	MeshAccessLogItemSpecKindMeshExternalService  MeshAccessLogItemSpecKind = "MeshExternalService"
	MeshAccessLogItemSpecKindMeshMultiZoneService MeshAccessLogItemSpecKind = "MeshMultiZoneService"
	MeshAccessLogItemSpecKindMeshServiceSubset    MeshAccessLogItemSpecKind = "MeshServiceSubset"
	MeshAccessLogItemSpecKindMeshHTTPRoute        MeshAccessLogItemSpecKind = "MeshHTTPRoute"
	MeshAccessLogItemSpecKindDataplane            MeshAccessLogItemSpecKind = "Dataplane"
)

func (e MeshAccessLogItemSpecKind) ToPointer() *MeshAccessLogItemSpecKind {
	return &e
}
func (e *MeshAccessLogItemSpecKind) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Mesh":
		fallthrough
	case "MeshSubset":
		fallthrough
	case "MeshGateway":
		fallthrough
	case "MeshService":
		fallthrough
	case "MeshExternalService":
		fallthrough
	case "MeshMultiZoneService":
		fallthrough
	case "MeshServiceSubset":
		fallthrough
	case "MeshHTTPRoute":
		fallthrough
	case "Dataplane":
		*e = MeshAccessLogItemSpecKind(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshAccessLogItemSpecKind: %v", v)
	}
}

type MeshAccessLogItemSpecProxyTypes string

const (
	MeshAccessLogItemSpecProxyTypesSidecar MeshAccessLogItemSpecProxyTypes = "Sidecar"
	MeshAccessLogItemSpecProxyTypesGateway MeshAccessLogItemSpecProxyTypes = "Gateway"
)

func (e MeshAccessLogItemSpecProxyTypes) ToPointer() *MeshAccessLogItemSpecProxyTypes {
	return &e
}
func (e *MeshAccessLogItemSpecProxyTypes) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Sidecar":
		fallthrough
	case "Gateway":
		*e = MeshAccessLogItemSpecProxyTypes(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshAccessLogItemSpecProxyTypes: %v", v)
	}
}

// MeshAccessLogItemSpecTargetRef - TargetRef is a reference to the resource that represents a group of
// destinations.
type MeshAccessLogItemSpecTargetRef struct {
	// Kind of the referenced resource
	Kind MeshAccessLogItemSpecKind `json:"kind"`
	// Labels are used to select group of MeshServices that match labels. Either Labels or
	// Name and Namespace can be used.
	Labels map[string]string `json:"labels,omitempty"`
	// Mesh is reserved for future use to identify cross mesh resources.
	Mesh *string `json:"mesh,omitempty"`
	// Name of the referenced resource. Can only be used with kinds: `MeshService`,
	// `MeshServiceSubset` and `MeshGatewayRoute`
	Name *string `json:"name,omitempty"`
	// Namespace specifies the namespace of target resource. If empty only resources in policy namespace
	// will be targeted.
	Namespace *string `json:"namespace,omitempty"`
	// ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
	// all data plane types are targeted by the policy.
	ProxyTypes []MeshAccessLogItemSpecProxyTypes `json:"proxyTypes,omitempty"`
	// SectionName is used to target specific section of resource.
	// For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected.
	SectionName *string `json:"sectionName,omitempty"`
	// Tags used to select a subset of proxies by tags. Can only be used with kinds
	// `MeshSubset` and `MeshServiceSubset`
	Tags map[string]string `json:"tags,omitempty"`
}

func (m *MeshAccessLogItemSpecTargetRef) GetKind() MeshAccessLogItemSpecKind {
	if m == nil {
		return MeshAccessLogItemSpecKind("")
	}
	return m.Kind
}

func (m *MeshAccessLogItemSpecTargetRef) GetLabels() map[string]string {
	if m == nil {
		return nil
	}
	return m.Labels
}

func (m *MeshAccessLogItemSpecTargetRef) GetMesh() *string {
	if m == nil {
		return nil
	}
	return m.Mesh
}

func (m *MeshAccessLogItemSpecTargetRef) GetName() *string {
	if m == nil {
		return nil
	}
	return m.Name
}

func (m *MeshAccessLogItemSpecTargetRef) GetNamespace() *string {
	if m == nil {
		return nil
	}
	return m.Namespace
}

func (m *MeshAccessLogItemSpecTargetRef) GetProxyTypes() []MeshAccessLogItemSpecProxyTypes {
	if m == nil {
		return nil
	}
	return m.ProxyTypes
}

func (m *MeshAccessLogItemSpecTargetRef) GetSectionName() *string {
	if m == nil {
		return nil
	}
	return m.SectionName
}

func (m *MeshAccessLogItemSpecTargetRef) GetTags() map[string]string {
	if m == nil {
		return nil
	}
	return m.Tags
}

type To struct {
	// Default is a configuration specific to the group of destinations referenced in
	// 'targetRef'
	Default MeshAccessLogItemSpecDefault `json:"default"`
	// TargetRef is a reference to the resource that represents a group of
	// destinations.
	TargetRef MeshAccessLogItemSpecTargetRef `json:"targetRef"`
}

func (t *To) GetDefault() MeshAccessLogItemSpecDefault {
	if t == nil {
		return MeshAccessLogItemSpecDefault{}
	}
	return t.Default
}

func (t *To) GetTargetRef() MeshAccessLogItemSpecTargetRef {
	if t == nil {
		return MeshAccessLogItemSpecTargetRef{}
	}
	return t.TargetRef
}

// Spec is the specification of the Kuma MeshAccessLog resource.
type Spec struct {
	// From list makes a match between clients and corresponding configurations
	From []From `json:"from,omitempty"`
	// Rules defines inbound access log configurations. Currently limited to
	// selecting all inbound traffic, as L7 matching is not yet implemented.
	Rules []Rules `json:"rules,omitempty"`
	// TargetRef is a reference to the resource the policy takes an effect on.
	// The resource could be either a real store object or virtual resource
	// defined in-place.
	TargetRef *TargetRef `json:"targetRef,omitempty"`
	// To list makes a match between the consumed services and corresponding configurations
	To []To `json:"to,omitempty"`
}

func (s *Spec) GetFrom() []From {
	if s == nil {
		return nil
	}
	return s.From
}

func (s *Spec) GetRules() []Rules {
	if s == nil {
		return nil
	}
	return s.Rules
}

func (s *Spec) GetTargetRef() *TargetRef {
	if s == nil {
		return nil
	}
	return s.TargetRef
}

func (s *Spec) GetTo() []To {
	if s == nil {
		return nil
	}
	return s.To
}

// MeshAccessLogItem - Successful response
type MeshAccessLogItem struct {
	// the type of the resource
	Type Type `json:"type"`
	// Mesh is the name of the Kuma mesh this resource belongs to. It may be omitted for cluster-scoped resources.
	Mesh *string `default:"default" json:"mesh"`
	// Name of the Kuma resource
	Name string `json:"name"`
	// The labels to help identity resources
	Labels map[string]string `json:"labels,omitempty"`
	// Spec is the specification of the Kuma MeshAccessLog resource.
	Spec Spec `json:"spec"`
	// Time at which the resource was created
	CreationTime *time.Time `json:"creationTime,omitempty"`
	// Time at which the resource was updated
	ModificationTime *time.Time `json:"modificationTime,omitempty"`
}

func (m MeshAccessLogItem) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(m, "", false)
}

func (m *MeshAccessLogItem) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &m, "", false, []string{"type", "name", "spec"}); err != nil {
		return err
	}
	return nil
}

func (m *MeshAccessLogItem) GetType() Type {
	if m == nil {
		return Type("")
	}
	return m.Type
}

func (m *MeshAccessLogItem) GetMesh() *string {
	if m == nil {
		return nil
	}
	return m.Mesh
}

func (m *MeshAccessLogItem) GetName() string {
	if m == nil {
		return ""
	}
	return m.Name
}

func (m *MeshAccessLogItem) GetLabels() map[string]string {
	if m == nil {
		return nil
	}
	return m.Labels
}

func (m *MeshAccessLogItem) GetSpec() Spec {
	if m == nil {
		return Spec{}
	}
	return m.Spec
}

func (m *MeshAccessLogItem) GetCreationTime() *time.Time {
	if m == nil {
		return nil
	}
	return m.CreationTime
}

func (m *MeshAccessLogItem) GetModificationTime() *time.Time {
	if m == nil {
		return nil
	}
	return m.ModificationTime
}

type MeshAccessLogItemInput struct {
	// the type of the resource
	Type Type `json:"type"`
	// Mesh is the name of the Kuma mesh this resource belongs to. It may be omitted for cluster-scoped resources.
	Mesh *string `default:"default" json:"mesh"`
	// Name of the Kuma resource
	Name string `json:"name"`
	// The labels to help identity resources
	Labels map[string]string `json:"labels,omitempty"`
	// Spec is the specification of the Kuma MeshAccessLog resource.
	Spec Spec `json:"spec"`
}

func (m MeshAccessLogItemInput) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(m, "", false)
}

func (m *MeshAccessLogItemInput) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &m, "", false, []string{"type", "name", "spec"}); err != nil {
		return err
	}
	return nil
}

func (m *MeshAccessLogItemInput) GetType() Type {
	if m == nil {
		return Type("")
	}
	return m.Type
}

func (m *MeshAccessLogItemInput) GetMesh() *string {
	if m == nil {
		return nil
	}
	return m.Mesh
}

func (m *MeshAccessLogItemInput) GetName() string {
	if m == nil {
		return ""
	}
	return m.Name
}

func (m *MeshAccessLogItemInput) GetLabels() map[string]string {
	if m == nil {
		return nil
	}
	return m.Labels
}

func (m *MeshAccessLogItemInput) GetSpec() Spec {
	if m == nil {
		return Spec{}
	}
	return m.Spec
}
