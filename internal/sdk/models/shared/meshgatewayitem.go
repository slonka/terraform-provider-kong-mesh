// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"errors"
	"fmt"
	"github.com/kong/terraform-provider-kong-mesh/internal/sdk/internal/utils"
)

type ProtocolType string

const (
	ProtocolTypeStr     ProtocolType = "str"
	ProtocolTypeInteger ProtocolType = "integer"
)

// Protocol specifies the network protocol this listener expects to receive.
type Protocol struct {
	Str     *string `queryParam:"inline,name=protocol"`
	Integer *int64  `queryParam:"inline,name=protocol"`

	Type ProtocolType
}

func CreateProtocolStr(str string) Protocol {
	typ := ProtocolTypeStr

	return Protocol{
		Str:  &str,
		Type: typ,
	}
}

func CreateProtocolInteger(integer int64) Protocol {
	typ := ProtocolTypeInteger

	return Protocol{
		Integer: &integer,
		Type:    typ,
	}
}

func (u *Protocol) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  ProtocolTypeStr,
			Value: &str,
		})
	}

	var integer int64 = int64(0)
	if err := utils.UnmarshalJSON(data, &integer, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  ProtocolTypeInteger,
			Value: &integer,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for Protocol", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestCandidate(candidates)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for Protocol", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(ProtocolType)
	switch best.Type {
	case ProtocolTypeStr:
		u.Str = best.Value.(*string)
		return nil
	case ProtocolTypeInteger:
		u.Integer = best.Value.(*int64)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Protocol", string(data))
}

func (u Protocol) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Integer != nil {
		return utils.MarshalJSON(u.Integer, "", true)
	}

	return nil, errors.New("could not marshal union type Protocol: all fields are null")
}

// Resources is used to specify listener-specific resource settings.
type Resources struct {
	ConnectionLimit *int64 `json:"connectionLimit,omitempty"`
}

func (r *Resources) GetConnectionLimit() *int64 {
	if r == nil {
		return nil
	}
	return r.ConnectionLimit
}

type DataSourceSecret struct {
	// Data source is a secret with given Secret key.
	Secret *string `json:"secret,omitempty"`
}

func (d DataSourceSecret) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DataSourceSecret) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DataSourceSecret) GetSecret() *string {
	if d == nil {
		return nil
	}
	return d.Secret
}

type DataSourceInlineString struct {
	// Data source is inline string
	InlineString *string `json:"inlineString,omitempty"`
}

func (d DataSourceInlineString) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DataSourceInlineString) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DataSourceInlineString) GetInlineString() *string {
	if d == nil {
		return nil
	}
	return d.InlineString
}

type DataSourceInline struct {
	// Data source is inline bytes.
	Inline *string `json:"inline,omitempty"`
}

func (d DataSourceInline) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DataSourceInline) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DataSourceInline) GetInline() *string {
	if d == nil {
		return nil
	}
	return d.Inline
}

type DataSourceFile struct {
	// Data source is a path to a file.
	// Deprecated, use other sources of a data.
	File *string `json:"file,omitempty"`
}

func (d DataSourceFile) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DataSourceFile) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DataSourceFile) GetFile() *string {
	if d == nil {
		return nil
	}
	return d.File
}

type CertificatesType string

const (
	CertificatesTypeDataSourceFile         CertificatesType = "DataSource_File"
	CertificatesTypeDataSourceInline       CertificatesType = "DataSource_Inline"
	CertificatesTypeDataSourceInlineString CertificatesType = "DataSource_InlineString"
	CertificatesTypeDataSourceSecret       CertificatesType = "DataSource_Secret"
)

type Certificates struct {
	DataSourceFile         *DataSourceFile         `queryParam:"inline,name=certificates"`
	DataSourceInline       *DataSourceInline       `queryParam:"inline,name=certificates"`
	DataSourceInlineString *DataSourceInlineString `queryParam:"inline,name=certificates"`
	DataSourceSecret       *DataSourceSecret       `queryParam:"inline,name=certificates"`

	Type CertificatesType
}

func CreateCertificatesDataSourceFile(dataSourceFile DataSourceFile) Certificates {
	typ := CertificatesTypeDataSourceFile

	return Certificates{
		DataSourceFile: &dataSourceFile,
		Type:           typ,
	}
}

func CreateCertificatesDataSourceInline(dataSourceInline DataSourceInline) Certificates {
	typ := CertificatesTypeDataSourceInline

	return Certificates{
		DataSourceInline: &dataSourceInline,
		Type:             typ,
	}
}

func CreateCertificatesDataSourceInlineString(dataSourceInlineString DataSourceInlineString) Certificates {
	typ := CertificatesTypeDataSourceInlineString

	return Certificates{
		DataSourceInlineString: &dataSourceInlineString,
		Type:                   typ,
	}
}

func CreateCertificatesDataSourceSecret(dataSourceSecret DataSourceSecret) Certificates {
	typ := CertificatesTypeDataSourceSecret

	return Certificates{
		DataSourceSecret: &dataSourceSecret,
		Type:             typ,
	}
}

func (u *Certificates) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var dataSourceFile DataSourceFile = DataSourceFile{}
	if err := utils.UnmarshalJSON(data, &dataSourceFile, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  CertificatesTypeDataSourceFile,
			Value: &dataSourceFile,
		})
	}

	var dataSourceInline DataSourceInline = DataSourceInline{}
	if err := utils.UnmarshalJSON(data, &dataSourceInline, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  CertificatesTypeDataSourceInline,
			Value: &dataSourceInline,
		})
	}

	var dataSourceInlineString DataSourceInlineString = DataSourceInlineString{}
	if err := utils.UnmarshalJSON(data, &dataSourceInlineString, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  CertificatesTypeDataSourceInlineString,
			Value: &dataSourceInlineString,
		})
	}

	var dataSourceSecret DataSourceSecret = DataSourceSecret{}
	if err := utils.UnmarshalJSON(data, &dataSourceSecret, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  CertificatesTypeDataSourceSecret,
			Value: &dataSourceSecret,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for Certificates", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestCandidate(candidates)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for Certificates", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(CertificatesType)
	switch best.Type {
	case CertificatesTypeDataSourceFile:
		u.DataSourceFile = best.Value.(*DataSourceFile)
		return nil
	case CertificatesTypeDataSourceInline:
		u.DataSourceInline = best.Value.(*DataSourceInline)
		return nil
	case CertificatesTypeDataSourceInlineString:
		u.DataSourceInlineString = best.Value.(*DataSourceInlineString)
		return nil
	case CertificatesTypeDataSourceSecret:
		u.DataSourceSecret = best.Value.(*DataSourceSecret)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Certificates", string(data))
}

func (u Certificates) MarshalJSON() ([]byte, error) {
	if u.DataSourceFile != nil {
		return utils.MarshalJSON(u.DataSourceFile, "", true)
	}

	if u.DataSourceInline != nil {
		return utils.MarshalJSON(u.DataSourceInline, "", true)
	}

	if u.DataSourceInlineString != nil {
		return utils.MarshalJSON(u.DataSourceInlineString, "", true)
	}

	if u.DataSourceSecret != nil {
		return utils.MarshalJSON(u.DataSourceSecret, "", true)
	}

	return nil, errors.New("could not marshal union type Certificates: all fields are null")
}

type MeshGatewayItemModeType string

const (
	MeshGatewayItemModeTypeStr     MeshGatewayItemModeType = "str"
	MeshGatewayItemModeTypeInteger MeshGatewayItemModeType = "integer"
)

// MeshGatewayItemMode - Mode defines the TLS behavior for the TLS session initiated
// by the client.
type MeshGatewayItemMode struct {
	Str     *string `queryParam:"inline,name=mode"`
	Integer *int64  `queryParam:"inline,name=mode"`

	Type MeshGatewayItemModeType
}

func CreateMeshGatewayItemModeStr(str string) MeshGatewayItemMode {
	typ := MeshGatewayItemModeTypeStr

	return MeshGatewayItemMode{
		Str:  &str,
		Type: typ,
	}
}

func CreateMeshGatewayItemModeInteger(integer int64) MeshGatewayItemMode {
	typ := MeshGatewayItemModeTypeInteger

	return MeshGatewayItemMode{
		Integer: &integer,
		Type:    typ,
	}
}

func (u *MeshGatewayItemMode) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  MeshGatewayItemModeTypeStr,
			Value: &str,
		})
	}

	var integer int64 = int64(0)
	if err := utils.UnmarshalJSON(data, &integer, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  MeshGatewayItemModeTypeInteger,
			Value: &integer,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for MeshGatewayItemMode", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestCandidate(candidates)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for MeshGatewayItemMode", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(MeshGatewayItemModeType)
	switch best.Type {
	case MeshGatewayItemModeTypeStr:
		u.Str = best.Value.(*string)
		return nil
	case MeshGatewayItemModeTypeInteger:
		u.Integer = best.Value.(*int64)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for MeshGatewayItemMode", string(data))
}

func (u MeshGatewayItemMode) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Integer != nil {
		return utils.MarshalJSON(u.Integer, "", true)
	}

	return nil, errors.New("could not marshal union type MeshGatewayItemMode: all fields are null")
}

// OptionsObj - Options should eventually configure how TLS is configured. This
// is where cipher suite and version configuration can be specified,
// client certificates enforced, and so on.
type OptionsObj struct {
}

// MeshGatewayItemTLS - TLS is the TLS configuration for the Listener. This field
// is required if the Protocol field is "HTTPS" or "TLS" and
// ignored otherwise.
type MeshGatewayItemTLS struct {
	// Certificates is an array of datasources that contain TLS
	// certificates and private keys.  Each datasource must contain a
	// sequence of PEM-encoded objects. The server certificate and private
	// key are required, but additional certificates are allowed and will
	// be added to the certificate chain.  The server certificate must
	// be the first certificate in the datasource.
	//
	// When multiple certificate datasources are configured, they must have
	// different key types. In practice, this means that one datasource
	// should contain an RSA key and certificate, and the other an
	// ECDSA key and certificate.
	Certificates []Certificates `json:"certificates,omitempty"`
	// Mode defines the TLS behavior for the TLS session initiated
	// by the client.
	Mode *MeshGatewayItemMode `json:"mode,omitempty"`
	// Options should eventually configure how TLS is configured. This
	// is where cipher suite and version configuration can be specified,
	// client certificates enforced, and so on.
	Options *OptionsObj `json:"options,omitempty"`
}

func (m *MeshGatewayItemTLS) GetCertificates() []Certificates {
	if m == nil {
		return nil
	}
	return m.Certificates
}

func (m *MeshGatewayItemTLS) GetMode() *MeshGatewayItemMode {
	if m == nil {
		return nil
	}
	return m.Mode
}

func (m *MeshGatewayItemTLS) GetOptions() *OptionsObj {
	if m == nil {
		return nil
	}
	return m.Options
}

type Listeners struct {
	// CrossMesh enables traffic to flow to this listener only from other
	// meshes.
	CrossMesh *bool `json:"crossMesh,omitempty"`
	// Hostname specifies the virtual hostname to match for protocol types that
	// define this concept. When unspecified, "", or `*`, all hostnames are
	// matched. This field can be omitted for protocols that don't require
	// hostname based matching.
	Hostname *string `json:"hostname,omitempty"`
	// Port is the network port. Multiple listeners may use the
	// same port, subject to the Listener compatibility rules.
	Port *int64 `json:"port,omitempty"`
	// Protocol specifies the network protocol this listener expects to receive.
	Protocol *Protocol `json:"protocol,omitempty"`
	// Resources is used to specify listener-specific resource settings.
	Resources *Resources `json:"resources,omitempty"`
	// Tags specifies a unique combination of tags that routes can use
	// to match themselves to this listener.
	//
	// When matching routes to listeners, the control plane constructs a
	// set of matching tags for each listener by forming the union of the
	// gateway tags and the listener tags. A route will be attached to the
	// listener if all of the route's tags are preset in the matching tags
	Tags map[string]string `json:"tags,omitempty"`
	// TLS is the TLS configuration for the Listener. This field
	// is required if the Protocol field is "HTTPS" or "TLS" and
	// ignored otherwise.
	TLS *MeshGatewayItemTLS `json:"tls,omitempty"`
}

func (l *Listeners) GetCrossMesh() *bool {
	if l == nil {
		return nil
	}
	return l.CrossMesh
}

func (l *Listeners) GetHostname() *string {
	if l == nil {
		return nil
	}
	return l.Hostname
}

func (l *Listeners) GetPort() *int64 {
	if l == nil {
		return nil
	}
	return l.Port
}

func (l *Listeners) GetProtocol() *Protocol {
	if l == nil {
		return nil
	}
	return l.Protocol
}

func (l *Listeners) GetResources() *Resources {
	if l == nil {
		return nil
	}
	return l.Resources
}

func (l *Listeners) GetTags() map[string]string {
	if l == nil {
		return nil
	}
	return l.Tags
}

func (l *Listeners) GetTLS() *MeshGatewayItemTLS {
	if l == nil {
		return nil
	}
	return l.TLS
}

// Conf - The desired configuration of the MeshGateway.
type Conf struct {
	// Listeners define logical endpoints that are bound on this MeshGateway's
	// address(es).
	Listeners []Listeners `json:"listeners,omitempty"`
}

func (c *Conf) GetListeners() []Listeners {
	if c == nil {
		return nil
	}
	return c.Listeners
}

// Selectors - Selector defines structure for selecting tags for given dataplane
type Selectors struct {
	// Tags to match, can be used for both source and destinations
	Match map[string]string `json:"match,omitempty"`
}

func (s *Selectors) GetMatch() map[string]string {
	if s == nil {
		return nil
	}
	return s.Match
}

// MeshGatewayItem - Successful response
type MeshGatewayItem struct {
	// The desired configuration of the MeshGateway.
	Conf   *Conf             `json:"conf,omitempty"`
	Labels map[string]string `json:"labels,omitempty"`
	Mesh   string            `json:"mesh"`
	Name   string            `json:"name"`
	// Selectors is a list of selectors that are used to match builtin
	// gateway dataplanes that will receive this MeshGateway configuration.
	Selectors []Selectors `json:"selectors,omitempty"`
	// Tags is the set of tags common to all of the gateway's listeners.
	//
	// This field must not include a `kuma.io/service` tag (the service is always
	// defined on the dataplanes).
	Tags map[string]string `json:"tags,omitempty"`
	Type string            `json:"type"`
}

func (m *MeshGatewayItem) GetConf() *Conf {
	if m == nil {
		return nil
	}
	return m.Conf
}

func (m *MeshGatewayItem) GetLabels() map[string]string {
	if m == nil {
		return nil
	}
	return m.Labels
}

func (m *MeshGatewayItem) GetMesh() string {
	if m == nil {
		return ""
	}
	return m.Mesh
}

func (m *MeshGatewayItem) GetName() string {
	if m == nil {
		return ""
	}
	return m.Name
}

func (m *MeshGatewayItem) GetSelectors() []Selectors {
	if m == nil {
		return nil
	}
	return m.Selectors
}

func (m *MeshGatewayItem) GetTags() map[string]string {
	if m == nil {
		return nil
	}
	return m.Tags
}

func (m *MeshGatewayItem) GetType() string {
	if m == nil {
		return ""
	}
	return m.Type
}
