// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/kong/terraform-provider-kong-mesh/internal/sdk/internal/utils"
	"time"
)

// MeshFaultInjectionItemType - the type of the resource
type MeshFaultInjectionItemType string

const (
	MeshFaultInjectionItemTypeMeshFaultInjection MeshFaultInjectionItemType = "MeshFaultInjection"
)

func (e MeshFaultInjectionItemType) ToPointer() *MeshFaultInjectionItemType {
	return &e
}
func (e *MeshFaultInjectionItemType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "MeshFaultInjection":
		*e = MeshFaultInjectionItemType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshFaultInjectionItemType: %v", v)
	}
}

type PercentageType string

const (
	PercentageTypeInteger PercentageType = "integer"
	PercentageTypeStr     PercentageType = "str"
)

// Percentage of requests on which abort will be injected, has to be
// either int or decimal represented as string.
type Percentage struct {
	Integer *int64  `queryParam:"inline,name=percentage"`
	Str     *string `queryParam:"inline,name=percentage"`

	Type PercentageType
}

func CreatePercentageInteger(integer int64) Percentage {
	typ := PercentageTypeInteger

	return Percentage{
		Integer: &integer,
		Type:    typ,
	}
}

func CreatePercentageStr(str string) Percentage {
	typ := PercentageTypeStr

	return Percentage{
		Str:  &str,
		Type: typ,
	}
}

func (u *Percentage) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var integer int64 = int64(0)
	if err := utils.UnmarshalJSON(data, &integer, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  PercentageTypeInteger,
			Value: &integer,
		})
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  PercentageTypeStr,
			Value: &str,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for Percentage", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestCandidate(candidates)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for Percentage", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(PercentageType)
	switch best.Type {
	case PercentageTypeInteger:
		u.Integer = best.Value.(*int64)
		return nil
	case PercentageTypeStr:
		u.Str = best.Value.(*string)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Percentage", string(data))
}

func (u Percentage) MarshalJSON() ([]byte, error) {
	if u.Integer != nil {
		return utils.MarshalJSON(u.Integer, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	return nil, errors.New("could not marshal union type Percentage: all fields are null")
}

// Abort defines a configuration of not delivering requests to destination
// service and replacing the responses from destination dataplane by
// predefined status code
type Abort struct {
	// HTTP status code which will be returned to source side
	HTTPStatus int `json:"httpStatus"`
	// Percentage of requests on which abort will be injected, has to be
	// either int or decimal represented as string.
	Percentage Percentage `json:"percentage"`
}

func (a *Abort) GetHTTPStatus() int {
	if a == nil {
		return 0
	}
	return a.HTTPStatus
}

func (a *Abort) GetPercentage() Percentage {
	if a == nil {
		return Percentage{}
	}
	return a.Percentage
}

type MeshFaultInjectionItemPercentageType string

const (
	MeshFaultInjectionItemPercentageTypeInteger MeshFaultInjectionItemPercentageType = "integer"
	MeshFaultInjectionItemPercentageTypeStr     MeshFaultInjectionItemPercentageType = "str"
)

// MeshFaultInjectionItemPercentage - Percentage of requests on which delay will be injected, has to be
// either int or decimal represented as string.
type MeshFaultInjectionItemPercentage struct {
	Integer *int64  `queryParam:"inline,name=percentage"`
	Str     *string `queryParam:"inline,name=percentage"`

	Type MeshFaultInjectionItemPercentageType
}

func CreateMeshFaultInjectionItemPercentageInteger(integer int64) MeshFaultInjectionItemPercentage {
	typ := MeshFaultInjectionItemPercentageTypeInteger

	return MeshFaultInjectionItemPercentage{
		Integer: &integer,
		Type:    typ,
	}
}

func CreateMeshFaultInjectionItemPercentageStr(str string) MeshFaultInjectionItemPercentage {
	typ := MeshFaultInjectionItemPercentageTypeStr

	return MeshFaultInjectionItemPercentage{
		Str:  &str,
		Type: typ,
	}
}

func (u *MeshFaultInjectionItemPercentage) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var integer int64 = int64(0)
	if err := utils.UnmarshalJSON(data, &integer, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  MeshFaultInjectionItemPercentageTypeInteger,
			Value: &integer,
		})
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  MeshFaultInjectionItemPercentageTypeStr,
			Value: &str,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for MeshFaultInjectionItemPercentage", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestCandidate(candidates)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for MeshFaultInjectionItemPercentage", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(MeshFaultInjectionItemPercentageType)
	switch best.Type {
	case MeshFaultInjectionItemPercentageTypeInteger:
		u.Integer = best.Value.(*int64)
		return nil
	case MeshFaultInjectionItemPercentageTypeStr:
		u.Str = best.Value.(*string)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for MeshFaultInjectionItemPercentage", string(data))
}

func (u MeshFaultInjectionItemPercentage) MarshalJSON() ([]byte, error) {
	if u.Integer != nil {
		return utils.MarshalJSON(u.Integer, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	return nil, errors.New("could not marshal union type MeshFaultInjectionItemPercentage: all fields are null")
}

// Delay defines configuration of delaying a response from a destination
type Delay struct {
	// Percentage of requests on which delay will be injected, has to be
	// either int or decimal represented as string.
	Percentage MeshFaultInjectionItemPercentage `json:"percentage"`
	// The duration during which the response will be delayed
	Value string `json:"value"`
}

func (d *Delay) GetPercentage() MeshFaultInjectionItemPercentage {
	if d == nil {
		return MeshFaultInjectionItemPercentage{}
	}
	return d.Percentage
}

func (d *Delay) GetValue() string {
	if d == nil {
		return ""
	}
	return d.Value
}

type MeshFaultInjectionItemSpecPercentageType string

const (
	MeshFaultInjectionItemSpecPercentageTypeInteger MeshFaultInjectionItemSpecPercentageType = "integer"
	MeshFaultInjectionItemSpecPercentageTypeStr     MeshFaultInjectionItemSpecPercentageType = "str"
)

// MeshFaultInjectionItemSpecPercentage - Percentage of requests on which response bandwidth limit will be
// either int or decimal represented as string.
type MeshFaultInjectionItemSpecPercentage struct {
	Integer *int64  `queryParam:"inline,name=percentage"`
	Str     *string `queryParam:"inline,name=percentage"`

	Type MeshFaultInjectionItemSpecPercentageType
}

func CreateMeshFaultInjectionItemSpecPercentageInteger(integer int64) MeshFaultInjectionItemSpecPercentage {
	typ := MeshFaultInjectionItemSpecPercentageTypeInteger

	return MeshFaultInjectionItemSpecPercentage{
		Integer: &integer,
		Type:    typ,
	}
}

func CreateMeshFaultInjectionItemSpecPercentageStr(str string) MeshFaultInjectionItemSpecPercentage {
	typ := MeshFaultInjectionItemSpecPercentageTypeStr

	return MeshFaultInjectionItemSpecPercentage{
		Str:  &str,
		Type: typ,
	}
}

func (u *MeshFaultInjectionItemSpecPercentage) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var integer int64 = int64(0)
	if err := utils.UnmarshalJSON(data, &integer, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  MeshFaultInjectionItemSpecPercentageTypeInteger,
			Value: &integer,
		})
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  MeshFaultInjectionItemSpecPercentageTypeStr,
			Value: &str,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for MeshFaultInjectionItemSpecPercentage", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestCandidate(candidates)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for MeshFaultInjectionItemSpecPercentage", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(MeshFaultInjectionItemSpecPercentageType)
	switch best.Type {
	case MeshFaultInjectionItemSpecPercentageTypeInteger:
		u.Integer = best.Value.(*int64)
		return nil
	case MeshFaultInjectionItemSpecPercentageTypeStr:
		u.Str = best.Value.(*string)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for MeshFaultInjectionItemSpecPercentage", string(data))
}

func (u MeshFaultInjectionItemSpecPercentage) MarshalJSON() ([]byte, error) {
	if u.Integer != nil {
		return utils.MarshalJSON(u.Integer, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	return nil, errors.New("could not marshal union type MeshFaultInjectionItemSpecPercentage: all fields are null")
}

// ResponseBandwidth defines a configuration to limit the speed of
// responding to the requests
type ResponseBandwidth struct {
	// Limit is represented by value measure in Gbps, Mbps, kbps, e.g.
	// 10kbps
	Limit string `json:"limit"`
	// Percentage of requests on which response bandwidth limit will be
	// either int or decimal represented as string.
	Percentage MeshFaultInjectionItemSpecPercentage `json:"percentage"`
}

func (r *ResponseBandwidth) GetLimit() string {
	if r == nil {
		return ""
	}
	return r.Limit
}

func (r *ResponseBandwidth) GetPercentage() MeshFaultInjectionItemSpecPercentage {
	if r == nil {
		return MeshFaultInjectionItemSpecPercentage{}
	}
	return r.Percentage
}

// HTTP - FaultInjection defines the configuration of faults between dataplanes.
type HTTP struct {
	// Abort defines a configuration of not delivering requests to destination
	// service and replacing the responses from destination dataplane by
	// predefined status code
	Abort *Abort `json:"abort,omitempty"`
	// Delay defines configuration of delaying a response from a destination
	Delay *Delay `json:"delay,omitempty"`
	// ResponseBandwidth defines a configuration to limit the speed of
	// responding to the requests
	ResponseBandwidth *ResponseBandwidth `json:"responseBandwidth,omitempty"`
}

func (h *HTTP) GetAbort() *Abort {
	if h == nil {
		return nil
	}
	return h.Abort
}

func (h *HTTP) GetDelay() *Delay {
	if h == nil {
		return nil
	}
	return h.Delay
}

func (h *HTTP) GetResponseBandwidth() *ResponseBandwidth {
	if h == nil {
		return nil
	}
	return h.ResponseBandwidth
}

// MeshFaultInjectionItemDefault - Default is a configuration specific to the group of destinations referenced in
// 'targetRef'
type MeshFaultInjectionItemDefault struct {
	// Http allows to define list of Http faults between dataplanes.
	HTTP []HTTP `json:"http,omitempty"`
}

func (m *MeshFaultInjectionItemDefault) GetHTTP() []HTTP {
	if m == nil {
		return nil
	}
	return m.HTTP
}

// MeshFaultInjectionItemSpecKind - Kind of the referenced resource
type MeshFaultInjectionItemSpecKind string

const (
	MeshFaultInjectionItemSpecKindMesh                 MeshFaultInjectionItemSpecKind = "Mesh"
	MeshFaultInjectionItemSpecKindMeshSubset           MeshFaultInjectionItemSpecKind = "MeshSubset"
	MeshFaultInjectionItemSpecKindMeshGateway          MeshFaultInjectionItemSpecKind = "MeshGateway"
	MeshFaultInjectionItemSpecKindMeshService          MeshFaultInjectionItemSpecKind = "MeshService"
	MeshFaultInjectionItemSpecKindMeshExternalService  MeshFaultInjectionItemSpecKind = "MeshExternalService"
	MeshFaultInjectionItemSpecKindMeshMultiZoneService MeshFaultInjectionItemSpecKind = "MeshMultiZoneService"
	MeshFaultInjectionItemSpecKindMeshServiceSubset    MeshFaultInjectionItemSpecKind = "MeshServiceSubset"
	MeshFaultInjectionItemSpecKindMeshHTTPRoute        MeshFaultInjectionItemSpecKind = "MeshHTTPRoute"
	MeshFaultInjectionItemSpecKindDataplane            MeshFaultInjectionItemSpecKind = "Dataplane"
)

func (e MeshFaultInjectionItemSpecKind) ToPointer() *MeshFaultInjectionItemSpecKind {
	return &e
}
func (e *MeshFaultInjectionItemSpecKind) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Mesh":
		fallthrough
	case "MeshSubset":
		fallthrough
	case "MeshGateway":
		fallthrough
	case "MeshService":
		fallthrough
	case "MeshExternalService":
		fallthrough
	case "MeshMultiZoneService":
		fallthrough
	case "MeshServiceSubset":
		fallthrough
	case "MeshHTTPRoute":
		fallthrough
	case "Dataplane":
		*e = MeshFaultInjectionItemSpecKind(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshFaultInjectionItemSpecKind: %v", v)
	}
}

type MeshFaultInjectionItemSpecProxyTypes string

const (
	MeshFaultInjectionItemSpecProxyTypesSidecar MeshFaultInjectionItemSpecProxyTypes = "Sidecar"
	MeshFaultInjectionItemSpecProxyTypesGateway MeshFaultInjectionItemSpecProxyTypes = "Gateway"
)

func (e MeshFaultInjectionItemSpecProxyTypes) ToPointer() *MeshFaultInjectionItemSpecProxyTypes {
	return &e
}
func (e *MeshFaultInjectionItemSpecProxyTypes) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Sidecar":
		fallthrough
	case "Gateway":
		*e = MeshFaultInjectionItemSpecProxyTypes(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshFaultInjectionItemSpecProxyTypes: %v", v)
	}
}

// MeshFaultInjectionItemSpecTargetRef - TargetRef is a reference to the resource that represents a group of
// destinations.
type MeshFaultInjectionItemSpecTargetRef struct {
	// Kind of the referenced resource
	Kind MeshFaultInjectionItemSpecKind `json:"kind"`
	// Labels are used to select group of MeshServices that match labels. Either Labels or
	// Name and Namespace can be used.
	Labels map[string]string `json:"labels,omitempty"`
	// Mesh is reserved for future use to identify cross mesh resources.
	Mesh *string `json:"mesh,omitempty"`
	// Name of the referenced resource. Can only be used with kinds: `MeshService`,
	// `MeshServiceSubset` and `MeshGatewayRoute`
	Name *string `json:"name,omitempty"`
	// Namespace specifies the namespace of target resource. If empty only resources in policy namespace
	// will be targeted.
	Namespace *string `json:"namespace,omitempty"`
	// ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
	// all data plane types are targeted by the policy.
	ProxyTypes []MeshFaultInjectionItemSpecProxyTypes `json:"proxyTypes,omitempty"`
	// SectionName is used to target specific section of resource.
	// For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected.
	SectionName *string `json:"sectionName,omitempty"`
	// Tags used to select a subset of proxies by tags. Can only be used with kinds
	// `MeshSubset` and `MeshServiceSubset`
	Tags map[string]string `json:"tags,omitempty"`
}

func (m *MeshFaultInjectionItemSpecTargetRef) GetKind() MeshFaultInjectionItemSpecKind {
	if m == nil {
		return MeshFaultInjectionItemSpecKind("")
	}
	return m.Kind
}

func (m *MeshFaultInjectionItemSpecTargetRef) GetLabels() map[string]string {
	if m == nil {
		return nil
	}
	return m.Labels
}

func (m *MeshFaultInjectionItemSpecTargetRef) GetMesh() *string {
	if m == nil {
		return nil
	}
	return m.Mesh
}

func (m *MeshFaultInjectionItemSpecTargetRef) GetName() *string {
	if m == nil {
		return nil
	}
	return m.Name
}

func (m *MeshFaultInjectionItemSpecTargetRef) GetNamespace() *string {
	if m == nil {
		return nil
	}
	return m.Namespace
}

func (m *MeshFaultInjectionItemSpecTargetRef) GetProxyTypes() []MeshFaultInjectionItemSpecProxyTypes {
	if m == nil {
		return nil
	}
	return m.ProxyTypes
}

func (m *MeshFaultInjectionItemSpecTargetRef) GetSectionName() *string {
	if m == nil {
		return nil
	}
	return m.SectionName
}

func (m *MeshFaultInjectionItemSpecTargetRef) GetTags() map[string]string {
	if m == nil {
		return nil
	}
	return m.Tags
}

type MeshFaultInjectionItemFrom struct {
	// Default is a configuration specific to the group of destinations referenced in
	// 'targetRef'
	Default *MeshFaultInjectionItemDefault `json:"default,omitempty"`
	// TargetRef is a reference to the resource that represents a group of
	// destinations.
	TargetRef MeshFaultInjectionItemSpecTargetRef `json:"targetRef"`
}

func (m *MeshFaultInjectionItemFrom) GetDefault() *MeshFaultInjectionItemDefault {
	if m == nil {
		return nil
	}
	return m.Default
}

func (m *MeshFaultInjectionItemFrom) GetTargetRef() MeshFaultInjectionItemSpecTargetRef {
	if m == nil {
		return MeshFaultInjectionItemSpecTargetRef{}
	}
	return m.TargetRef
}

type MeshFaultInjectionItemSpecRulesPercentageType string

const (
	MeshFaultInjectionItemSpecRulesPercentageTypeInteger MeshFaultInjectionItemSpecRulesPercentageType = "integer"
	MeshFaultInjectionItemSpecRulesPercentageTypeStr     MeshFaultInjectionItemSpecRulesPercentageType = "str"
)

// MeshFaultInjectionItemSpecRulesPercentage - Percentage of requests on which abort will be injected, has to be
// either int or decimal represented as string.
type MeshFaultInjectionItemSpecRulesPercentage struct {
	Integer *int64  `queryParam:"inline,name=percentage"`
	Str     *string `queryParam:"inline,name=percentage"`

	Type MeshFaultInjectionItemSpecRulesPercentageType
}

func CreateMeshFaultInjectionItemSpecRulesPercentageInteger(integer int64) MeshFaultInjectionItemSpecRulesPercentage {
	typ := MeshFaultInjectionItemSpecRulesPercentageTypeInteger

	return MeshFaultInjectionItemSpecRulesPercentage{
		Integer: &integer,
		Type:    typ,
	}
}

func CreateMeshFaultInjectionItemSpecRulesPercentageStr(str string) MeshFaultInjectionItemSpecRulesPercentage {
	typ := MeshFaultInjectionItemSpecRulesPercentageTypeStr

	return MeshFaultInjectionItemSpecRulesPercentage{
		Str:  &str,
		Type: typ,
	}
}

func (u *MeshFaultInjectionItemSpecRulesPercentage) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var integer int64 = int64(0)
	if err := utils.UnmarshalJSON(data, &integer, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  MeshFaultInjectionItemSpecRulesPercentageTypeInteger,
			Value: &integer,
		})
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  MeshFaultInjectionItemSpecRulesPercentageTypeStr,
			Value: &str,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for MeshFaultInjectionItemSpecRulesPercentage", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestCandidate(candidates)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for MeshFaultInjectionItemSpecRulesPercentage", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(MeshFaultInjectionItemSpecRulesPercentageType)
	switch best.Type {
	case MeshFaultInjectionItemSpecRulesPercentageTypeInteger:
		u.Integer = best.Value.(*int64)
		return nil
	case MeshFaultInjectionItemSpecRulesPercentageTypeStr:
		u.Str = best.Value.(*string)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for MeshFaultInjectionItemSpecRulesPercentage", string(data))
}

func (u MeshFaultInjectionItemSpecRulesPercentage) MarshalJSON() ([]byte, error) {
	if u.Integer != nil {
		return utils.MarshalJSON(u.Integer, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	return nil, errors.New("could not marshal union type MeshFaultInjectionItemSpecRulesPercentage: all fields are null")
}

// MeshFaultInjectionItemAbort - Abort defines a configuration of not delivering requests to destination
// service and replacing the responses from destination dataplane by
// predefined status code
type MeshFaultInjectionItemAbort struct {
	// HTTP status code which will be returned to source side
	HTTPStatus int `json:"httpStatus"`
	// Percentage of requests on which abort will be injected, has to be
	// either int or decimal represented as string.
	Percentage MeshFaultInjectionItemSpecRulesPercentage `json:"percentage"`
}

func (m *MeshFaultInjectionItemAbort) GetHTTPStatus() int {
	if m == nil {
		return 0
	}
	return m.HTTPStatus
}

func (m *MeshFaultInjectionItemAbort) GetPercentage() MeshFaultInjectionItemSpecRulesPercentage {
	if m == nil {
		return MeshFaultInjectionItemSpecRulesPercentage{}
	}
	return m.Percentage
}

type MeshFaultInjectionItemSpecRulesDefaultPercentageType string

const (
	MeshFaultInjectionItemSpecRulesDefaultPercentageTypeInteger MeshFaultInjectionItemSpecRulesDefaultPercentageType = "integer"
	MeshFaultInjectionItemSpecRulesDefaultPercentageTypeStr     MeshFaultInjectionItemSpecRulesDefaultPercentageType = "str"
)

// MeshFaultInjectionItemSpecRulesDefaultPercentage - Percentage of requests on which delay will be injected, has to be
// either int or decimal represented as string.
type MeshFaultInjectionItemSpecRulesDefaultPercentage struct {
	Integer *int64  `queryParam:"inline,name=percentage"`
	Str     *string `queryParam:"inline,name=percentage"`

	Type MeshFaultInjectionItemSpecRulesDefaultPercentageType
}

func CreateMeshFaultInjectionItemSpecRulesDefaultPercentageInteger(integer int64) MeshFaultInjectionItemSpecRulesDefaultPercentage {
	typ := MeshFaultInjectionItemSpecRulesDefaultPercentageTypeInteger

	return MeshFaultInjectionItemSpecRulesDefaultPercentage{
		Integer: &integer,
		Type:    typ,
	}
}

func CreateMeshFaultInjectionItemSpecRulesDefaultPercentageStr(str string) MeshFaultInjectionItemSpecRulesDefaultPercentage {
	typ := MeshFaultInjectionItemSpecRulesDefaultPercentageTypeStr

	return MeshFaultInjectionItemSpecRulesDefaultPercentage{
		Str:  &str,
		Type: typ,
	}
}

func (u *MeshFaultInjectionItemSpecRulesDefaultPercentage) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var integer int64 = int64(0)
	if err := utils.UnmarshalJSON(data, &integer, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  MeshFaultInjectionItemSpecRulesDefaultPercentageTypeInteger,
			Value: &integer,
		})
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  MeshFaultInjectionItemSpecRulesDefaultPercentageTypeStr,
			Value: &str,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for MeshFaultInjectionItemSpecRulesDefaultPercentage", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestCandidate(candidates)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for MeshFaultInjectionItemSpecRulesDefaultPercentage", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(MeshFaultInjectionItemSpecRulesDefaultPercentageType)
	switch best.Type {
	case MeshFaultInjectionItemSpecRulesDefaultPercentageTypeInteger:
		u.Integer = best.Value.(*int64)
		return nil
	case MeshFaultInjectionItemSpecRulesDefaultPercentageTypeStr:
		u.Str = best.Value.(*string)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for MeshFaultInjectionItemSpecRulesDefaultPercentage", string(data))
}

func (u MeshFaultInjectionItemSpecRulesDefaultPercentage) MarshalJSON() ([]byte, error) {
	if u.Integer != nil {
		return utils.MarshalJSON(u.Integer, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	return nil, errors.New("could not marshal union type MeshFaultInjectionItemSpecRulesDefaultPercentage: all fields are null")
}

// MeshFaultInjectionItemDelay - Delay defines configuration of delaying a response from a destination
type MeshFaultInjectionItemDelay struct {
	// Percentage of requests on which delay will be injected, has to be
	// either int or decimal represented as string.
	Percentage MeshFaultInjectionItemSpecRulesDefaultPercentage `json:"percentage"`
	// The duration during which the response will be delayed
	Value string `json:"value"`
}

func (m *MeshFaultInjectionItemDelay) GetPercentage() MeshFaultInjectionItemSpecRulesDefaultPercentage {
	if m == nil {
		return MeshFaultInjectionItemSpecRulesDefaultPercentage{}
	}
	return m.Percentage
}

func (m *MeshFaultInjectionItemDelay) GetValue() string {
	if m == nil {
		return ""
	}
	return m.Value
}

type MeshFaultInjectionItemSpecRulesDefaultHTTPPercentageType string

const (
	MeshFaultInjectionItemSpecRulesDefaultHTTPPercentageTypeInteger MeshFaultInjectionItemSpecRulesDefaultHTTPPercentageType = "integer"
	MeshFaultInjectionItemSpecRulesDefaultHTTPPercentageTypeStr     MeshFaultInjectionItemSpecRulesDefaultHTTPPercentageType = "str"
)

// MeshFaultInjectionItemSpecRulesDefaultHTTPPercentage - Percentage of requests on which response bandwidth limit will be
// either int or decimal represented as string.
type MeshFaultInjectionItemSpecRulesDefaultHTTPPercentage struct {
	Integer *int64  `queryParam:"inline,name=percentage"`
	Str     *string `queryParam:"inline,name=percentage"`

	Type MeshFaultInjectionItemSpecRulesDefaultHTTPPercentageType
}

func CreateMeshFaultInjectionItemSpecRulesDefaultHTTPPercentageInteger(integer int64) MeshFaultInjectionItemSpecRulesDefaultHTTPPercentage {
	typ := MeshFaultInjectionItemSpecRulesDefaultHTTPPercentageTypeInteger

	return MeshFaultInjectionItemSpecRulesDefaultHTTPPercentage{
		Integer: &integer,
		Type:    typ,
	}
}

func CreateMeshFaultInjectionItemSpecRulesDefaultHTTPPercentageStr(str string) MeshFaultInjectionItemSpecRulesDefaultHTTPPercentage {
	typ := MeshFaultInjectionItemSpecRulesDefaultHTTPPercentageTypeStr

	return MeshFaultInjectionItemSpecRulesDefaultHTTPPercentage{
		Str:  &str,
		Type: typ,
	}
}

func (u *MeshFaultInjectionItemSpecRulesDefaultHTTPPercentage) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var integer int64 = int64(0)
	if err := utils.UnmarshalJSON(data, &integer, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  MeshFaultInjectionItemSpecRulesDefaultHTTPPercentageTypeInteger,
			Value: &integer,
		})
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  MeshFaultInjectionItemSpecRulesDefaultHTTPPercentageTypeStr,
			Value: &str,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for MeshFaultInjectionItemSpecRulesDefaultHTTPPercentage", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestCandidate(candidates)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for MeshFaultInjectionItemSpecRulesDefaultHTTPPercentage", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(MeshFaultInjectionItemSpecRulesDefaultHTTPPercentageType)
	switch best.Type {
	case MeshFaultInjectionItemSpecRulesDefaultHTTPPercentageTypeInteger:
		u.Integer = best.Value.(*int64)
		return nil
	case MeshFaultInjectionItemSpecRulesDefaultHTTPPercentageTypeStr:
		u.Str = best.Value.(*string)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for MeshFaultInjectionItemSpecRulesDefaultHTTPPercentage", string(data))
}

func (u MeshFaultInjectionItemSpecRulesDefaultHTTPPercentage) MarshalJSON() ([]byte, error) {
	if u.Integer != nil {
		return utils.MarshalJSON(u.Integer, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	return nil, errors.New("could not marshal union type MeshFaultInjectionItemSpecRulesDefaultHTTPPercentage: all fields are null")
}

// MeshFaultInjectionItemResponseBandwidth - ResponseBandwidth defines a configuration to limit the speed of
// responding to the requests
type MeshFaultInjectionItemResponseBandwidth struct {
	// Limit is represented by value measure in Gbps, Mbps, kbps, e.g.
	// 10kbps
	Limit string `json:"limit"`
	// Percentage of requests on which response bandwidth limit will be
	// either int or decimal represented as string.
	Percentage MeshFaultInjectionItemSpecRulesDefaultHTTPPercentage `json:"percentage"`
}

func (m *MeshFaultInjectionItemResponseBandwidth) GetLimit() string {
	if m == nil {
		return ""
	}
	return m.Limit
}

func (m *MeshFaultInjectionItemResponseBandwidth) GetPercentage() MeshFaultInjectionItemSpecRulesDefaultHTTPPercentage {
	if m == nil {
		return MeshFaultInjectionItemSpecRulesDefaultHTTPPercentage{}
	}
	return m.Percentage
}

// MeshFaultInjectionItemHTTP - FaultInjection defines the configuration of faults between dataplanes.
type MeshFaultInjectionItemHTTP struct {
	// Abort defines a configuration of not delivering requests to destination
	// service and replacing the responses from destination dataplane by
	// predefined status code
	Abort *MeshFaultInjectionItemAbort `json:"abort,omitempty"`
	// Delay defines configuration of delaying a response from a destination
	Delay *MeshFaultInjectionItemDelay `json:"delay,omitempty"`
	// ResponseBandwidth defines a configuration to limit the speed of
	// responding to the requests
	ResponseBandwidth *MeshFaultInjectionItemResponseBandwidth `json:"responseBandwidth,omitempty"`
}

func (m *MeshFaultInjectionItemHTTP) GetAbort() *MeshFaultInjectionItemAbort {
	if m == nil {
		return nil
	}
	return m.Abort
}

func (m *MeshFaultInjectionItemHTTP) GetDelay() *MeshFaultInjectionItemDelay {
	if m == nil {
		return nil
	}
	return m.Delay
}

func (m *MeshFaultInjectionItemHTTP) GetResponseBandwidth() *MeshFaultInjectionItemResponseBandwidth {
	if m == nil {
		return nil
	}
	return m.ResponseBandwidth
}

// MeshFaultInjectionItemSpecDefault - Default defines fault configuration
type MeshFaultInjectionItemSpecDefault struct {
	// Http allows to define list of Http faults between dataplanes.
	HTTP []MeshFaultInjectionItemHTTP `json:"http,omitempty"`
}

func (m *MeshFaultInjectionItemSpecDefault) GetHTTP() []MeshFaultInjectionItemHTTP {
	if m == nil {
		return nil
	}
	return m.HTTP
}

// MeshFaultInjectionItemSpecType - Type defines how to match incoming traffic by SpiffeID. `Exact` or `Prefix` are allowed.
type MeshFaultInjectionItemSpecType string

const (
	MeshFaultInjectionItemSpecTypeExact  MeshFaultInjectionItemSpecType = "Exact"
	MeshFaultInjectionItemSpecTypePrefix MeshFaultInjectionItemSpecType = "Prefix"
)

func (e MeshFaultInjectionItemSpecType) ToPointer() *MeshFaultInjectionItemSpecType {
	return &e
}
func (e *MeshFaultInjectionItemSpecType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Exact":
		fallthrough
	case "Prefix":
		*e = MeshFaultInjectionItemSpecType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshFaultInjectionItemSpecType: %v", v)
	}
}

// MeshFaultInjectionItemSpiffeID - SpiffeID defines a matcher configuration for SpiffeID matching
type MeshFaultInjectionItemSpiffeID struct {
	// Type defines how to match incoming traffic by SpiffeID. `Exact` or `Prefix` are allowed.
	Type MeshFaultInjectionItemSpecType `json:"type"`
	// Value is SpiffeId of a client that needs to match for the configuration to be applied
	Value string `json:"value"`
}

func (m *MeshFaultInjectionItemSpiffeID) GetType() MeshFaultInjectionItemSpecType {
	if m == nil {
		return MeshFaultInjectionItemSpecType("")
	}
	return m.Type
}

func (m *MeshFaultInjectionItemSpiffeID) GetValue() string {
	if m == nil {
		return ""
	}
	return m.Value
}

type Matches struct {
	// SpiffeID defines a matcher configuration for SpiffeID matching
	SpiffeID *MeshFaultInjectionItemSpiffeID `json:"spiffeID,omitempty"`
}

func (m *Matches) GetSpiffeID() *MeshFaultInjectionItemSpiffeID {
	if m == nil {
		return nil
	}
	return m.SpiffeID
}

type MeshFaultInjectionItemRules struct {
	// Default defines fault configuration
	Default MeshFaultInjectionItemSpecDefault `json:"default"`
	// Matches defines list of matches for which fault injection will be applied
	Matches []Matches `json:"matches,omitempty"`
}

func (m *MeshFaultInjectionItemRules) GetDefault() MeshFaultInjectionItemSpecDefault {
	if m == nil {
		return MeshFaultInjectionItemSpecDefault{}
	}
	return m.Default
}

func (m *MeshFaultInjectionItemRules) GetMatches() []Matches {
	if m == nil {
		return nil
	}
	return m.Matches
}

// MeshFaultInjectionItemKind - Kind of the referenced resource
type MeshFaultInjectionItemKind string

const (
	MeshFaultInjectionItemKindMesh                 MeshFaultInjectionItemKind = "Mesh"
	MeshFaultInjectionItemKindMeshSubset           MeshFaultInjectionItemKind = "MeshSubset"
	MeshFaultInjectionItemKindMeshGateway          MeshFaultInjectionItemKind = "MeshGateway"
	MeshFaultInjectionItemKindMeshService          MeshFaultInjectionItemKind = "MeshService"
	MeshFaultInjectionItemKindMeshExternalService  MeshFaultInjectionItemKind = "MeshExternalService"
	MeshFaultInjectionItemKindMeshMultiZoneService MeshFaultInjectionItemKind = "MeshMultiZoneService"
	MeshFaultInjectionItemKindMeshServiceSubset    MeshFaultInjectionItemKind = "MeshServiceSubset"
	MeshFaultInjectionItemKindMeshHTTPRoute        MeshFaultInjectionItemKind = "MeshHTTPRoute"
	MeshFaultInjectionItemKindDataplane            MeshFaultInjectionItemKind = "Dataplane"
)

func (e MeshFaultInjectionItemKind) ToPointer() *MeshFaultInjectionItemKind {
	return &e
}
func (e *MeshFaultInjectionItemKind) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Mesh":
		fallthrough
	case "MeshSubset":
		fallthrough
	case "MeshGateway":
		fallthrough
	case "MeshService":
		fallthrough
	case "MeshExternalService":
		fallthrough
	case "MeshMultiZoneService":
		fallthrough
	case "MeshServiceSubset":
		fallthrough
	case "MeshHTTPRoute":
		fallthrough
	case "Dataplane":
		*e = MeshFaultInjectionItemKind(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshFaultInjectionItemKind: %v", v)
	}
}

type MeshFaultInjectionItemProxyTypes string

const (
	MeshFaultInjectionItemProxyTypesSidecar MeshFaultInjectionItemProxyTypes = "Sidecar"
	MeshFaultInjectionItemProxyTypesGateway MeshFaultInjectionItemProxyTypes = "Gateway"
)

func (e MeshFaultInjectionItemProxyTypes) ToPointer() *MeshFaultInjectionItemProxyTypes {
	return &e
}
func (e *MeshFaultInjectionItemProxyTypes) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Sidecar":
		fallthrough
	case "Gateway":
		*e = MeshFaultInjectionItemProxyTypes(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshFaultInjectionItemProxyTypes: %v", v)
	}
}

// MeshFaultInjectionItemTargetRef - TargetRef is a reference to the resource the policy takes an effect on.
// The resource could be either a real store object or virtual resource
// defined inplace.
type MeshFaultInjectionItemTargetRef struct {
	// Kind of the referenced resource
	Kind MeshFaultInjectionItemKind `json:"kind"`
	// Labels are used to select group of MeshServices that match labels. Either Labels or
	// Name and Namespace can be used.
	Labels map[string]string `json:"labels,omitempty"`
	// Mesh is reserved for future use to identify cross mesh resources.
	Mesh *string `json:"mesh,omitempty"`
	// Name of the referenced resource. Can only be used with kinds: `MeshService`,
	// `MeshServiceSubset` and `MeshGatewayRoute`
	Name *string `json:"name,omitempty"`
	// Namespace specifies the namespace of target resource. If empty only resources in policy namespace
	// will be targeted.
	Namespace *string `json:"namespace,omitempty"`
	// ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
	// all data plane types are targeted by the policy.
	ProxyTypes []MeshFaultInjectionItemProxyTypes `json:"proxyTypes,omitempty"`
	// SectionName is used to target specific section of resource.
	// For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected.
	SectionName *string `json:"sectionName,omitempty"`
	// Tags used to select a subset of proxies by tags. Can only be used with kinds
	// `MeshSubset` and `MeshServiceSubset`
	Tags map[string]string `json:"tags,omitempty"`
}

func (m *MeshFaultInjectionItemTargetRef) GetKind() MeshFaultInjectionItemKind {
	if m == nil {
		return MeshFaultInjectionItemKind("")
	}
	return m.Kind
}

func (m *MeshFaultInjectionItemTargetRef) GetLabels() map[string]string {
	if m == nil {
		return nil
	}
	return m.Labels
}

func (m *MeshFaultInjectionItemTargetRef) GetMesh() *string {
	if m == nil {
		return nil
	}
	return m.Mesh
}

func (m *MeshFaultInjectionItemTargetRef) GetName() *string {
	if m == nil {
		return nil
	}
	return m.Name
}

func (m *MeshFaultInjectionItemTargetRef) GetNamespace() *string {
	if m == nil {
		return nil
	}
	return m.Namespace
}

func (m *MeshFaultInjectionItemTargetRef) GetProxyTypes() []MeshFaultInjectionItemProxyTypes {
	if m == nil {
		return nil
	}
	return m.ProxyTypes
}

func (m *MeshFaultInjectionItemTargetRef) GetSectionName() *string {
	if m == nil {
		return nil
	}
	return m.SectionName
}

func (m *MeshFaultInjectionItemTargetRef) GetTags() map[string]string {
	if m == nil {
		return nil
	}
	return m.Tags
}

type MeshFaultInjectionItemSpecToPercentageType string

const (
	MeshFaultInjectionItemSpecToPercentageTypeInteger MeshFaultInjectionItemSpecToPercentageType = "integer"
	MeshFaultInjectionItemSpecToPercentageTypeStr     MeshFaultInjectionItemSpecToPercentageType = "str"
)

// MeshFaultInjectionItemSpecToPercentage - Percentage of requests on which abort will be injected, has to be
// either int or decimal represented as string.
type MeshFaultInjectionItemSpecToPercentage struct {
	Integer *int64  `queryParam:"inline,name=percentage"`
	Str     *string `queryParam:"inline,name=percentage"`

	Type MeshFaultInjectionItemSpecToPercentageType
}

func CreateMeshFaultInjectionItemSpecToPercentageInteger(integer int64) MeshFaultInjectionItemSpecToPercentage {
	typ := MeshFaultInjectionItemSpecToPercentageTypeInteger

	return MeshFaultInjectionItemSpecToPercentage{
		Integer: &integer,
		Type:    typ,
	}
}

func CreateMeshFaultInjectionItemSpecToPercentageStr(str string) MeshFaultInjectionItemSpecToPercentage {
	typ := MeshFaultInjectionItemSpecToPercentageTypeStr

	return MeshFaultInjectionItemSpecToPercentage{
		Str:  &str,
		Type: typ,
	}
}

func (u *MeshFaultInjectionItemSpecToPercentage) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var integer int64 = int64(0)
	if err := utils.UnmarshalJSON(data, &integer, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  MeshFaultInjectionItemSpecToPercentageTypeInteger,
			Value: &integer,
		})
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  MeshFaultInjectionItemSpecToPercentageTypeStr,
			Value: &str,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for MeshFaultInjectionItemSpecToPercentage", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestCandidate(candidates)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for MeshFaultInjectionItemSpecToPercentage", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(MeshFaultInjectionItemSpecToPercentageType)
	switch best.Type {
	case MeshFaultInjectionItemSpecToPercentageTypeInteger:
		u.Integer = best.Value.(*int64)
		return nil
	case MeshFaultInjectionItemSpecToPercentageTypeStr:
		u.Str = best.Value.(*string)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for MeshFaultInjectionItemSpecToPercentage", string(data))
}

func (u MeshFaultInjectionItemSpecToPercentage) MarshalJSON() ([]byte, error) {
	if u.Integer != nil {
		return utils.MarshalJSON(u.Integer, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	return nil, errors.New("could not marshal union type MeshFaultInjectionItemSpecToPercentage: all fields are null")
}

// MeshFaultInjectionItemSpecAbort - Abort defines a configuration of not delivering requests to destination
// service and replacing the responses from destination dataplane by
// predefined status code
type MeshFaultInjectionItemSpecAbort struct {
	// HTTP status code which will be returned to source side
	HTTPStatus int `json:"httpStatus"`
	// Percentage of requests on which abort will be injected, has to be
	// either int or decimal represented as string.
	Percentage MeshFaultInjectionItemSpecToPercentage `json:"percentage"`
}

func (m *MeshFaultInjectionItemSpecAbort) GetHTTPStatus() int {
	if m == nil {
		return 0
	}
	return m.HTTPStatus
}

func (m *MeshFaultInjectionItemSpecAbort) GetPercentage() MeshFaultInjectionItemSpecToPercentage {
	if m == nil {
		return MeshFaultInjectionItemSpecToPercentage{}
	}
	return m.Percentage
}

type MeshFaultInjectionItemSpecToDefaultPercentageType string

const (
	MeshFaultInjectionItemSpecToDefaultPercentageTypeInteger MeshFaultInjectionItemSpecToDefaultPercentageType = "integer"
	MeshFaultInjectionItemSpecToDefaultPercentageTypeStr     MeshFaultInjectionItemSpecToDefaultPercentageType = "str"
)

// MeshFaultInjectionItemSpecToDefaultPercentage - Percentage of requests on which delay will be injected, has to be
// either int or decimal represented as string.
type MeshFaultInjectionItemSpecToDefaultPercentage struct {
	Integer *int64  `queryParam:"inline,name=percentage"`
	Str     *string `queryParam:"inline,name=percentage"`

	Type MeshFaultInjectionItemSpecToDefaultPercentageType
}

func CreateMeshFaultInjectionItemSpecToDefaultPercentageInteger(integer int64) MeshFaultInjectionItemSpecToDefaultPercentage {
	typ := MeshFaultInjectionItemSpecToDefaultPercentageTypeInteger

	return MeshFaultInjectionItemSpecToDefaultPercentage{
		Integer: &integer,
		Type:    typ,
	}
}

func CreateMeshFaultInjectionItemSpecToDefaultPercentageStr(str string) MeshFaultInjectionItemSpecToDefaultPercentage {
	typ := MeshFaultInjectionItemSpecToDefaultPercentageTypeStr

	return MeshFaultInjectionItemSpecToDefaultPercentage{
		Str:  &str,
		Type: typ,
	}
}

func (u *MeshFaultInjectionItemSpecToDefaultPercentage) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var integer int64 = int64(0)
	if err := utils.UnmarshalJSON(data, &integer, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  MeshFaultInjectionItemSpecToDefaultPercentageTypeInteger,
			Value: &integer,
		})
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  MeshFaultInjectionItemSpecToDefaultPercentageTypeStr,
			Value: &str,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for MeshFaultInjectionItemSpecToDefaultPercentage", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestCandidate(candidates)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for MeshFaultInjectionItemSpecToDefaultPercentage", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(MeshFaultInjectionItemSpecToDefaultPercentageType)
	switch best.Type {
	case MeshFaultInjectionItemSpecToDefaultPercentageTypeInteger:
		u.Integer = best.Value.(*int64)
		return nil
	case MeshFaultInjectionItemSpecToDefaultPercentageTypeStr:
		u.Str = best.Value.(*string)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for MeshFaultInjectionItemSpecToDefaultPercentage", string(data))
}

func (u MeshFaultInjectionItemSpecToDefaultPercentage) MarshalJSON() ([]byte, error) {
	if u.Integer != nil {
		return utils.MarshalJSON(u.Integer, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	return nil, errors.New("could not marshal union type MeshFaultInjectionItemSpecToDefaultPercentage: all fields are null")
}

// MeshFaultInjectionItemSpecDelay - Delay defines configuration of delaying a response from a destination
type MeshFaultInjectionItemSpecDelay struct {
	// Percentage of requests on which delay will be injected, has to be
	// either int or decimal represented as string.
	Percentage MeshFaultInjectionItemSpecToDefaultPercentage `json:"percentage"`
	// The duration during which the response will be delayed
	Value string `json:"value"`
}

func (m *MeshFaultInjectionItemSpecDelay) GetPercentage() MeshFaultInjectionItemSpecToDefaultPercentage {
	if m == nil {
		return MeshFaultInjectionItemSpecToDefaultPercentage{}
	}
	return m.Percentage
}

func (m *MeshFaultInjectionItemSpecDelay) GetValue() string {
	if m == nil {
		return ""
	}
	return m.Value
}

type MeshFaultInjectionItemSpecToDefaultHTTPPercentageType string

const (
	MeshFaultInjectionItemSpecToDefaultHTTPPercentageTypeInteger MeshFaultInjectionItemSpecToDefaultHTTPPercentageType = "integer"
	MeshFaultInjectionItemSpecToDefaultHTTPPercentageTypeStr     MeshFaultInjectionItemSpecToDefaultHTTPPercentageType = "str"
)

// MeshFaultInjectionItemSpecToDefaultHTTPPercentage - Percentage of requests on which response bandwidth limit will be
// either int or decimal represented as string.
type MeshFaultInjectionItemSpecToDefaultHTTPPercentage struct {
	Integer *int64  `queryParam:"inline,name=percentage"`
	Str     *string `queryParam:"inline,name=percentage"`

	Type MeshFaultInjectionItemSpecToDefaultHTTPPercentageType
}

func CreateMeshFaultInjectionItemSpecToDefaultHTTPPercentageInteger(integer int64) MeshFaultInjectionItemSpecToDefaultHTTPPercentage {
	typ := MeshFaultInjectionItemSpecToDefaultHTTPPercentageTypeInteger

	return MeshFaultInjectionItemSpecToDefaultHTTPPercentage{
		Integer: &integer,
		Type:    typ,
	}
}

func CreateMeshFaultInjectionItemSpecToDefaultHTTPPercentageStr(str string) MeshFaultInjectionItemSpecToDefaultHTTPPercentage {
	typ := MeshFaultInjectionItemSpecToDefaultHTTPPercentageTypeStr

	return MeshFaultInjectionItemSpecToDefaultHTTPPercentage{
		Str:  &str,
		Type: typ,
	}
}

func (u *MeshFaultInjectionItemSpecToDefaultHTTPPercentage) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var integer int64 = int64(0)
	if err := utils.UnmarshalJSON(data, &integer, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  MeshFaultInjectionItemSpecToDefaultHTTPPercentageTypeInteger,
			Value: &integer,
		})
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  MeshFaultInjectionItemSpecToDefaultHTTPPercentageTypeStr,
			Value: &str,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for MeshFaultInjectionItemSpecToDefaultHTTPPercentage", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestCandidate(candidates)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for MeshFaultInjectionItemSpecToDefaultHTTPPercentage", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(MeshFaultInjectionItemSpecToDefaultHTTPPercentageType)
	switch best.Type {
	case MeshFaultInjectionItemSpecToDefaultHTTPPercentageTypeInteger:
		u.Integer = best.Value.(*int64)
		return nil
	case MeshFaultInjectionItemSpecToDefaultHTTPPercentageTypeStr:
		u.Str = best.Value.(*string)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for MeshFaultInjectionItemSpecToDefaultHTTPPercentage", string(data))
}

func (u MeshFaultInjectionItemSpecToDefaultHTTPPercentage) MarshalJSON() ([]byte, error) {
	if u.Integer != nil {
		return utils.MarshalJSON(u.Integer, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	return nil, errors.New("could not marshal union type MeshFaultInjectionItemSpecToDefaultHTTPPercentage: all fields are null")
}

// MeshFaultInjectionItemSpecResponseBandwidth - ResponseBandwidth defines a configuration to limit the speed of
// responding to the requests
type MeshFaultInjectionItemSpecResponseBandwidth struct {
	// Limit is represented by value measure in Gbps, Mbps, kbps, e.g.
	// 10kbps
	Limit string `json:"limit"`
	// Percentage of requests on which response bandwidth limit will be
	// either int or decimal represented as string.
	Percentage MeshFaultInjectionItemSpecToDefaultHTTPPercentage `json:"percentage"`
}

func (m *MeshFaultInjectionItemSpecResponseBandwidth) GetLimit() string {
	if m == nil {
		return ""
	}
	return m.Limit
}

func (m *MeshFaultInjectionItemSpecResponseBandwidth) GetPercentage() MeshFaultInjectionItemSpecToDefaultHTTPPercentage {
	if m == nil {
		return MeshFaultInjectionItemSpecToDefaultHTTPPercentage{}
	}
	return m.Percentage
}

// MeshFaultInjectionItemSpecHTTP - FaultInjection defines the configuration of faults between dataplanes.
type MeshFaultInjectionItemSpecHTTP struct {
	// Abort defines a configuration of not delivering requests to destination
	// service and replacing the responses from destination dataplane by
	// predefined status code
	Abort *MeshFaultInjectionItemSpecAbort `json:"abort,omitempty"`
	// Delay defines configuration of delaying a response from a destination
	Delay *MeshFaultInjectionItemSpecDelay `json:"delay,omitempty"`
	// ResponseBandwidth defines a configuration to limit the speed of
	// responding to the requests
	ResponseBandwidth *MeshFaultInjectionItemSpecResponseBandwidth `json:"responseBandwidth,omitempty"`
}

func (m *MeshFaultInjectionItemSpecHTTP) GetAbort() *MeshFaultInjectionItemSpecAbort {
	if m == nil {
		return nil
	}
	return m.Abort
}

func (m *MeshFaultInjectionItemSpecHTTP) GetDelay() *MeshFaultInjectionItemSpecDelay {
	if m == nil {
		return nil
	}
	return m.Delay
}

func (m *MeshFaultInjectionItemSpecHTTP) GetResponseBandwidth() *MeshFaultInjectionItemSpecResponseBandwidth {
	if m == nil {
		return nil
	}
	return m.ResponseBandwidth
}

// MeshFaultInjectionItemSpecToDefault - Default is a configuration specific to the group of destinations referenced in
// 'targetRef'
type MeshFaultInjectionItemSpecToDefault struct {
	// Http allows to define list of Http faults between dataplanes.
	HTTP []MeshFaultInjectionItemSpecHTTP `json:"http,omitempty"`
}

func (m *MeshFaultInjectionItemSpecToDefault) GetHTTP() []MeshFaultInjectionItemSpecHTTP {
	if m == nil {
		return nil
	}
	return m.HTTP
}

// MeshFaultInjectionItemSpecToKind - Kind of the referenced resource
type MeshFaultInjectionItemSpecToKind string

const (
	MeshFaultInjectionItemSpecToKindMesh                 MeshFaultInjectionItemSpecToKind = "Mesh"
	MeshFaultInjectionItemSpecToKindMeshSubset           MeshFaultInjectionItemSpecToKind = "MeshSubset"
	MeshFaultInjectionItemSpecToKindMeshGateway          MeshFaultInjectionItemSpecToKind = "MeshGateway"
	MeshFaultInjectionItemSpecToKindMeshService          MeshFaultInjectionItemSpecToKind = "MeshService"
	MeshFaultInjectionItemSpecToKindMeshExternalService  MeshFaultInjectionItemSpecToKind = "MeshExternalService"
	MeshFaultInjectionItemSpecToKindMeshMultiZoneService MeshFaultInjectionItemSpecToKind = "MeshMultiZoneService"
	MeshFaultInjectionItemSpecToKindMeshServiceSubset    MeshFaultInjectionItemSpecToKind = "MeshServiceSubset"
	MeshFaultInjectionItemSpecToKindMeshHTTPRoute        MeshFaultInjectionItemSpecToKind = "MeshHTTPRoute"
	MeshFaultInjectionItemSpecToKindDataplane            MeshFaultInjectionItemSpecToKind = "Dataplane"
)

func (e MeshFaultInjectionItemSpecToKind) ToPointer() *MeshFaultInjectionItemSpecToKind {
	return &e
}
func (e *MeshFaultInjectionItemSpecToKind) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Mesh":
		fallthrough
	case "MeshSubset":
		fallthrough
	case "MeshGateway":
		fallthrough
	case "MeshService":
		fallthrough
	case "MeshExternalService":
		fallthrough
	case "MeshMultiZoneService":
		fallthrough
	case "MeshServiceSubset":
		fallthrough
	case "MeshHTTPRoute":
		fallthrough
	case "Dataplane":
		*e = MeshFaultInjectionItemSpecToKind(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshFaultInjectionItemSpecToKind: %v", v)
	}
}

type MeshFaultInjectionItemSpecToProxyTypes string

const (
	MeshFaultInjectionItemSpecToProxyTypesSidecar MeshFaultInjectionItemSpecToProxyTypes = "Sidecar"
	MeshFaultInjectionItemSpecToProxyTypesGateway MeshFaultInjectionItemSpecToProxyTypes = "Gateway"
)

func (e MeshFaultInjectionItemSpecToProxyTypes) ToPointer() *MeshFaultInjectionItemSpecToProxyTypes {
	return &e
}
func (e *MeshFaultInjectionItemSpecToProxyTypes) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Sidecar":
		fallthrough
	case "Gateway":
		*e = MeshFaultInjectionItemSpecToProxyTypes(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshFaultInjectionItemSpecToProxyTypes: %v", v)
	}
}

// MeshFaultInjectionItemSpecToTargetRef - TargetRef is a reference to the resource that represents a group of
// destinations.
type MeshFaultInjectionItemSpecToTargetRef struct {
	// Kind of the referenced resource
	Kind MeshFaultInjectionItemSpecToKind `json:"kind"`
	// Labels are used to select group of MeshServices that match labels. Either Labels or
	// Name and Namespace can be used.
	Labels map[string]string `json:"labels,omitempty"`
	// Mesh is reserved for future use to identify cross mesh resources.
	Mesh *string `json:"mesh,omitempty"`
	// Name of the referenced resource. Can only be used with kinds: `MeshService`,
	// `MeshServiceSubset` and `MeshGatewayRoute`
	Name *string `json:"name,omitempty"`
	// Namespace specifies the namespace of target resource. If empty only resources in policy namespace
	// will be targeted.
	Namespace *string `json:"namespace,omitempty"`
	// ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
	// all data plane types are targeted by the policy.
	ProxyTypes []MeshFaultInjectionItemSpecToProxyTypes `json:"proxyTypes,omitempty"`
	// SectionName is used to target specific section of resource.
	// For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected.
	SectionName *string `json:"sectionName,omitempty"`
	// Tags used to select a subset of proxies by tags. Can only be used with kinds
	// `MeshSubset` and `MeshServiceSubset`
	Tags map[string]string `json:"tags,omitempty"`
}

func (m *MeshFaultInjectionItemSpecToTargetRef) GetKind() MeshFaultInjectionItemSpecToKind {
	if m == nil {
		return MeshFaultInjectionItemSpecToKind("")
	}
	return m.Kind
}

func (m *MeshFaultInjectionItemSpecToTargetRef) GetLabels() map[string]string {
	if m == nil {
		return nil
	}
	return m.Labels
}

func (m *MeshFaultInjectionItemSpecToTargetRef) GetMesh() *string {
	if m == nil {
		return nil
	}
	return m.Mesh
}

func (m *MeshFaultInjectionItemSpecToTargetRef) GetName() *string {
	if m == nil {
		return nil
	}
	return m.Name
}

func (m *MeshFaultInjectionItemSpecToTargetRef) GetNamespace() *string {
	if m == nil {
		return nil
	}
	return m.Namespace
}

func (m *MeshFaultInjectionItemSpecToTargetRef) GetProxyTypes() []MeshFaultInjectionItemSpecToProxyTypes {
	if m == nil {
		return nil
	}
	return m.ProxyTypes
}

func (m *MeshFaultInjectionItemSpecToTargetRef) GetSectionName() *string {
	if m == nil {
		return nil
	}
	return m.SectionName
}

func (m *MeshFaultInjectionItemSpecToTargetRef) GetTags() map[string]string {
	if m == nil {
		return nil
	}
	return m.Tags
}

type MeshFaultInjectionItemTo struct {
	// Default is a configuration specific to the group of destinations referenced in
	// 'targetRef'
	Default *MeshFaultInjectionItemSpecToDefault `json:"default,omitempty"`
	// TargetRef is a reference to the resource that represents a group of
	// destinations.
	TargetRef MeshFaultInjectionItemSpecToTargetRef `json:"targetRef"`
}

func (m *MeshFaultInjectionItemTo) GetDefault() *MeshFaultInjectionItemSpecToDefault {
	if m == nil {
		return nil
	}
	return m.Default
}

func (m *MeshFaultInjectionItemTo) GetTargetRef() MeshFaultInjectionItemSpecToTargetRef {
	if m == nil {
		return MeshFaultInjectionItemSpecToTargetRef{}
	}
	return m.TargetRef
}

// MeshFaultInjectionItemSpec - Spec is the specification of the Kuma MeshFaultInjection resource.
type MeshFaultInjectionItemSpec struct {
	// From list makes a match between clients and corresponding configurations
	From []MeshFaultInjectionItemFrom `json:"from,omitempty"`
	// Rules defines inbound fault injection configuration
	Rules []MeshFaultInjectionItemRules `json:"rules,omitempty"`
	// TargetRef is a reference to the resource the policy takes an effect on.
	// The resource could be either a real store object or virtual resource
	// defined inplace.
	TargetRef *MeshFaultInjectionItemTargetRef `json:"targetRef,omitempty"`
	// To list makes a match between clients and corresponding configurations
	To []MeshFaultInjectionItemTo `json:"to,omitempty"`
}

func (m *MeshFaultInjectionItemSpec) GetFrom() []MeshFaultInjectionItemFrom {
	if m == nil {
		return nil
	}
	return m.From
}

func (m *MeshFaultInjectionItemSpec) GetRules() []MeshFaultInjectionItemRules {
	if m == nil {
		return nil
	}
	return m.Rules
}

func (m *MeshFaultInjectionItemSpec) GetTargetRef() *MeshFaultInjectionItemTargetRef {
	if m == nil {
		return nil
	}
	return m.TargetRef
}

func (m *MeshFaultInjectionItemSpec) GetTo() []MeshFaultInjectionItemTo {
	if m == nil {
		return nil
	}
	return m.To
}

// MeshFaultInjectionItem - Successful response
type MeshFaultInjectionItem struct {
	// the type of the resource
	Type MeshFaultInjectionItemType `json:"type"`
	// Mesh is the name of the Kuma mesh this resource belongs to. It may be omitted for cluster-scoped resources.
	Mesh *string `default:"default" json:"mesh"`
	// Name of the Kuma resource
	Name string `json:"name"`
	// The labels to help identity resources
	Labels map[string]string `json:"labels,omitempty"`
	// Spec is the specification of the Kuma MeshFaultInjection resource.
	Spec MeshFaultInjectionItemSpec `json:"spec"`
	// Time at which the resource was created
	CreationTime *time.Time `json:"creationTime,omitempty"`
	// Time at which the resource was updated
	ModificationTime *time.Time `json:"modificationTime,omitempty"`
}

func (m MeshFaultInjectionItem) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(m, "", false)
}

func (m *MeshFaultInjectionItem) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &m, "", false, []string{"type", "name", "spec"}); err != nil {
		return err
	}
	return nil
}

func (m *MeshFaultInjectionItem) GetType() MeshFaultInjectionItemType {
	if m == nil {
		return MeshFaultInjectionItemType("")
	}
	return m.Type
}

func (m *MeshFaultInjectionItem) GetMesh() *string {
	if m == nil {
		return nil
	}
	return m.Mesh
}

func (m *MeshFaultInjectionItem) GetName() string {
	if m == nil {
		return ""
	}
	return m.Name
}

func (m *MeshFaultInjectionItem) GetLabels() map[string]string {
	if m == nil {
		return nil
	}
	return m.Labels
}

func (m *MeshFaultInjectionItem) GetSpec() MeshFaultInjectionItemSpec {
	if m == nil {
		return MeshFaultInjectionItemSpec{}
	}
	return m.Spec
}

func (m *MeshFaultInjectionItem) GetCreationTime() *time.Time {
	if m == nil {
		return nil
	}
	return m.CreationTime
}

func (m *MeshFaultInjectionItem) GetModificationTime() *time.Time {
	if m == nil {
		return nil
	}
	return m.ModificationTime
}

type MeshFaultInjectionItemInput struct {
	// the type of the resource
	Type MeshFaultInjectionItemType `json:"type"`
	// Mesh is the name of the Kuma mesh this resource belongs to. It may be omitted for cluster-scoped resources.
	Mesh *string `default:"default" json:"mesh"`
	// Name of the Kuma resource
	Name string `json:"name"`
	// The labels to help identity resources
	Labels map[string]string `json:"labels,omitempty"`
	// Spec is the specification of the Kuma MeshFaultInjection resource.
	Spec MeshFaultInjectionItemSpec `json:"spec"`
}

func (m MeshFaultInjectionItemInput) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(m, "", false)
}

func (m *MeshFaultInjectionItemInput) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &m, "", false, []string{"type", "name", "spec"}); err != nil {
		return err
	}
	return nil
}

func (m *MeshFaultInjectionItemInput) GetType() MeshFaultInjectionItemType {
	if m == nil {
		return MeshFaultInjectionItemType("")
	}
	return m.Type
}

func (m *MeshFaultInjectionItemInput) GetMesh() *string {
	if m == nil {
		return nil
	}
	return m.Mesh
}

func (m *MeshFaultInjectionItemInput) GetName() string {
	if m == nil {
		return ""
	}
	return m.Name
}

func (m *MeshFaultInjectionItemInput) GetLabels() map[string]string {
	if m == nil {
		return nil
	}
	return m.Labels
}

func (m *MeshFaultInjectionItemInput) GetSpec() MeshFaultInjectionItemSpec {
	if m == nil {
		return MeshFaultInjectionItemSpec{}
	}
	return m.Spec
}
