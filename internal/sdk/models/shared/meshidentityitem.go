// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
	"github.com/kong/terraform-provider-kong-mesh/internal/sdk/internal/utils"
	"time"
)

// MeshIdentityItemType - the type of the resource
type MeshIdentityItemType string

const (
	MeshIdentityItemTypeMeshIdentity MeshIdentityItemType = "MeshIdentity"
)

func (e MeshIdentityItemType) ToPointer() *MeshIdentityItemType {
	return &e
}
func (e *MeshIdentityItemType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "MeshIdentity":
		*e = MeshIdentityItemType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshIdentityItemType: %v", v)
	}
}

// Autogenerate configures the control plane to use self-signed certificates.
type Autogenerate struct {
	Enabled *bool `json:"enabled,omitempty"`
}

func (a *Autogenerate) GetEnabled() *bool {
	if a == nil {
		return nil
	}
	return a.Enabled
}

type EnvVar struct {
	Name string `json:"name"`
}

func (e *EnvVar) GetName() string {
	if e == nil {
		return ""
	}
	return e.Name
}

type MeshIdentityItemFile struct {
	Path string `json:"path"`
}

func (m *MeshIdentityItemFile) GetPath() string {
	if m == nil {
		return ""
	}
	return m.Path
}

type InsecureInline struct {
	Value string `json:"value"`
}

func (i *InsecureInline) GetValue() string {
	if i == nil {
		return ""
	}
	return i.Value
}

type MeshIdentityItemKind string

const (
	MeshIdentityItemKindSecret MeshIdentityItemKind = "Secret"
)

func (e MeshIdentityItemKind) ToPointer() *MeshIdentityItemKind {
	return &e
}
func (e *MeshIdentityItemKind) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Secret":
		*e = MeshIdentityItemKind(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshIdentityItemKind: %v", v)
	}
}

type SecretRef struct {
	Kind MeshIdentityItemKind `json:"kind"`
	Name string               `json:"name"`
}

func (s *SecretRef) GetKind() MeshIdentityItemKind {
	if s == nil {
		return MeshIdentityItemKind("")
	}
	return s.Kind
}

func (s *SecretRef) GetName() string {
	if s == nil {
		return ""
	}
	return s.Name
}

type MeshIdentityItemSpecProviderBundledType string

const (
	MeshIdentityItemSpecProviderBundledTypeFile           MeshIdentityItemSpecProviderBundledType = "File"
	MeshIdentityItemSpecProviderBundledTypeSecret         MeshIdentityItemSpecProviderBundledType = "Secret"
	MeshIdentityItemSpecProviderBundledTypeEnvVar         MeshIdentityItemSpecProviderBundledType = "EnvVar"
	MeshIdentityItemSpecProviderBundledTypeInsecureInline MeshIdentityItemSpecProviderBundledType = "InsecureInline"
)

func (e MeshIdentityItemSpecProviderBundledType) ToPointer() *MeshIdentityItemSpecProviderBundledType {
	return &e
}
func (e *MeshIdentityItemSpecProviderBundledType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "File":
		fallthrough
	case "Secret":
		fallthrough
	case "EnvVar":
		fallthrough
	case "InsecureInline":
		*e = MeshIdentityItemSpecProviderBundledType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshIdentityItemSpecProviderBundledType: %v", v)
	}
}

// Certificate allows the user to specify a custom certificate.
type Certificate struct {
	EnvVar         *EnvVar                                 `json:"envVar,omitempty"`
	File           *MeshIdentityItemFile                   `json:"file,omitempty"`
	InsecureInline *InsecureInline                         `json:"insecureInline,omitempty"`
	SecretRef      *SecretRef                              `json:"secretRef,omitempty"`
	Type           MeshIdentityItemSpecProviderBundledType `json:"type"`
}

func (c *Certificate) GetEnvVar() *EnvVar {
	if c == nil {
		return nil
	}
	return c.EnvVar
}

func (c *Certificate) GetFile() *MeshIdentityItemFile {
	if c == nil {
		return nil
	}
	return c.File
}

func (c *Certificate) GetInsecureInline() *InsecureInline {
	if c == nil {
		return nil
	}
	return c.InsecureInline
}

func (c *Certificate) GetSecretRef() *SecretRef {
	if c == nil {
		return nil
	}
	return c.SecretRef
}

func (c *Certificate) GetType() MeshIdentityItemSpecProviderBundledType {
	if c == nil {
		return MeshIdentityItemSpecProviderBundledType("")
	}
	return c.Type
}

type MeshIdentityItemEnvVar struct {
	Name string `json:"name"`
}

func (m *MeshIdentityItemEnvVar) GetName() string {
	if m == nil {
		return ""
	}
	return m.Name
}

type MeshIdentityItemSpecFile struct {
	Path string `json:"path"`
}

func (m *MeshIdentityItemSpecFile) GetPath() string {
	if m == nil {
		return ""
	}
	return m.Path
}

type MeshIdentityItemInsecureInline struct {
	Value string `json:"value"`
}

func (m *MeshIdentityItemInsecureInline) GetValue() string {
	if m == nil {
		return ""
	}
	return m.Value
}

type MeshIdentityItemSpecKind string

const (
	MeshIdentityItemSpecKindSecret MeshIdentityItemSpecKind = "Secret"
)

func (e MeshIdentityItemSpecKind) ToPointer() *MeshIdentityItemSpecKind {
	return &e
}
func (e *MeshIdentityItemSpecKind) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Secret":
		*e = MeshIdentityItemSpecKind(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshIdentityItemSpecKind: %v", v)
	}
}

type MeshIdentityItemSecretRef struct {
	Kind MeshIdentityItemSpecKind `json:"kind"`
	Name string                   `json:"name"`
}

func (m *MeshIdentityItemSecretRef) GetKind() MeshIdentityItemSpecKind {
	if m == nil {
		return MeshIdentityItemSpecKind("")
	}
	return m.Kind
}

func (m *MeshIdentityItemSecretRef) GetName() string {
	if m == nil {
		return ""
	}
	return m.Name
}

type MeshIdentityItemSpecProviderType string

const (
	MeshIdentityItemSpecProviderTypeFile           MeshIdentityItemSpecProviderType = "File"
	MeshIdentityItemSpecProviderTypeSecret         MeshIdentityItemSpecProviderType = "Secret"
	MeshIdentityItemSpecProviderTypeEnvVar         MeshIdentityItemSpecProviderType = "EnvVar"
	MeshIdentityItemSpecProviderTypeInsecureInline MeshIdentityItemSpecProviderType = "InsecureInline"
)

func (e MeshIdentityItemSpecProviderType) ToPointer() *MeshIdentityItemSpecProviderType {
	return &e
}
func (e *MeshIdentityItemSpecProviderType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "File":
		fallthrough
	case "Secret":
		fallthrough
	case "EnvVar":
		fallthrough
	case "InsecureInline":
		*e = MeshIdentityItemSpecProviderType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshIdentityItemSpecProviderType: %v", v)
	}
}

// PrivateKey allows the user to specify a custom private key.
type PrivateKey struct {
	EnvVar         *MeshIdentityItemEnvVar          `json:"envVar,omitempty"`
	File           *MeshIdentityItemSpecFile        `json:"file,omitempty"`
	InsecureInline *MeshIdentityItemInsecureInline  `json:"insecureInline,omitempty"`
	SecretRef      *MeshIdentityItemSecretRef       `json:"secretRef,omitempty"`
	Type           MeshIdentityItemSpecProviderType `json:"type"`
}

func (p *PrivateKey) GetEnvVar() *MeshIdentityItemEnvVar {
	if p == nil {
		return nil
	}
	return p.EnvVar
}

func (p *PrivateKey) GetFile() *MeshIdentityItemSpecFile {
	if p == nil {
		return nil
	}
	return p.File
}

func (p *PrivateKey) GetInsecureInline() *MeshIdentityItemInsecureInline {
	if p == nil {
		return nil
	}
	return p.InsecureInline
}

func (p *PrivateKey) GetSecretRef() *MeshIdentityItemSecretRef {
	if p == nil {
		return nil
	}
	return p.SecretRef
}

func (p *PrivateKey) GetType() MeshIdentityItemSpecProviderType {
	if p == nil {
		return MeshIdentityItemSpecProviderType("")
	}
	return p.Type
}

// Ca - CA has configuration related to the CA
type Ca struct {
	// Certificate allows the user to specify a custom certificate.
	Certificate *Certificate `json:"certificate,omitempty"`
	// PrivateKey allows the user to specify a custom private key.
	PrivateKey *PrivateKey `json:"privateKey,omitempty"`
}

func (c *Ca) GetCertificate() *Certificate {
	if c == nil {
		return nil
	}
	return c.Certificate
}

func (c *Ca) GetPrivateKey() *PrivateKey {
	if c == nil {
		return nil
	}
	return c.PrivateKey
}

// CertificateParameters allows users to define certificate generation parameters.
type CertificateParameters struct {
	Expiry *string `json:"expiry,omitempty"`
}

func (c *CertificateParameters) GetExpiry() *string {
	if c == nil {
		return nil
	}
	return c.Expiry
}

// MeshTrustCreation defines whether a MeshTrust resource should be automatically created
// from an existing MeshIdentity. If not defined, the control plane automatically generates a MeshTrust.
type MeshTrustCreation string

const (
	MeshTrustCreationEnabled  MeshTrustCreation = "Enabled"
	MeshTrustCreationDisabled MeshTrustCreation = "Disabled"
)

func (e MeshTrustCreation) ToPointer() *MeshTrustCreation {
	return &e
}
func (e *MeshTrustCreation) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Enabled":
		fallthrough
	case "Disabled":
		*e = MeshTrustCreation(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshTrustCreation: %v", v)
	}
}

// Bundled provides information about certificates that are generated by the control plane,
// either autogenerated or provided by the user.
type Bundled struct {
	// Autogenerate configures the control plane to use self-signed certificates.
	Autogenerate *Autogenerate `json:"autogenerate,omitempty"`
	// CA has configuration related to the CA
	Ca *Ca `json:"ca,omitempty"`
	// CertificateParameters allows users to define certificate generation parameters.
	CertificateParameters *CertificateParameters `json:"certificateParameters,omitempty"`
	// InsecureAllowSelfSigned allows users to enable the use of self-signed certificates.
	InsecureAllowSelfSigned *bool `json:"insecureAllowSelfSigned,omitempty"`
	// MeshTrustCreation defines whether a MeshTrust resource should be automatically created
	// from an existing MeshIdentity. If not defined, the control plane automatically generates a MeshTrust.
	MeshTrustCreation *MeshTrustCreation `json:"meshTrustCreation,omitempty"`
}

func (b *Bundled) GetAutogenerate() *Autogenerate {
	if b == nil {
		return nil
	}
	return b.Autogenerate
}

func (b *Bundled) GetCa() *Ca {
	if b == nil {
		return nil
	}
	return b.Ca
}

func (b *Bundled) GetCertificateParameters() *CertificateParameters {
	if b == nil {
		return nil
	}
	return b.CertificateParameters
}

func (b *Bundled) GetInsecureAllowSelfSigned() *bool {
	if b == nil {
		return nil
	}
	return b.InsecureAllowSelfSigned
}

func (b *Bundled) GetMeshTrustCreation() *MeshTrustCreation {
	if b == nil {
		return nil
	}
	return b.MeshTrustCreation
}

// Agent - Spire agent configuration
type Agent struct {
	// Connection timeout to the socket exposed by Spire agent
	// Default 1 second.
	Timeout *string `json:"timeout,omitempty"`
}

func (a *Agent) GetTimeout() *string {
	if a == nil {
		return nil
	}
	return a.Timeout
}

// Spire indicates that SPIRE is used for certificate delivery.
type Spire struct {
	// Spire agent configuration
	Agent *Agent `json:"agent,omitempty"`
}

func (s *Spire) GetAgent() *Agent {
	if s == nil {
		return nil
	}
	return s.Agent
}

// MeshIdentityItemSpecType - Type specifies the type of certificate provider.
type MeshIdentityItemSpecType string

const (
	MeshIdentityItemSpecTypeBundled MeshIdentityItemSpecType = "Bundled"
	MeshIdentityItemSpecTypeSpire   MeshIdentityItemSpecType = "Spire"
)

func (e MeshIdentityItemSpecType) ToPointer() *MeshIdentityItemSpecType {
	return &e
}
func (e *MeshIdentityItemSpecType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Bundled":
		fallthrough
	case "Spire":
		*e = MeshIdentityItemSpecType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshIdentityItemSpecType: %v", v)
	}
}

type Provider struct {
	// Bundled provides information about certificates that are generated by the control plane,
	// either autogenerated or provided by the user.
	Bundled *Bundled `json:"bundled,omitempty"`
	// Spire indicates that SPIRE is used for certificate delivery.
	Spire *Spire `json:"spire,omitempty"`
	// Type specifies the type of certificate provider.
	Type MeshIdentityItemSpecType `json:"type"`
}

func (p *Provider) GetBundled() *Bundled {
	if p == nil {
		return nil
	}
	return p.Bundled
}

func (p *Provider) GetSpire() *Spire {
	if p == nil {
		return nil
	}
	return p.Spire
}

func (p *Provider) GetType() MeshIdentityItemSpecType {
	if p == nil {
		return MeshIdentityItemSpecType("")
	}
	return p.Type
}

type Dataplane struct {
	MatchLabels map[string]string `json:"matchLabels,omitempty"`
}

func (d *Dataplane) GetMatchLabels() map[string]string {
	if d == nil {
		return nil
	}
	return d.MatchLabels
}

type MeshIdentityItemSelector struct {
	Dataplane *Dataplane `json:"dataplane,omitempty"`
}

func (m *MeshIdentityItemSelector) GetDataplane() *Dataplane {
	if m == nil {
		return nil
	}
	return m.Dataplane
}

type SpiffeID struct {
	Path        *string `json:"path,omitempty"`
	TrustDomain *string `json:"trustDomain,omitempty"`
}

func (s *SpiffeID) GetPath() *string {
	if s == nil {
		return nil
	}
	return s.Path
}

func (s *SpiffeID) GetTrustDomain() *string {
	if s == nil {
		return nil
	}
	return s.TrustDomain
}

// MeshIdentityItemSpec - Spec is the specification of the Kuma MeshIdentity resource.
type MeshIdentityItemSpec struct {
	Provider Provider                  `json:"provider"`
	Selector *MeshIdentityItemSelector `json:"selector,omitempty"`
	SpiffeID *SpiffeID                 `json:"spiffeID,omitempty"`
}

func (m *MeshIdentityItemSpec) GetProvider() Provider {
	if m == nil {
		return Provider{}
	}
	return m.Provider
}

func (m *MeshIdentityItemSpec) GetSelector() *MeshIdentityItemSelector {
	if m == nil {
		return nil
	}
	return m.Selector
}

func (m *MeshIdentityItemSpec) GetSpiffeID() *SpiffeID {
	if m == nil {
		return nil
	}
	return m.SpiffeID
}

// MeshIdentityItemStatusStatus - status of the condition, one of True, False, Unknown.
type MeshIdentityItemStatusStatus string

const (
	MeshIdentityItemStatusStatusTrue    MeshIdentityItemStatusStatus = "True"
	MeshIdentityItemStatusStatusFalse   MeshIdentityItemStatusStatus = "False"
	MeshIdentityItemStatusStatusUnknown MeshIdentityItemStatusStatus = "Unknown"
)

func (e MeshIdentityItemStatusStatus) ToPointer() *MeshIdentityItemStatusStatus {
	return &e
}
func (e *MeshIdentityItemStatusStatus) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "True":
		fallthrough
	case "False":
		fallthrough
	case "Unknown":
		*e = MeshIdentityItemStatusStatus(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshIdentityItemStatusStatus: %v", v)
	}
}

type Conditions struct {
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message string `json:"message"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason string `json:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status MeshIdentityItemStatusStatus `json:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	Type string `json:"type"`
}

func (c *Conditions) GetMessage() string {
	if c == nil {
		return ""
	}
	return c.Message
}

func (c *Conditions) GetReason() string {
	if c == nil {
		return ""
	}
	return c.Reason
}

func (c *Conditions) GetStatus() MeshIdentityItemStatusStatus {
	if c == nil {
		return MeshIdentityItemStatusStatus("")
	}
	return c.Status
}

func (c *Conditions) GetType() string {
	if c == nil {
		return ""
	}
	return c.Type
}

// MeshIdentityItemStatus - Status is the current status of the Kuma MeshIdentity resource.
type MeshIdentityItemStatus struct {
	// Conditions is an array of hostname generator conditions.
	Conditions []Conditions `json:"conditions,omitempty"`
}

func (m *MeshIdentityItemStatus) GetConditions() []Conditions {
	if m == nil {
		return nil
	}
	return m.Conditions
}

// MeshIdentityItem - Successful response
type MeshIdentityItem struct {
	// the type of the resource
	Type MeshIdentityItemType `json:"type"`
	// Mesh is the name of the Kuma mesh this resource belongs to. It may be omitted for cluster-scoped resources.
	Mesh *string `default:"default" json:"mesh"`
	// Name of the Kuma resource
	Name string `json:"name"`
	// The labels to help identity resources
	Labels map[string]string `json:"labels,omitempty"`
	// Spec is the specification of the Kuma MeshIdentity resource.
	Spec MeshIdentityItemSpec `json:"spec"`
	// Time at which the resource was created
	CreationTime *time.Time `json:"creationTime,omitempty"`
	// Time at which the resource was updated
	ModificationTime *time.Time `json:"modificationTime,omitempty"`
	// Status is the current status of the Kuma MeshIdentity resource.
	Status *MeshIdentityItemStatus `json:"status,omitempty"`
}

func (m MeshIdentityItem) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(m, "", false)
}

func (m *MeshIdentityItem) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &m, "", false, []string{"type", "name", "spec"}); err != nil {
		return err
	}
	return nil
}

func (m *MeshIdentityItem) GetType() MeshIdentityItemType {
	if m == nil {
		return MeshIdentityItemType("")
	}
	return m.Type
}

func (m *MeshIdentityItem) GetMesh() *string {
	if m == nil {
		return nil
	}
	return m.Mesh
}

func (m *MeshIdentityItem) GetName() string {
	if m == nil {
		return ""
	}
	return m.Name
}

func (m *MeshIdentityItem) GetLabels() map[string]string {
	if m == nil {
		return nil
	}
	return m.Labels
}

func (m *MeshIdentityItem) GetSpec() MeshIdentityItemSpec {
	if m == nil {
		return MeshIdentityItemSpec{}
	}
	return m.Spec
}

func (m *MeshIdentityItem) GetCreationTime() *time.Time {
	if m == nil {
		return nil
	}
	return m.CreationTime
}

func (m *MeshIdentityItem) GetModificationTime() *time.Time {
	if m == nil {
		return nil
	}
	return m.ModificationTime
}

func (m *MeshIdentityItem) GetStatus() *MeshIdentityItemStatus {
	if m == nil {
		return nil
	}
	return m.Status
}

type MeshIdentityItemInput struct {
	// the type of the resource
	Type MeshIdentityItemType `json:"type"`
	// Mesh is the name of the Kuma mesh this resource belongs to. It may be omitted for cluster-scoped resources.
	Mesh *string `default:"default" json:"mesh"`
	// Name of the Kuma resource
	Name string `json:"name"`
	// The labels to help identity resources
	Labels map[string]string `json:"labels,omitempty"`
	// Spec is the specification of the Kuma MeshIdentity resource.
	Spec MeshIdentityItemSpec `json:"spec"`
}

func (m MeshIdentityItemInput) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(m, "", false)
}

func (m *MeshIdentityItemInput) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &m, "", false, []string{"type", "name", "spec"}); err != nil {
		return err
	}
	return nil
}

func (m *MeshIdentityItemInput) GetType() MeshIdentityItemType {
	if m == nil {
		return MeshIdentityItemType("")
	}
	return m.Type
}

func (m *MeshIdentityItemInput) GetMesh() *string {
	if m == nil {
		return nil
	}
	return m.Mesh
}

func (m *MeshIdentityItemInput) GetName() string {
	if m == nil {
		return ""
	}
	return m.Name
}

func (m *MeshIdentityItemInput) GetLabels() map[string]string {
	if m == nil {
		return nil
	}
	return m.Labels
}

func (m *MeshIdentityItemInput) GetSpec() MeshIdentityItemSpec {
	if m == nil {
		return MeshIdentityItemSpec{}
	}
	return m.Spec
}
