// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/kong/terraform-provider-kong-mesh/internal/sdk/internal/utils"
	"time"
)

// MeshHTTPRouteItemType - the type of the resource
type MeshHTTPRouteItemType string

const (
	MeshHTTPRouteItemTypeMeshHTTPRoute MeshHTTPRouteItemType = "MeshHTTPRoute"
)

func (e MeshHTTPRouteItemType) ToPointer() *MeshHTTPRouteItemType {
	return &e
}
func (e *MeshHTTPRouteItemType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "MeshHTTPRoute":
		*e = MeshHTTPRouteItemType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshHTTPRouteItemType: %v", v)
	}
}

// MeshHTTPRouteItemKind - Kind of the referenced resource
type MeshHTTPRouteItemKind string

const (
	MeshHTTPRouteItemKindMesh                 MeshHTTPRouteItemKind = "Mesh"
	MeshHTTPRouteItemKindMeshSubset           MeshHTTPRouteItemKind = "MeshSubset"
	MeshHTTPRouteItemKindMeshGateway          MeshHTTPRouteItemKind = "MeshGateway"
	MeshHTTPRouteItemKindMeshService          MeshHTTPRouteItemKind = "MeshService"
	MeshHTTPRouteItemKindMeshExternalService  MeshHTTPRouteItemKind = "MeshExternalService"
	MeshHTTPRouteItemKindMeshMultiZoneService MeshHTTPRouteItemKind = "MeshMultiZoneService"
	MeshHTTPRouteItemKindMeshServiceSubset    MeshHTTPRouteItemKind = "MeshServiceSubset"
	MeshHTTPRouteItemKindMeshHTTPRoute        MeshHTTPRouteItemKind = "MeshHTTPRoute"
	MeshHTTPRouteItemKindDataplane            MeshHTTPRouteItemKind = "Dataplane"
)

func (e MeshHTTPRouteItemKind) ToPointer() *MeshHTTPRouteItemKind {
	return &e
}
func (e *MeshHTTPRouteItemKind) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Mesh":
		fallthrough
	case "MeshSubset":
		fallthrough
	case "MeshGateway":
		fallthrough
	case "MeshService":
		fallthrough
	case "MeshExternalService":
		fallthrough
	case "MeshMultiZoneService":
		fallthrough
	case "MeshServiceSubset":
		fallthrough
	case "MeshHTTPRoute":
		fallthrough
	case "Dataplane":
		*e = MeshHTTPRouteItemKind(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshHTTPRouteItemKind: %v", v)
	}
}

type MeshHTTPRouteItemProxyTypes string

const (
	MeshHTTPRouteItemProxyTypesSidecar MeshHTTPRouteItemProxyTypes = "Sidecar"
	MeshHTTPRouteItemProxyTypesGateway MeshHTTPRouteItemProxyTypes = "Gateway"
)

func (e MeshHTTPRouteItemProxyTypes) ToPointer() *MeshHTTPRouteItemProxyTypes {
	return &e
}
func (e *MeshHTTPRouteItemProxyTypes) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Sidecar":
		fallthrough
	case "Gateway":
		*e = MeshHTTPRouteItemProxyTypes(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshHTTPRouteItemProxyTypes: %v", v)
	}
}

// MeshHTTPRouteItemTargetRef - TargetRef is a reference to the resource the policy takes an effect on.
// The resource could be either a real store object or virtual resource
// defined inplace.
type MeshHTTPRouteItemTargetRef struct {
	// Kind of the referenced resource
	Kind MeshHTTPRouteItemKind `json:"kind"`
	// Labels are used to select group of MeshServices that match labels. Either Labels or
	// Name and Namespace can be used.
	Labels map[string]string `json:"labels,omitempty"`
	// Mesh is reserved for future use to identify cross mesh resources.
	Mesh *string `json:"mesh,omitempty"`
	// Name of the referenced resource. Can only be used with kinds: `MeshService`,
	// `MeshServiceSubset` and `MeshGatewayRoute`
	Name *string `json:"name,omitempty"`
	// Namespace specifies the namespace of target resource. If empty only resources in policy namespace
	// will be targeted.
	Namespace *string `json:"namespace,omitempty"`
	// ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
	// all data plane types are targeted by the policy.
	ProxyTypes []MeshHTTPRouteItemProxyTypes `json:"proxyTypes,omitempty"`
	// SectionName is used to target specific section of resource.
	// For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected.
	SectionName *string `json:"sectionName,omitempty"`
	// Tags used to select a subset of proxies by tags. Can only be used with kinds
	// `MeshSubset` and `MeshServiceSubset`
	Tags map[string]string `json:"tags,omitempty"`
}

func (m *MeshHTTPRouteItemTargetRef) GetKind() MeshHTTPRouteItemKind {
	if m == nil {
		return MeshHTTPRouteItemKind("")
	}
	return m.Kind
}

func (m *MeshHTTPRouteItemTargetRef) GetLabels() map[string]string {
	if m == nil {
		return nil
	}
	return m.Labels
}

func (m *MeshHTTPRouteItemTargetRef) GetMesh() *string {
	if m == nil {
		return nil
	}
	return m.Mesh
}

func (m *MeshHTTPRouteItemTargetRef) GetName() *string {
	if m == nil {
		return nil
	}
	return m.Name
}

func (m *MeshHTTPRouteItemTargetRef) GetNamespace() *string {
	if m == nil {
		return nil
	}
	return m.Namespace
}

func (m *MeshHTTPRouteItemTargetRef) GetProxyTypes() []MeshHTTPRouteItemProxyTypes {
	if m == nil {
		return nil
	}
	return m.ProxyTypes
}

func (m *MeshHTTPRouteItemTargetRef) GetSectionName() *string {
	if m == nil {
		return nil
	}
	return m.SectionName
}

func (m *MeshHTTPRouteItemTargetRef) GetTags() map[string]string {
	if m == nil {
		return nil
	}
	return m.Tags
}

// MeshHTTPRouteItemSpecToKind - Kind of the referenced resource
type MeshHTTPRouteItemSpecToKind string

const (
	MeshHTTPRouteItemSpecToKindMesh                 MeshHTTPRouteItemSpecToKind = "Mesh"
	MeshHTTPRouteItemSpecToKindMeshSubset           MeshHTTPRouteItemSpecToKind = "MeshSubset"
	MeshHTTPRouteItemSpecToKindMeshGateway          MeshHTTPRouteItemSpecToKind = "MeshGateway"
	MeshHTTPRouteItemSpecToKindMeshService          MeshHTTPRouteItemSpecToKind = "MeshService"
	MeshHTTPRouteItemSpecToKindMeshExternalService  MeshHTTPRouteItemSpecToKind = "MeshExternalService"
	MeshHTTPRouteItemSpecToKindMeshMultiZoneService MeshHTTPRouteItemSpecToKind = "MeshMultiZoneService"
	MeshHTTPRouteItemSpecToKindMeshServiceSubset    MeshHTTPRouteItemSpecToKind = "MeshServiceSubset"
	MeshHTTPRouteItemSpecToKindMeshHTTPRoute        MeshHTTPRouteItemSpecToKind = "MeshHTTPRoute"
	MeshHTTPRouteItemSpecToKindDataplane            MeshHTTPRouteItemSpecToKind = "Dataplane"
)

func (e MeshHTTPRouteItemSpecToKind) ToPointer() *MeshHTTPRouteItemSpecToKind {
	return &e
}
func (e *MeshHTTPRouteItemSpecToKind) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Mesh":
		fallthrough
	case "MeshSubset":
		fallthrough
	case "MeshGateway":
		fallthrough
	case "MeshService":
		fallthrough
	case "MeshExternalService":
		fallthrough
	case "MeshMultiZoneService":
		fallthrough
	case "MeshServiceSubset":
		fallthrough
	case "MeshHTTPRoute":
		fallthrough
	case "Dataplane":
		*e = MeshHTTPRouteItemSpecToKind(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshHTTPRouteItemSpecToKind: %v", v)
	}
}

type MeshHTTPRouteItemSpecToProxyTypes string

const (
	MeshHTTPRouteItemSpecToProxyTypesSidecar MeshHTTPRouteItemSpecToProxyTypes = "Sidecar"
	MeshHTTPRouteItemSpecToProxyTypesGateway MeshHTTPRouteItemSpecToProxyTypes = "Gateway"
)

func (e MeshHTTPRouteItemSpecToProxyTypes) ToPointer() *MeshHTTPRouteItemSpecToProxyTypes {
	return &e
}
func (e *MeshHTTPRouteItemSpecToProxyTypes) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Sidecar":
		fallthrough
	case "Gateway":
		*e = MeshHTTPRouteItemSpecToProxyTypes(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshHTTPRouteItemSpecToProxyTypes: %v", v)
	}
}

// BackendRefs - BackendRef defines where to forward traffic.
type BackendRefs struct {
	// Kind of the referenced resource
	Kind MeshHTTPRouteItemSpecToKind `json:"kind"`
	// Labels are used to select group of MeshServices that match labels. Either Labels or
	// Name and Namespace can be used.
	Labels map[string]string `json:"labels,omitempty"`
	// Mesh is reserved for future use to identify cross mesh resources.
	Mesh *string `json:"mesh,omitempty"`
	// Name of the referenced resource. Can only be used with kinds: `MeshService`,
	// `MeshServiceSubset` and `MeshGatewayRoute`
	Name *string `json:"name,omitempty"`
	// Namespace specifies the namespace of target resource. If empty only resources in policy namespace
	// will be targeted.
	Namespace *string `json:"namespace,omitempty"`
	// Port is only supported when this ref refers to a real MeshService object
	Port *int `json:"port,omitempty"`
	// ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
	// all data plane types are targeted by the policy.
	ProxyTypes []MeshHTTPRouteItemSpecToProxyTypes `json:"proxyTypes,omitempty"`
	// SectionName is used to target specific section of resource.
	// For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected.
	SectionName *string `json:"sectionName,omitempty"`
	// Tags used to select a subset of proxies by tags. Can only be used with kinds
	// `MeshSubset` and `MeshServiceSubset`
	Tags   map[string]string `json:"tags,omitempty"`
	Weight *int64            `default:"1" json:"weight"`
}

func (b BackendRefs) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(b, "", false)
}

func (b *BackendRefs) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &b, "", false, []string{"kind"}); err != nil {
		return err
	}
	return nil
}

func (b *BackendRefs) GetKind() MeshHTTPRouteItemSpecToKind {
	if b == nil {
		return MeshHTTPRouteItemSpecToKind("")
	}
	return b.Kind
}

func (b *BackendRefs) GetLabels() map[string]string {
	if b == nil {
		return nil
	}
	return b.Labels
}

func (b *BackendRefs) GetMesh() *string {
	if b == nil {
		return nil
	}
	return b.Mesh
}

func (b *BackendRefs) GetName() *string {
	if b == nil {
		return nil
	}
	return b.Name
}

func (b *BackendRefs) GetNamespace() *string {
	if b == nil {
		return nil
	}
	return b.Namespace
}

func (b *BackendRefs) GetPort() *int {
	if b == nil {
		return nil
	}
	return b.Port
}

func (b *BackendRefs) GetProxyTypes() []MeshHTTPRouteItemSpecToProxyTypes {
	if b == nil {
		return nil
	}
	return b.ProxyTypes
}

func (b *BackendRefs) GetSectionName() *string {
	if b == nil {
		return nil
	}
	return b.SectionName
}

func (b *BackendRefs) GetTags() map[string]string {
	if b == nil {
		return nil
	}
	return b.Tags
}

func (b *BackendRefs) GetWeight() *int64 {
	if b == nil {
		return nil
	}
	return b.Weight
}

type MeshHTTPRouteItemAdd struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

func (m *MeshHTTPRouteItemAdd) GetName() string {
	if m == nil {
		return ""
	}
	return m.Name
}

func (m *MeshHTTPRouteItemAdd) GetValue() string {
	if m == nil {
		return ""
	}
	return m.Value
}

type MeshHTTPRouteItemSet struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

func (m *MeshHTTPRouteItemSet) GetName() string {
	if m == nil {
		return ""
	}
	return m.Name
}

func (m *MeshHTTPRouteItemSet) GetValue() string {
	if m == nil {
		return ""
	}
	return m.Value
}

// RequestHeaderModifier - Only one action is supported per header name.
// Configuration to set or add multiple values for a header must use RFC 7230
// header value formatting, separating each value with a comma.
type RequestHeaderModifier struct {
	Add    []MeshHTTPRouteItemAdd `json:"add,omitempty"`
	Remove []string               `json:"remove,omitempty"`
	Set    []MeshHTTPRouteItemSet `json:"set,omitempty"`
}

func (r *RequestHeaderModifier) GetAdd() []MeshHTTPRouteItemAdd {
	if r == nil {
		return nil
	}
	return r.Add
}

func (r *RequestHeaderModifier) GetRemove() []string {
	if r == nil {
		return nil
	}
	return r.Remove
}

func (r *RequestHeaderModifier) GetSet() []MeshHTTPRouteItemSet {
	if r == nil {
		return nil
	}
	return r.Set
}

// MeshHTTPRouteItemSpecToRulesKind - Kind of the referenced resource
type MeshHTTPRouteItemSpecToRulesKind string

const (
	MeshHTTPRouteItemSpecToRulesKindMesh                 MeshHTTPRouteItemSpecToRulesKind = "Mesh"
	MeshHTTPRouteItemSpecToRulesKindMeshSubset           MeshHTTPRouteItemSpecToRulesKind = "MeshSubset"
	MeshHTTPRouteItemSpecToRulesKindMeshGateway          MeshHTTPRouteItemSpecToRulesKind = "MeshGateway"
	MeshHTTPRouteItemSpecToRulesKindMeshService          MeshHTTPRouteItemSpecToRulesKind = "MeshService"
	MeshHTTPRouteItemSpecToRulesKindMeshExternalService  MeshHTTPRouteItemSpecToRulesKind = "MeshExternalService"
	MeshHTTPRouteItemSpecToRulesKindMeshMultiZoneService MeshHTTPRouteItemSpecToRulesKind = "MeshMultiZoneService"
	MeshHTTPRouteItemSpecToRulesKindMeshServiceSubset    MeshHTTPRouteItemSpecToRulesKind = "MeshServiceSubset"
	MeshHTTPRouteItemSpecToRulesKindMeshHTTPRoute        MeshHTTPRouteItemSpecToRulesKind = "MeshHTTPRoute"
	MeshHTTPRouteItemSpecToRulesKindDataplane            MeshHTTPRouteItemSpecToRulesKind = "Dataplane"
)

func (e MeshHTTPRouteItemSpecToRulesKind) ToPointer() *MeshHTTPRouteItemSpecToRulesKind {
	return &e
}
func (e *MeshHTTPRouteItemSpecToRulesKind) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Mesh":
		fallthrough
	case "MeshSubset":
		fallthrough
	case "MeshGateway":
		fallthrough
	case "MeshService":
		fallthrough
	case "MeshExternalService":
		fallthrough
	case "MeshMultiZoneService":
		fallthrough
	case "MeshServiceSubset":
		fallthrough
	case "MeshHTTPRoute":
		fallthrough
	case "Dataplane":
		*e = MeshHTTPRouteItemSpecToRulesKind(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshHTTPRouteItemSpecToRulesKind: %v", v)
	}
}

type MeshHTTPRouteItemSpecToRulesProxyTypes string

const (
	MeshHTTPRouteItemSpecToRulesProxyTypesSidecar MeshHTTPRouteItemSpecToRulesProxyTypes = "Sidecar"
	MeshHTTPRouteItemSpecToRulesProxyTypesGateway MeshHTTPRouteItemSpecToRulesProxyTypes = "Gateway"
)

func (e MeshHTTPRouteItemSpecToRulesProxyTypes) ToPointer() *MeshHTTPRouteItemSpecToRulesProxyTypes {
	return &e
}
func (e *MeshHTTPRouteItemSpecToRulesProxyTypes) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Sidecar":
		fallthrough
	case "Gateway":
		*e = MeshHTTPRouteItemSpecToRulesProxyTypes(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshHTTPRouteItemSpecToRulesProxyTypes: %v", v)
	}
}

// BackendRef defines where to forward traffic.
type BackendRef struct {
	// Kind of the referenced resource
	Kind MeshHTTPRouteItemSpecToRulesKind `json:"kind"`
	// Labels are used to select group of MeshServices that match labels. Either Labels or
	// Name and Namespace can be used.
	Labels map[string]string `json:"labels,omitempty"`
	// Mesh is reserved for future use to identify cross mesh resources.
	Mesh *string `json:"mesh,omitempty"`
	// Name of the referenced resource. Can only be used with kinds: `MeshService`,
	// `MeshServiceSubset` and `MeshGatewayRoute`
	Name *string `json:"name,omitempty"`
	// Namespace specifies the namespace of target resource. If empty only resources in policy namespace
	// will be targeted.
	Namespace *string `json:"namespace,omitempty"`
	// Port is only supported when this ref refers to a real MeshService object
	Port *int `json:"port,omitempty"`
	// ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
	// all data plane types are targeted by the policy.
	ProxyTypes []MeshHTTPRouteItemSpecToRulesProxyTypes `json:"proxyTypes,omitempty"`
	// SectionName is used to target specific section of resource.
	// For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected.
	SectionName *string `json:"sectionName,omitempty"`
	// Tags used to select a subset of proxies by tags. Can only be used with kinds
	// `MeshSubset` and `MeshServiceSubset`
	Tags   map[string]string `json:"tags,omitempty"`
	Weight *int64            `default:"1" json:"weight"`
}

func (b BackendRef) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(b, "", false)
}

func (b *BackendRef) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &b, "", false, []string{"kind"}); err != nil {
		return err
	}
	return nil
}

func (b *BackendRef) GetKind() MeshHTTPRouteItemSpecToRulesKind {
	if b == nil {
		return MeshHTTPRouteItemSpecToRulesKind("")
	}
	return b.Kind
}

func (b *BackendRef) GetLabels() map[string]string {
	if b == nil {
		return nil
	}
	return b.Labels
}

func (b *BackendRef) GetMesh() *string {
	if b == nil {
		return nil
	}
	return b.Mesh
}

func (b *BackendRef) GetName() *string {
	if b == nil {
		return nil
	}
	return b.Name
}

func (b *BackendRef) GetNamespace() *string {
	if b == nil {
		return nil
	}
	return b.Namespace
}

func (b *BackendRef) GetPort() *int {
	if b == nil {
		return nil
	}
	return b.Port
}

func (b *BackendRef) GetProxyTypes() []MeshHTTPRouteItemSpecToRulesProxyTypes {
	if b == nil {
		return nil
	}
	return b.ProxyTypes
}

func (b *BackendRef) GetSectionName() *string {
	if b == nil {
		return nil
	}
	return b.SectionName
}

func (b *BackendRef) GetTags() map[string]string {
	if b == nil {
		return nil
	}
	return b.Tags
}

func (b *BackendRef) GetWeight() *int64 {
	if b == nil {
		return nil
	}
	return b.Weight
}

type MeshHTTPRouteItemPercentageType string

const (
	MeshHTTPRouteItemPercentageTypeInteger MeshHTTPRouteItemPercentageType = "integer"
	MeshHTTPRouteItemPercentageTypeStr     MeshHTTPRouteItemPercentageType = "str"
)

// MeshHTTPRouteItemPercentage - Percentage of requests to mirror. If not specified, all requests
// to the target cluster will be mirrored.
type MeshHTTPRouteItemPercentage struct {
	Integer *int64  `queryParam:"inline,name=percentage"`
	Str     *string `queryParam:"inline,name=percentage"`

	Type MeshHTTPRouteItemPercentageType
}

func CreateMeshHTTPRouteItemPercentageInteger(integer int64) MeshHTTPRouteItemPercentage {
	typ := MeshHTTPRouteItemPercentageTypeInteger

	return MeshHTTPRouteItemPercentage{
		Integer: &integer,
		Type:    typ,
	}
}

func CreateMeshHTTPRouteItemPercentageStr(str string) MeshHTTPRouteItemPercentage {
	typ := MeshHTTPRouteItemPercentageTypeStr

	return MeshHTTPRouteItemPercentage{
		Str:  &str,
		Type: typ,
	}
}

func (u *MeshHTTPRouteItemPercentage) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var integer int64 = int64(0)
	if err := utils.UnmarshalJSON(data, &integer, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  MeshHTTPRouteItemPercentageTypeInteger,
			Value: &integer,
		})
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  MeshHTTPRouteItemPercentageTypeStr,
			Value: &str,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for MeshHTTPRouteItemPercentage", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestCandidate(candidates)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for MeshHTTPRouteItemPercentage", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(MeshHTTPRouteItemPercentageType)
	switch best.Type {
	case MeshHTTPRouteItemPercentageTypeInteger:
		u.Integer = best.Value.(*int64)
		return nil
	case MeshHTTPRouteItemPercentageTypeStr:
		u.Str = best.Value.(*string)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for MeshHTTPRouteItemPercentage", string(data))
}

func (u MeshHTTPRouteItemPercentage) MarshalJSON() ([]byte, error) {
	if u.Integer != nil {
		return utils.MarshalJSON(u.Integer, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	return nil, errors.New("could not marshal union type MeshHTTPRouteItemPercentage: all fields are null")
}

type RequestMirror struct {
	// BackendRef defines where to forward traffic.
	BackendRef BackendRef `json:"backendRef"`
	// Percentage of requests to mirror. If not specified, all requests
	// to the target cluster will be mirrored.
	Percentage *MeshHTTPRouteItemPercentage `json:"percentage,omitempty"`
}

func (r *RequestMirror) GetBackendRef() BackendRef {
	if r == nil {
		return BackendRef{}
	}
	return r.BackendRef
}

func (r *RequestMirror) GetPercentage() *MeshHTTPRouteItemPercentage {
	if r == nil {
		return nil
	}
	return r.Percentage
}

type MeshHTTPRouteItemSpecToRulesDefaultType string

const (
	MeshHTTPRouteItemSpecToRulesDefaultTypeReplaceFullPath    MeshHTTPRouteItemSpecToRulesDefaultType = "ReplaceFullPath"
	MeshHTTPRouteItemSpecToRulesDefaultTypeReplacePrefixMatch MeshHTTPRouteItemSpecToRulesDefaultType = "ReplacePrefixMatch"
)

func (e MeshHTTPRouteItemSpecToRulesDefaultType) ToPointer() *MeshHTTPRouteItemSpecToRulesDefaultType {
	return &e
}
func (e *MeshHTTPRouteItemSpecToRulesDefaultType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "ReplaceFullPath":
		fallthrough
	case "ReplacePrefixMatch":
		*e = MeshHTTPRouteItemSpecToRulesDefaultType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshHTTPRouteItemSpecToRulesDefaultType: %v", v)
	}
}

// MeshHTTPRouteItemSpecPath - Path defines parameters used to modify the path of the incoming request.
// The modified path is then used to construct the location header.
// When empty, the request path is used as-is.
type MeshHTTPRouteItemSpecPath struct {
	ReplaceFullPath    *string                                 `json:"replaceFullPath,omitempty"`
	ReplacePrefixMatch *string                                 `json:"replacePrefixMatch,omitempty"`
	Type               MeshHTTPRouteItemSpecToRulesDefaultType `json:"type"`
}

func (m *MeshHTTPRouteItemSpecPath) GetReplaceFullPath() *string {
	if m == nil {
		return nil
	}
	return m.ReplaceFullPath
}

func (m *MeshHTTPRouteItemSpecPath) GetReplacePrefixMatch() *string {
	if m == nil {
		return nil
	}
	return m.ReplacePrefixMatch
}

func (m *MeshHTTPRouteItemSpecPath) GetType() MeshHTTPRouteItemSpecToRulesDefaultType {
	if m == nil {
		return MeshHTTPRouteItemSpecToRulesDefaultType("")
	}
	return m.Type
}

type Scheme string

const (
	SchemeHTTP  Scheme = "http"
	SchemeHTTPS Scheme = "https"
)

func (e Scheme) ToPointer() *Scheme {
	return &e
}
func (e *Scheme) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "http":
		fallthrough
	case "https":
		*e = Scheme(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Scheme: %v", v)
	}
}

// StatusCode is the HTTP status code to be used in response.
type StatusCode int64

const (
	StatusCodeThreeHundredAndOne   StatusCode = 301
	StatusCodeThreeHundredAndTwo   StatusCode = 302
	StatusCodeThreeHundredAndThree StatusCode = 303
	StatusCodeThreeHundredAndSeven StatusCode = 307
	StatusCodeThreeHundredAndEight StatusCode = 308
)

func (e StatusCode) ToPointer() *StatusCode {
	return &e
}
func (e *StatusCode) UnmarshalJSON(data []byte) error {
	var v int64
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case 301:
		fallthrough
	case 302:
		fallthrough
	case 303:
		fallthrough
	case 307:
		fallthrough
	case 308:
		*e = StatusCode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for StatusCode: %v", v)
	}
}

type RequestRedirect struct {
	// PreciseHostname is the fully qualified domain name of a network host. This
	// matches the RFC 1123 definition of a hostname with 1 notable exception that
	// numeric IP addresses are not allowed.
	//
	// Note that as per RFC1035 and RFC1123, a *label* must consist of lower case
	// alphanumeric characters or '-', and must start and end with an alphanumeric
	// character. No other punctuation is allowed.
	Hostname *string `json:"hostname,omitempty"`
	// Path defines parameters used to modify the path of the incoming request.
	// The modified path is then used to construct the location header.
	// When empty, the request path is used as-is.
	Path *MeshHTTPRouteItemSpecPath `json:"path,omitempty"`
	// Port is the port to be used in the value of the `Location`
	// header in the response.
	// When empty, port (if specified) of the request is used.
	Port   *int    `json:"port,omitempty"`
	Scheme *Scheme `json:"scheme,omitempty"`
	// StatusCode is the HTTP status code to be used in response.
	StatusCode *StatusCode `default:"302" json:"statusCode"`
}

func (r RequestRedirect) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(r, "", false)
}

func (r *RequestRedirect) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &r, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (r *RequestRedirect) GetHostname() *string {
	if r == nil {
		return nil
	}
	return r.Hostname
}

func (r *RequestRedirect) GetPath() *MeshHTTPRouteItemSpecPath {
	if r == nil {
		return nil
	}
	return r.Path
}

func (r *RequestRedirect) GetPort() *int {
	if r == nil {
		return nil
	}
	return r.Port
}

func (r *RequestRedirect) GetScheme() *Scheme {
	if r == nil {
		return nil
	}
	return r.Scheme
}

func (r *RequestRedirect) GetStatusCode() *StatusCode {
	if r == nil {
		return nil
	}
	return r.StatusCode
}

type MeshHTTPRouteItemSpecAdd struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

func (m *MeshHTTPRouteItemSpecAdd) GetName() string {
	if m == nil {
		return ""
	}
	return m.Name
}

func (m *MeshHTTPRouteItemSpecAdd) GetValue() string {
	if m == nil {
		return ""
	}
	return m.Value
}

type MeshHTTPRouteItemSpecSet struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

func (m *MeshHTTPRouteItemSpecSet) GetName() string {
	if m == nil {
		return ""
	}
	return m.Name
}

func (m *MeshHTTPRouteItemSpecSet) GetValue() string {
	if m == nil {
		return ""
	}
	return m.Value
}

// ResponseHeaderModifier - Only one action is supported per header name.
// Configuration to set or add multiple values for a header must use RFC 7230
// header value formatting, separating each value with a comma.
type ResponseHeaderModifier struct {
	Add    []MeshHTTPRouteItemSpecAdd `json:"add,omitempty"`
	Remove []string                   `json:"remove,omitempty"`
	Set    []MeshHTTPRouteItemSpecSet `json:"set,omitempty"`
}

func (r *ResponseHeaderModifier) GetAdd() []MeshHTTPRouteItemSpecAdd {
	if r == nil {
		return nil
	}
	return r.Add
}

func (r *ResponseHeaderModifier) GetRemove() []string {
	if r == nil {
		return nil
	}
	return r.Remove
}

func (r *ResponseHeaderModifier) GetSet() []MeshHTTPRouteItemSpecSet {
	if r == nil {
		return nil
	}
	return r.Set
}

type MeshHTTPRouteItemSpecType string

const (
	MeshHTTPRouteItemSpecTypeRequestHeaderModifier  MeshHTTPRouteItemSpecType = "RequestHeaderModifier"
	MeshHTTPRouteItemSpecTypeResponseHeaderModifier MeshHTTPRouteItemSpecType = "ResponseHeaderModifier"
	MeshHTTPRouteItemSpecTypeRequestRedirect        MeshHTTPRouteItemSpecType = "RequestRedirect"
	MeshHTTPRouteItemSpecTypeURLRewrite             MeshHTTPRouteItemSpecType = "URLRewrite"
	MeshHTTPRouteItemSpecTypeRequestMirror          MeshHTTPRouteItemSpecType = "RequestMirror"
)

func (e MeshHTTPRouteItemSpecType) ToPointer() *MeshHTTPRouteItemSpecType {
	return &e
}
func (e *MeshHTTPRouteItemSpecType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "RequestHeaderModifier":
		fallthrough
	case "ResponseHeaderModifier":
		fallthrough
	case "RequestRedirect":
		fallthrough
	case "URLRewrite":
		fallthrough
	case "RequestMirror":
		*e = MeshHTTPRouteItemSpecType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshHTTPRouteItemSpecType: %v", v)
	}
}

type MeshHTTPRouteItemSpecToRulesDefaultFiltersType string

const (
	MeshHTTPRouteItemSpecToRulesDefaultFiltersTypeReplaceFullPath    MeshHTTPRouteItemSpecToRulesDefaultFiltersType = "ReplaceFullPath"
	MeshHTTPRouteItemSpecToRulesDefaultFiltersTypeReplacePrefixMatch MeshHTTPRouteItemSpecToRulesDefaultFiltersType = "ReplacePrefixMatch"
)

func (e MeshHTTPRouteItemSpecToRulesDefaultFiltersType) ToPointer() *MeshHTTPRouteItemSpecToRulesDefaultFiltersType {
	return &e
}
func (e *MeshHTTPRouteItemSpecToRulesDefaultFiltersType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "ReplaceFullPath":
		fallthrough
	case "ReplacePrefixMatch":
		*e = MeshHTTPRouteItemSpecToRulesDefaultFiltersType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshHTTPRouteItemSpecToRulesDefaultFiltersType: %v", v)
	}
}

// MeshHTTPRouteItemPath - Path defines a path rewrite.
type MeshHTTPRouteItemPath struct {
	ReplaceFullPath    *string                                        `json:"replaceFullPath,omitempty"`
	ReplacePrefixMatch *string                                        `json:"replacePrefixMatch,omitempty"`
	Type               MeshHTTPRouteItemSpecToRulesDefaultFiltersType `json:"type"`
}

func (m *MeshHTTPRouteItemPath) GetReplaceFullPath() *string {
	if m == nil {
		return nil
	}
	return m.ReplaceFullPath
}

func (m *MeshHTTPRouteItemPath) GetReplacePrefixMatch() *string {
	if m == nil {
		return nil
	}
	return m.ReplacePrefixMatch
}

func (m *MeshHTTPRouteItemPath) GetType() MeshHTTPRouteItemSpecToRulesDefaultFiltersType {
	if m == nil {
		return MeshHTTPRouteItemSpecToRulesDefaultFiltersType("")
	}
	return m.Type
}

type URLRewrite struct {
	// HostToBackendHostname rewrites the hostname to the hostname of the
	// upstream host. This option is only available when targeting MeshGateways.
	HostToBackendHostname *bool `json:"hostToBackendHostname,omitempty"`
	// Hostname is the value to be used to replace the host header value during forwarding.
	Hostname *string `json:"hostname,omitempty"`
	// Path defines a path rewrite.
	Path *MeshHTTPRouteItemPath `json:"path,omitempty"`
}

func (u *URLRewrite) GetHostToBackendHostname() *bool {
	if u == nil {
		return nil
	}
	return u.HostToBackendHostname
}

func (u *URLRewrite) GetHostname() *string {
	if u == nil {
		return nil
	}
	return u.Hostname
}

func (u *URLRewrite) GetPath() *MeshHTTPRouteItemPath {
	if u == nil {
		return nil
	}
	return u.Path
}

type Filters struct {
	// Only one action is supported per header name.
	// Configuration to set or add multiple values for a header must use RFC 7230
	// header value formatting, separating each value with a comma.
	RequestHeaderModifier *RequestHeaderModifier `json:"requestHeaderModifier,omitempty"`
	RequestMirror         *RequestMirror         `json:"requestMirror,omitempty"`
	RequestRedirect       *RequestRedirect       `json:"requestRedirect,omitempty"`
	// Only one action is supported per header name.
	// Configuration to set or add multiple values for a header must use RFC 7230
	// header value formatting, separating each value with a comma.
	ResponseHeaderModifier *ResponseHeaderModifier   `json:"responseHeaderModifier,omitempty"`
	Type                   MeshHTTPRouteItemSpecType `json:"type"`
	URLRewrite             *URLRewrite               `json:"urlRewrite,omitempty"`
}

func (f *Filters) GetRequestHeaderModifier() *RequestHeaderModifier {
	if f == nil {
		return nil
	}
	return f.RequestHeaderModifier
}

func (f *Filters) GetRequestMirror() *RequestMirror {
	if f == nil {
		return nil
	}
	return f.RequestMirror
}

func (f *Filters) GetRequestRedirect() *RequestRedirect {
	if f == nil {
		return nil
	}
	return f.RequestRedirect
}

func (f *Filters) GetResponseHeaderModifier() *ResponseHeaderModifier {
	if f == nil {
		return nil
	}
	return f.ResponseHeaderModifier
}

func (f *Filters) GetType() MeshHTTPRouteItemSpecType {
	if f == nil {
		return MeshHTTPRouteItemSpecType("")
	}
	return f.Type
}

func (f *Filters) GetURLRewrite() *URLRewrite {
	if f == nil {
		return nil
	}
	return f.URLRewrite
}

// MeshHTTPRouteItemDefault - Default holds routing rules that can be merged with rules from other
// policies.
type MeshHTTPRouteItemDefault struct {
	BackendRefs []BackendRefs `json:"backendRefs,omitempty"`
	Filters     []Filters     `json:"filters,omitempty"`
}

func (m *MeshHTTPRouteItemDefault) GetBackendRefs() []BackendRefs {
	if m == nil {
		return nil
	}
	return m.BackendRefs
}

func (m *MeshHTTPRouteItemDefault) GetFilters() []Filters {
	if m == nil {
		return nil
	}
	return m.Filters
}

// MeshHTTPRouteItemSpecToType - Type specifies how to match against the value of the header.
type MeshHTTPRouteItemSpecToType string

const (
	MeshHTTPRouteItemSpecToTypeExact             MeshHTTPRouteItemSpecToType = "Exact"
	MeshHTTPRouteItemSpecToTypePresent           MeshHTTPRouteItemSpecToType = "Present"
	MeshHTTPRouteItemSpecToTypeRegularExpression MeshHTTPRouteItemSpecToType = "RegularExpression"
	MeshHTTPRouteItemSpecToTypeAbsent            MeshHTTPRouteItemSpecToType = "Absent"
	MeshHTTPRouteItemSpecToTypePrefix            MeshHTTPRouteItemSpecToType = "Prefix"
)

func (e MeshHTTPRouteItemSpecToType) ToPointer() *MeshHTTPRouteItemSpecToType {
	return &e
}
func (e *MeshHTTPRouteItemSpecToType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Exact":
		fallthrough
	case "Present":
		fallthrough
	case "RegularExpression":
		fallthrough
	case "Absent":
		fallthrough
	case "Prefix":
		*e = MeshHTTPRouteItemSpecToType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshHTTPRouteItemSpecToType: %v", v)
	}
}

// Headers - HeaderMatch describes how to select an HTTP route by matching HTTP request
// headers.
type Headers struct {
	// Name is the name of the HTTP Header to be matched. Name MUST be lower case
	// as they will be handled with case insensitivity (See https://tools.ietf.org/html/rfc7230#section-3.2).
	Name string `json:"name"`
	// Type specifies how to match against the value of the header.
	Type *MeshHTTPRouteItemSpecToType `default:"Exact" json:"type"`
	// Value is the value of HTTP Header to be matched.
	Value *string `json:"value,omitempty"`
}

func (h Headers) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(h, "", false)
}

func (h *Headers) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &h, "", false, []string{"name"}); err != nil {
		return err
	}
	return nil
}

func (h *Headers) GetName() string {
	if h == nil {
		return ""
	}
	return h.Name
}

func (h *Headers) GetType() *MeshHTTPRouteItemSpecToType {
	if h == nil {
		return nil
	}
	return h.Type
}

func (h *Headers) GetValue() *string {
	if h == nil {
		return nil
	}
	return h.Value
}

type Method string

const (
	MethodConnect Method = "CONNECT"
	MethodDelete  Method = "DELETE"
	MethodGet     Method = "GET"
	MethodHead    Method = "HEAD"
	MethodOptions Method = "OPTIONS"
	MethodPatch   Method = "PATCH"
	MethodPost    Method = "POST"
	MethodPut     Method = "PUT"
	MethodTrace   Method = "TRACE"
)

func (e Method) ToPointer() *Method {
	return &e
}
func (e *Method) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "CONNECT":
		fallthrough
	case "DELETE":
		fallthrough
	case "GET":
		fallthrough
	case "HEAD":
		fallthrough
	case "OPTIONS":
		fallthrough
	case "PATCH":
		fallthrough
	case "POST":
		fallthrough
	case "PUT":
		fallthrough
	case "TRACE":
		*e = Method(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Method: %v", v)
	}
}

type MeshHTTPRouteItemSpecToRulesType string

const (
	MeshHTTPRouteItemSpecToRulesTypeExact             MeshHTTPRouteItemSpecToRulesType = "Exact"
	MeshHTTPRouteItemSpecToRulesTypePathPrefix        MeshHTTPRouteItemSpecToRulesType = "PathPrefix"
	MeshHTTPRouteItemSpecToRulesTypeRegularExpression MeshHTTPRouteItemSpecToRulesType = "RegularExpression"
)

func (e MeshHTTPRouteItemSpecToRulesType) ToPointer() *MeshHTTPRouteItemSpecToRulesType {
	return &e
}
func (e *MeshHTTPRouteItemSpecToRulesType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Exact":
		fallthrough
	case "PathPrefix":
		fallthrough
	case "RegularExpression":
		*e = MeshHTTPRouteItemSpecToRulesType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshHTTPRouteItemSpecToRulesType: %v", v)
	}
}

type Path struct {
	Type MeshHTTPRouteItemSpecToRulesType `json:"type"`
	// Exact or prefix matches must be an absolute path. A prefix matches only
	// if separated by a slash or the entire path.
	Value string `json:"value"`
}

func (p *Path) GetType() MeshHTTPRouteItemSpecToRulesType {
	if p == nil {
		return MeshHTTPRouteItemSpecToRulesType("")
	}
	return p.Type
}

func (p *Path) GetValue() string {
	if p == nil {
		return ""
	}
	return p.Value
}

type MeshHTTPRouteItemSpecToRulesMatchesType string

const (
	MeshHTTPRouteItemSpecToRulesMatchesTypeExact             MeshHTTPRouteItemSpecToRulesMatchesType = "Exact"
	MeshHTTPRouteItemSpecToRulesMatchesTypeRegularExpression MeshHTTPRouteItemSpecToRulesMatchesType = "RegularExpression"
)

func (e MeshHTTPRouteItemSpecToRulesMatchesType) ToPointer() *MeshHTTPRouteItemSpecToRulesMatchesType {
	return &e
}
func (e *MeshHTTPRouteItemSpecToRulesMatchesType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Exact":
		fallthrough
	case "RegularExpression":
		*e = MeshHTTPRouteItemSpecToRulesMatchesType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshHTTPRouteItemSpecToRulesMatchesType: %v", v)
	}
}

type QueryParams struct {
	Name  string                                  `json:"name"`
	Type  MeshHTTPRouteItemSpecToRulesMatchesType `json:"type"`
	Value string                                  `json:"value"`
}

func (q *QueryParams) GetName() string {
	if q == nil {
		return ""
	}
	return q.Name
}

func (q *QueryParams) GetType() MeshHTTPRouteItemSpecToRulesMatchesType {
	if q == nil {
		return MeshHTTPRouteItemSpecToRulesMatchesType("")
	}
	return q.Type
}

func (q *QueryParams) GetValue() string {
	if q == nil {
		return ""
	}
	return q.Value
}

type MeshHTTPRouteItemMatches struct {
	Headers []Headers `json:"headers,omitempty"`
	Method  *Method   `json:"method,omitempty"`
	Path    *Path     `json:"path,omitempty"`
	// QueryParams matches based on HTTP URL query parameters. Multiple matches
	// are ANDed together such that all listed matches must succeed.
	QueryParams []QueryParams `json:"queryParams,omitempty"`
}

func (m *MeshHTTPRouteItemMatches) GetHeaders() []Headers {
	if m == nil {
		return nil
	}
	return m.Headers
}

func (m *MeshHTTPRouteItemMatches) GetMethod() *Method {
	if m == nil {
		return nil
	}
	return m.Method
}

func (m *MeshHTTPRouteItemMatches) GetPath() *Path {
	if m == nil {
		return nil
	}
	return m.Path
}

func (m *MeshHTTPRouteItemMatches) GetQueryParams() []QueryParams {
	if m == nil {
		return nil
	}
	return m.QueryParams
}

type MeshHTTPRouteItemRules struct {
	// Default holds routing rules that can be merged with rules from other
	// policies.
	Default MeshHTTPRouteItemDefault `json:"default"`
	// Matches describes how to match HTTP requests this rule should be applied
	// to.
	Matches []MeshHTTPRouteItemMatches `json:"matches"`
}

func (m *MeshHTTPRouteItemRules) GetDefault() MeshHTTPRouteItemDefault {
	if m == nil {
		return MeshHTTPRouteItemDefault{}
	}
	return m.Default
}

func (m *MeshHTTPRouteItemRules) GetMatches() []MeshHTTPRouteItemMatches {
	if m == nil {
		return []MeshHTTPRouteItemMatches{}
	}
	return m.Matches
}

// MeshHTTPRouteItemSpecKind - Kind of the referenced resource
type MeshHTTPRouteItemSpecKind string

const (
	MeshHTTPRouteItemSpecKindMesh                 MeshHTTPRouteItemSpecKind = "Mesh"
	MeshHTTPRouteItemSpecKindMeshSubset           MeshHTTPRouteItemSpecKind = "MeshSubset"
	MeshHTTPRouteItemSpecKindMeshGateway          MeshHTTPRouteItemSpecKind = "MeshGateway"
	MeshHTTPRouteItemSpecKindMeshService          MeshHTTPRouteItemSpecKind = "MeshService"
	MeshHTTPRouteItemSpecKindMeshExternalService  MeshHTTPRouteItemSpecKind = "MeshExternalService"
	MeshHTTPRouteItemSpecKindMeshMultiZoneService MeshHTTPRouteItemSpecKind = "MeshMultiZoneService"
	MeshHTTPRouteItemSpecKindMeshServiceSubset    MeshHTTPRouteItemSpecKind = "MeshServiceSubset"
	MeshHTTPRouteItemSpecKindMeshHTTPRoute        MeshHTTPRouteItemSpecKind = "MeshHTTPRoute"
	MeshHTTPRouteItemSpecKindDataplane            MeshHTTPRouteItemSpecKind = "Dataplane"
)

func (e MeshHTTPRouteItemSpecKind) ToPointer() *MeshHTTPRouteItemSpecKind {
	return &e
}
func (e *MeshHTTPRouteItemSpecKind) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Mesh":
		fallthrough
	case "MeshSubset":
		fallthrough
	case "MeshGateway":
		fallthrough
	case "MeshService":
		fallthrough
	case "MeshExternalService":
		fallthrough
	case "MeshMultiZoneService":
		fallthrough
	case "MeshServiceSubset":
		fallthrough
	case "MeshHTTPRoute":
		fallthrough
	case "Dataplane":
		*e = MeshHTTPRouteItemSpecKind(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshHTTPRouteItemSpecKind: %v", v)
	}
}

type MeshHTTPRouteItemSpecProxyTypes string

const (
	MeshHTTPRouteItemSpecProxyTypesSidecar MeshHTTPRouteItemSpecProxyTypes = "Sidecar"
	MeshHTTPRouteItemSpecProxyTypesGateway MeshHTTPRouteItemSpecProxyTypes = "Gateway"
)

func (e MeshHTTPRouteItemSpecProxyTypes) ToPointer() *MeshHTTPRouteItemSpecProxyTypes {
	return &e
}
func (e *MeshHTTPRouteItemSpecProxyTypes) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Sidecar":
		fallthrough
	case "Gateway":
		*e = MeshHTTPRouteItemSpecProxyTypes(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshHTTPRouteItemSpecProxyTypes: %v", v)
	}
}

// MeshHTTPRouteItemSpecTargetRef - TargetRef is a reference to the resource that represents a group of
// request destinations.
type MeshHTTPRouteItemSpecTargetRef struct {
	// Kind of the referenced resource
	Kind MeshHTTPRouteItemSpecKind `json:"kind"`
	// Labels are used to select group of MeshServices that match labels. Either Labels or
	// Name and Namespace can be used.
	Labels map[string]string `json:"labels,omitempty"`
	// Mesh is reserved for future use to identify cross mesh resources.
	Mesh *string `json:"mesh,omitempty"`
	// Name of the referenced resource. Can only be used with kinds: `MeshService`,
	// `MeshServiceSubset` and `MeshGatewayRoute`
	Name *string `json:"name,omitempty"`
	// Namespace specifies the namespace of target resource. If empty only resources in policy namespace
	// will be targeted.
	Namespace *string `json:"namespace,omitempty"`
	// ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
	// all data plane types are targeted by the policy.
	ProxyTypes []MeshHTTPRouteItemSpecProxyTypes `json:"proxyTypes,omitempty"`
	// SectionName is used to target specific section of resource.
	// For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected.
	SectionName *string `json:"sectionName,omitempty"`
	// Tags used to select a subset of proxies by tags. Can only be used with kinds
	// `MeshSubset` and `MeshServiceSubset`
	Tags map[string]string `json:"tags,omitempty"`
}

func (m *MeshHTTPRouteItemSpecTargetRef) GetKind() MeshHTTPRouteItemSpecKind {
	if m == nil {
		return MeshHTTPRouteItemSpecKind("")
	}
	return m.Kind
}

func (m *MeshHTTPRouteItemSpecTargetRef) GetLabels() map[string]string {
	if m == nil {
		return nil
	}
	return m.Labels
}

func (m *MeshHTTPRouteItemSpecTargetRef) GetMesh() *string {
	if m == nil {
		return nil
	}
	return m.Mesh
}

func (m *MeshHTTPRouteItemSpecTargetRef) GetName() *string {
	if m == nil {
		return nil
	}
	return m.Name
}

func (m *MeshHTTPRouteItemSpecTargetRef) GetNamespace() *string {
	if m == nil {
		return nil
	}
	return m.Namespace
}

func (m *MeshHTTPRouteItemSpecTargetRef) GetProxyTypes() []MeshHTTPRouteItemSpecProxyTypes {
	if m == nil {
		return nil
	}
	return m.ProxyTypes
}

func (m *MeshHTTPRouteItemSpecTargetRef) GetSectionName() *string {
	if m == nil {
		return nil
	}
	return m.SectionName
}

func (m *MeshHTTPRouteItemSpecTargetRef) GetTags() map[string]string {
	if m == nil {
		return nil
	}
	return m.Tags
}

type MeshHTTPRouteItemTo struct {
	// Hostnames is only valid when targeting MeshGateway and limits the
	// effects of the rules to requests to this hostname.
	// Given hostnames must intersect with the hostname of the listeners the
	// route attaches to.
	Hostnames []string `json:"hostnames,omitempty"`
	// Rules contains the routing rules applies to a combination of top-level
	// targetRef and the targetRef in this entry.
	Rules []MeshHTTPRouteItemRules `json:"rules"`
	// TargetRef is a reference to the resource that represents a group of
	// request destinations.
	TargetRef MeshHTTPRouteItemSpecTargetRef `json:"targetRef"`
}

func (m *MeshHTTPRouteItemTo) GetHostnames() []string {
	if m == nil {
		return nil
	}
	return m.Hostnames
}

func (m *MeshHTTPRouteItemTo) GetRules() []MeshHTTPRouteItemRules {
	if m == nil {
		return []MeshHTTPRouteItemRules{}
	}
	return m.Rules
}

func (m *MeshHTTPRouteItemTo) GetTargetRef() MeshHTTPRouteItemSpecTargetRef {
	if m == nil {
		return MeshHTTPRouteItemSpecTargetRef{}
	}
	return m.TargetRef
}

// MeshHTTPRouteItemSpec - Spec is the specification of the Kuma MeshHTTPRoute resource.
type MeshHTTPRouteItemSpec struct {
	// TargetRef is a reference to the resource the policy takes an effect on.
	// The resource could be either a real store object or virtual resource
	// defined inplace.
	TargetRef *MeshHTTPRouteItemTargetRef `json:"targetRef,omitempty"`
	// To matches destination services of requests and holds configuration.
	To []MeshHTTPRouteItemTo `json:"to,omitempty"`
}

func (m *MeshHTTPRouteItemSpec) GetTargetRef() *MeshHTTPRouteItemTargetRef {
	if m == nil {
		return nil
	}
	return m.TargetRef
}

func (m *MeshHTTPRouteItemSpec) GetTo() []MeshHTTPRouteItemTo {
	if m == nil {
		return nil
	}
	return m.To
}

// MeshHTTPRouteItem - Successful response
type MeshHTTPRouteItem struct {
	// the type of the resource
	Type MeshHTTPRouteItemType `json:"type"`
	// Mesh is the name of the Kuma mesh this resource belongs to. It may be omitted for cluster-scoped resources.
	Mesh *string `default:"default" json:"mesh"`
	// Name of the Kuma resource
	Name string `json:"name"`
	// The labels to help identity resources
	Labels map[string]string `json:"labels,omitempty"`
	// Spec is the specification of the Kuma MeshHTTPRoute resource.
	Spec MeshHTTPRouteItemSpec `json:"spec"`
	// Time at which the resource was created
	CreationTime *time.Time `json:"creationTime,omitempty"`
	// Time at which the resource was updated
	ModificationTime *time.Time `json:"modificationTime,omitempty"`
}

func (m MeshHTTPRouteItem) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(m, "", false)
}

func (m *MeshHTTPRouteItem) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &m, "", false, []string{"type", "name", "spec"}); err != nil {
		return err
	}
	return nil
}

func (m *MeshHTTPRouteItem) GetType() MeshHTTPRouteItemType {
	if m == nil {
		return MeshHTTPRouteItemType("")
	}
	return m.Type
}

func (m *MeshHTTPRouteItem) GetMesh() *string {
	if m == nil {
		return nil
	}
	return m.Mesh
}

func (m *MeshHTTPRouteItem) GetName() string {
	if m == nil {
		return ""
	}
	return m.Name
}

func (m *MeshHTTPRouteItem) GetLabels() map[string]string {
	if m == nil {
		return nil
	}
	return m.Labels
}

func (m *MeshHTTPRouteItem) GetSpec() MeshHTTPRouteItemSpec {
	if m == nil {
		return MeshHTTPRouteItemSpec{}
	}
	return m.Spec
}

func (m *MeshHTTPRouteItem) GetCreationTime() *time.Time {
	if m == nil {
		return nil
	}
	return m.CreationTime
}

func (m *MeshHTTPRouteItem) GetModificationTime() *time.Time {
	if m == nil {
		return nil
	}
	return m.ModificationTime
}

type MeshHTTPRouteItemInput struct {
	// the type of the resource
	Type MeshHTTPRouteItemType `json:"type"`
	// Mesh is the name of the Kuma mesh this resource belongs to. It may be omitted for cluster-scoped resources.
	Mesh *string `default:"default" json:"mesh"`
	// Name of the Kuma resource
	Name string `json:"name"`
	// The labels to help identity resources
	Labels map[string]string `json:"labels,omitempty"`
	// Spec is the specification of the Kuma MeshHTTPRoute resource.
	Spec MeshHTTPRouteItemSpec `json:"spec"`
}

func (m MeshHTTPRouteItemInput) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(m, "", false)
}

func (m *MeshHTTPRouteItemInput) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &m, "", false, []string{"type", "name", "spec"}); err != nil {
		return err
	}
	return nil
}

func (m *MeshHTTPRouteItemInput) GetType() MeshHTTPRouteItemType {
	if m == nil {
		return MeshHTTPRouteItemType("")
	}
	return m.Type
}

func (m *MeshHTTPRouteItemInput) GetMesh() *string {
	if m == nil {
		return nil
	}
	return m.Mesh
}

func (m *MeshHTTPRouteItemInput) GetName() string {
	if m == nil {
		return ""
	}
	return m.Name
}

func (m *MeshHTTPRouteItemInput) GetLabels() map[string]string {
	if m == nil {
		return nil
	}
	return m.Labels
}

func (m *MeshHTTPRouteItemInput) GetSpec() MeshHTTPRouteItemSpec {
	if m == nil {
		return MeshHTTPRouteItemSpec{}
	}
	return m.Spec
}
