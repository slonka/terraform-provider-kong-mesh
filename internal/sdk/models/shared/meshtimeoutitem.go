// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
	"github.com/kong/terraform-provider-kong-mesh/internal/sdk/internal/utils"
	"time"
)

// MeshTimeoutItemType - the type of the resource
type MeshTimeoutItemType string

const (
	MeshTimeoutItemTypeMeshTimeout MeshTimeoutItemType = "MeshTimeout"
)

func (e MeshTimeoutItemType) ToPointer() *MeshTimeoutItemType {
	return &e
}
func (e *MeshTimeoutItemType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "MeshTimeout":
		*e = MeshTimeoutItemType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshTimeoutItemType: %v", v)
	}
}

// MeshTimeoutItemHTTP - Http provides configuration for HTTP specific timeouts
type MeshTimeoutItemHTTP struct {
	// MaxConnectionDuration is the time after which a connection will be drained and/or closed,
	// starting from when it was first established. Setting this timeout to 0 will disable it.
	// Disabled by default.
	MaxConnectionDuration *string `json:"maxConnectionDuration,omitempty"`
	// MaxStreamDuration is the maximum time that a stream’s lifetime will span.
	// Setting this timeout to 0 will disable it. Disabled by default.
	MaxStreamDuration *string `json:"maxStreamDuration,omitempty"`
	// RequestHeadersTimeout The amount of time that proxy will wait for the request headers to be received. The timer is
	// activated when the first byte of the headers is received, and is disarmed when the last byte of
	// the headers has been received. If not specified or set to 0, this timeout is disabled.
	// Disabled by default.
	RequestHeadersTimeout *string `json:"requestHeadersTimeout,omitempty"`
	// RequestTimeout The amount of time that proxy will wait for the entire request to be received.
	// The timer is activated when the request is initiated, and is disarmed when the last byte of the request is sent,
	// OR when the response is initiated. Setting this timeout to 0 will disable it.
	// Default is 15s.
	RequestTimeout *string `json:"requestTimeout,omitempty"`
	// StreamIdleTimeout is the amount of time that proxy will allow a stream to exist with no activity.
	// Setting this timeout to 0 will disable it. Default is 30m
	StreamIdleTimeout *string `json:"streamIdleTimeout,omitempty"`
}

func (m *MeshTimeoutItemHTTP) GetMaxConnectionDuration() *string {
	if m == nil {
		return nil
	}
	return m.MaxConnectionDuration
}

func (m *MeshTimeoutItemHTTP) GetMaxStreamDuration() *string {
	if m == nil {
		return nil
	}
	return m.MaxStreamDuration
}

func (m *MeshTimeoutItemHTTP) GetRequestHeadersTimeout() *string {
	if m == nil {
		return nil
	}
	return m.RequestHeadersTimeout
}

func (m *MeshTimeoutItemHTTP) GetRequestTimeout() *string {
	if m == nil {
		return nil
	}
	return m.RequestTimeout
}

func (m *MeshTimeoutItemHTTP) GetStreamIdleTimeout() *string {
	if m == nil {
		return nil
	}
	return m.StreamIdleTimeout
}

// MeshTimeoutItemDefault - Default is a configuration specific to the group of clients referenced in
// 'targetRef'
type MeshTimeoutItemDefault struct {
	// ConnectionTimeout specifies the amount of time proxy will wait for an TCP connection to be established.
	// Default value is 5 seconds. Cannot be set to 0.
	ConnectionTimeout *string `json:"connectionTimeout,omitempty"`
	// Http provides configuration for HTTP specific timeouts
	HTTP *MeshTimeoutItemHTTP `json:"http,omitempty"`
	// IdleTimeout is defined as the period in which there are no bytes sent or received on connection
	// Setting this timeout to 0 will disable it. Be cautious when disabling it because
	// it can lead to connection leaking. Default value is 1h.
	IdleTimeout *string `json:"idleTimeout,omitempty"`
}

func (m *MeshTimeoutItemDefault) GetConnectionTimeout() *string {
	if m == nil {
		return nil
	}
	return m.ConnectionTimeout
}

func (m *MeshTimeoutItemDefault) GetHTTP() *MeshTimeoutItemHTTP {
	if m == nil {
		return nil
	}
	return m.HTTP
}

func (m *MeshTimeoutItemDefault) GetIdleTimeout() *string {
	if m == nil {
		return nil
	}
	return m.IdleTimeout
}

// MeshTimeoutItemSpecKind - Kind of the referenced resource
type MeshTimeoutItemSpecKind string

const (
	MeshTimeoutItemSpecKindMesh                 MeshTimeoutItemSpecKind = "Mesh"
	MeshTimeoutItemSpecKindMeshSubset           MeshTimeoutItemSpecKind = "MeshSubset"
	MeshTimeoutItemSpecKindMeshGateway          MeshTimeoutItemSpecKind = "MeshGateway"
	MeshTimeoutItemSpecKindMeshService          MeshTimeoutItemSpecKind = "MeshService"
	MeshTimeoutItemSpecKindMeshExternalService  MeshTimeoutItemSpecKind = "MeshExternalService"
	MeshTimeoutItemSpecKindMeshMultiZoneService MeshTimeoutItemSpecKind = "MeshMultiZoneService"
	MeshTimeoutItemSpecKindMeshServiceSubset    MeshTimeoutItemSpecKind = "MeshServiceSubset"
	MeshTimeoutItemSpecKindMeshHTTPRoute        MeshTimeoutItemSpecKind = "MeshHTTPRoute"
	MeshTimeoutItemSpecKindDataplane            MeshTimeoutItemSpecKind = "Dataplane"
)

func (e MeshTimeoutItemSpecKind) ToPointer() *MeshTimeoutItemSpecKind {
	return &e
}
func (e *MeshTimeoutItemSpecKind) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Mesh":
		fallthrough
	case "MeshSubset":
		fallthrough
	case "MeshGateway":
		fallthrough
	case "MeshService":
		fallthrough
	case "MeshExternalService":
		fallthrough
	case "MeshMultiZoneService":
		fallthrough
	case "MeshServiceSubset":
		fallthrough
	case "MeshHTTPRoute":
		fallthrough
	case "Dataplane":
		*e = MeshTimeoutItemSpecKind(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshTimeoutItemSpecKind: %v", v)
	}
}

type MeshTimeoutItemSpecProxyTypes string

const (
	MeshTimeoutItemSpecProxyTypesSidecar MeshTimeoutItemSpecProxyTypes = "Sidecar"
	MeshTimeoutItemSpecProxyTypesGateway MeshTimeoutItemSpecProxyTypes = "Gateway"
)

func (e MeshTimeoutItemSpecProxyTypes) ToPointer() *MeshTimeoutItemSpecProxyTypes {
	return &e
}
func (e *MeshTimeoutItemSpecProxyTypes) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Sidecar":
		fallthrough
	case "Gateway":
		*e = MeshTimeoutItemSpecProxyTypes(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshTimeoutItemSpecProxyTypes: %v", v)
	}
}

// MeshTimeoutItemSpecTargetRef - TargetRef is a reference to the resource that represents a group of
// clients.
type MeshTimeoutItemSpecTargetRef struct {
	// Kind of the referenced resource
	Kind MeshTimeoutItemSpecKind `json:"kind"`
	// Labels are used to select group of MeshServices that match labels. Either Labels or
	// Name and Namespace can be used.
	Labels map[string]string `json:"labels,omitempty"`
	// Mesh is reserved for future use to identify cross mesh resources.
	Mesh *string `json:"mesh,omitempty"`
	// Name of the referenced resource. Can only be used with kinds: `MeshService`,
	// `MeshServiceSubset` and `MeshGatewayRoute`
	Name *string `json:"name,omitempty"`
	// Namespace specifies the namespace of target resource. If empty only resources in policy namespace
	// will be targeted.
	Namespace *string `json:"namespace,omitempty"`
	// ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
	// all data plane types are targeted by the policy.
	ProxyTypes []MeshTimeoutItemSpecProxyTypes `json:"proxyTypes,omitempty"`
	// SectionName is used to target specific section of resource.
	// For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected.
	SectionName *string `json:"sectionName,omitempty"`
	// Tags used to select a subset of proxies by tags. Can only be used with kinds
	// `MeshSubset` and `MeshServiceSubset`
	Tags map[string]string `json:"tags,omitempty"`
}

func (m *MeshTimeoutItemSpecTargetRef) GetKind() MeshTimeoutItemSpecKind {
	if m == nil {
		return MeshTimeoutItemSpecKind("")
	}
	return m.Kind
}

func (m *MeshTimeoutItemSpecTargetRef) GetLabels() map[string]string {
	if m == nil {
		return nil
	}
	return m.Labels
}

func (m *MeshTimeoutItemSpecTargetRef) GetMesh() *string {
	if m == nil {
		return nil
	}
	return m.Mesh
}

func (m *MeshTimeoutItemSpecTargetRef) GetName() *string {
	if m == nil {
		return nil
	}
	return m.Name
}

func (m *MeshTimeoutItemSpecTargetRef) GetNamespace() *string {
	if m == nil {
		return nil
	}
	return m.Namespace
}

func (m *MeshTimeoutItemSpecTargetRef) GetProxyTypes() []MeshTimeoutItemSpecProxyTypes {
	if m == nil {
		return nil
	}
	return m.ProxyTypes
}

func (m *MeshTimeoutItemSpecTargetRef) GetSectionName() *string {
	if m == nil {
		return nil
	}
	return m.SectionName
}

func (m *MeshTimeoutItemSpecTargetRef) GetTags() map[string]string {
	if m == nil {
		return nil
	}
	return m.Tags
}

type MeshTimeoutItemFrom struct {
	// Default is a configuration specific to the group of clients referenced in
	// 'targetRef'
	Default *MeshTimeoutItemDefault `json:"default,omitempty"`
	// TargetRef is a reference to the resource that represents a group of
	// clients.
	TargetRef MeshTimeoutItemSpecTargetRef `json:"targetRef"`
}

func (m *MeshTimeoutItemFrom) GetDefault() *MeshTimeoutItemDefault {
	if m == nil {
		return nil
	}
	return m.Default
}

func (m *MeshTimeoutItemFrom) GetTargetRef() MeshTimeoutItemSpecTargetRef {
	if m == nil {
		return MeshTimeoutItemSpecTargetRef{}
	}
	return m.TargetRef
}

// MeshTimeoutItemSpecHTTP - Http provides configuration for HTTP specific timeouts
type MeshTimeoutItemSpecHTTP struct {
	// MaxConnectionDuration is the time after which a connection will be drained and/or closed,
	// starting from when it was first established. Setting this timeout to 0 will disable it.
	// Disabled by default.
	MaxConnectionDuration *string `json:"maxConnectionDuration,omitempty"`
	// MaxStreamDuration is the maximum time that a stream’s lifetime will span.
	// Setting this timeout to 0 will disable it. Disabled by default.
	MaxStreamDuration *string `json:"maxStreamDuration,omitempty"`
	// RequestHeadersTimeout The amount of time that proxy will wait for the request headers to be received. The timer is
	// activated when the first byte of the headers is received, and is disarmed when the last byte of
	// the headers has been received. If not specified or set to 0, this timeout is disabled.
	// Disabled by default.
	RequestHeadersTimeout *string `json:"requestHeadersTimeout,omitempty"`
	// RequestTimeout The amount of time that proxy will wait for the entire request to be received.
	// The timer is activated when the request is initiated, and is disarmed when the last byte of the request is sent,
	// OR when the response is initiated. Setting this timeout to 0 will disable it.
	// Default is 15s.
	RequestTimeout *string `json:"requestTimeout,omitempty"`
	// StreamIdleTimeout is the amount of time that proxy will allow a stream to exist with no activity.
	// Setting this timeout to 0 will disable it. Default is 30m
	StreamIdleTimeout *string `json:"streamIdleTimeout,omitempty"`
}

func (m *MeshTimeoutItemSpecHTTP) GetMaxConnectionDuration() *string {
	if m == nil {
		return nil
	}
	return m.MaxConnectionDuration
}

func (m *MeshTimeoutItemSpecHTTP) GetMaxStreamDuration() *string {
	if m == nil {
		return nil
	}
	return m.MaxStreamDuration
}

func (m *MeshTimeoutItemSpecHTTP) GetRequestHeadersTimeout() *string {
	if m == nil {
		return nil
	}
	return m.RequestHeadersTimeout
}

func (m *MeshTimeoutItemSpecHTTP) GetRequestTimeout() *string {
	if m == nil {
		return nil
	}
	return m.RequestTimeout
}

func (m *MeshTimeoutItemSpecHTTP) GetStreamIdleTimeout() *string {
	if m == nil {
		return nil
	}
	return m.StreamIdleTimeout
}

// MeshTimeoutItemSpecDefault - Default contains configuration of the inbound timeouts
type MeshTimeoutItemSpecDefault struct {
	// ConnectionTimeout specifies the amount of time proxy will wait for an TCP connection to be established.
	// Default value is 5 seconds. Cannot be set to 0.
	ConnectionTimeout *string `json:"connectionTimeout,omitempty"`
	// Http provides configuration for HTTP specific timeouts
	HTTP *MeshTimeoutItemSpecHTTP `json:"http,omitempty"`
	// IdleTimeout is defined as the period in which there are no bytes sent or received on connection
	// Setting this timeout to 0 will disable it. Be cautious when disabling it because
	// it can lead to connection leaking. Default value is 1h.
	IdleTimeout *string `json:"idleTimeout,omitempty"`
}

func (m *MeshTimeoutItemSpecDefault) GetConnectionTimeout() *string {
	if m == nil {
		return nil
	}
	return m.ConnectionTimeout
}

func (m *MeshTimeoutItemSpecDefault) GetHTTP() *MeshTimeoutItemSpecHTTP {
	if m == nil {
		return nil
	}
	return m.HTTP
}

func (m *MeshTimeoutItemSpecDefault) GetIdleTimeout() *string {
	if m == nil {
		return nil
	}
	return m.IdleTimeout
}

type MeshTimeoutItemRules struct {
	// Default contains configuration of the inbound timeouts
	Default *MeshTimeoutItemSpecDefault `json:"default,omitempty"`
}

func (m *MeshTimeoutItemRules) GetDefault() *MeshTimeoutItemSpecDefault {
	if m == nil {
		return nil
	}
	return m.Default
}

// MeshTimeoutItemKind - Kind of the referenced resource
type MeshTimeoutItemKind string

const (
	MeshTimeoutItemKindMesh                 MeshTimeoutItemKind = "Mesh"
	MeshTimeoutItemKindMeshSubset           MeshTimeoutItemKind = "MeshSubset"
	MeshTimeoutItemKindMeshGateway          MeshTimeoutItemKind = "MeshGateway"
	MeshTimeoutItemKindMeshService          MeshTimeoutItemKind = "MeshService"
	MeshTimeoutItemKindMeshExternalService  MeshTimeoutItemKind = "MeshExternalService"
	MeshTimeoutItemKindMeshMultiZoneService MeshTimeoutItemKind = "MeshMultiZoneService"
	MeshTimeoutItemKindMeshServiceSubset    MeshTimeoutItemKind = "MeshServiceSubset"
	MeshTimeoutItemKindMeshHTTPRoute        MeshTimeoutItemKind = "MeshHTTPRoute"
	MeshTimeoutItemKindDataplane            MeshTimeoutItemKind = "Dataplane"
)

func (e MeshTimeoutItemKind) ToPointer() *MeshTimeoutItemKind {
	return &e
}
func (e *MeshTimeoutItemKind) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Mesh":
		fallthrough
	case "MeshSubset":
		fallthrough
	case "MeshGateway":
		fallthrough
	case "MeshService":
		fallthrough
	case "MeshExternalService":
		fallthrough
	case "MeshMultiZoneService":
		fallthrough
	case "MeshServiceSubset":
		fallthrough
	case "MeshHTTPRoute":
		fallthrough
	case "Dataplane":
		*e = MeshTimeoutItemKind(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshTimeoutItemKind: %v", v)
	}
}

type MeshTimeoutItemProxyTypes string

const (
	MeshTimeoutItemProxyTypesSidecar MeshTimeoutItemProxyTypes = "Sidecar"
	MeshTimeoutItemProxyTypesGateway MeshTimeoutItemProxyTypes = "Gateway"
)

func (e MeshTimeoutItemProxyTypes) ToPointer() *MeshTimeoutItemProxyTypes {
	return &e
}
func (e *MeshTimeoutItemProxyTypes) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Sidecar":
		fallthrough
	case "Gateway":
		*e = MeshTimeoutItemProxyTypes(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshTimeoutItemProxyTypes: %v", v)
	}
}

// MeshTimeoutItemTargetRef - TargetRef is a reference to the resource the policy takes an effect on.
// The resource could be either a real store object or virtual resource
// defined inplace.
type MeshTimeoutItemTargetRef struct {
	// Kind of the referenced resource
	Kind MeshTimeoutItemKind `json:"kind"`
	// Labels are used to select group of MeshServices that match labels. Either Labels or
	// Name and Namespace can be used.
	Labels map[string]string `json:"labels,omitempty"`
	// Mesh is reserved for future use to identify cross mesh resources.
	Mesh *string `json:"mesh,omitempty"`
	// Name of the referenced resource. Can only be used with kinds: `MeshService`,
	// `MeshServiceSubset` and `MeshGatewayRoute`
	Name *string `json:"name,omitempty"`
	// Namespace specifies the namespace of target resource. If empty only resources in policy namespace
	// will be targeted.
	Namespace *string `json:"namespace,omitempty"`
	// ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
	// all data plane types are targeted by the policy.
	ProxyTypes []MeshTimeoutItemProxyTypes `json:"proxyTypes,omitempty"`
	// SectionName is used to target specific section of resource.
	// For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected.
	SectionName *string `json:"sectionName,omitempty"`
	// Tags used to select a subset of proxies by tags. Can only be used with kinds
	// `MeshSubset` and `MeshServiceSubset`
	Tags map[string]string `json:"tags,omitempty"`
}

func (m *MeshTimeoutItemTargetRef) GetKind() MeshTimeoutItemKind {
	if m == nil {
		return MeshTimeoutItemKind("")
	}
	return m.Kind
}

func (m *MeshTimeoutItemTargetRef) GetLabels() map[string]string {
	if m == nil {
		return nil
	}
	return m.Labels
}

func (m *MeshTimeoutItemTargetRef) GetMesh() *string {
	if m == nil {
		return nil
	}
	return m.Mesh
}

func (m *MeshTimeoutItemTargetRef) GetName() *string {
	if m == nil {
		return nil
	}
	return m.Name
}

func (m *MeshTimeoutItemTargetRef) GetNamespace() *string {
	if m == nil {
		return nil
	}
	return m.Namespace
}

func (m *MeshTimeoutItemTargetRef) GetProxyTypes() []MeshTimeoutItemProxyTypes {
	if m == nil {
		return nil
	}
	return m.ProxyTypes
}

func (m *MeshTimeoutItemTargetRef) GetSectionName() *string {
	if m == nil {
		return nil
	}
	return m.SectionName
}

func (m *MeshTimeoutItemTargetRef) GetTags() map[string]string {
	if m == nil {
		return nil
	}
	return m.Tags
}

// MeshTimeoutItemSpecToHTTP - Http provides configuration for HTTP specific timeouts
type MeshTimeoutItemSpecToHTTP struct {
	// MaxConnectionDuration is the time after which a connection will be drained and/or closed,
	// starting from when it was first established. Setting this timeout to 0 will disable it.
	// Disabled by default.
	MaxConnectionDuration *string `json:"maxConnectionDuration,omitempty"`
	// MaxStreamDuration is the maximum time that a stream’s lifetime will span.
	// Setting this timeout to 0 will disable it. Disabled by default.
	MaxStreamDuration *string `json:"maxStreamDuration,omitempty"`
	// RequestHeadersTimeout The amount of time that proxy will wait for the request headers to be received. The timer is
	// activated when the first byte of the headers is received, and is disarmed when the last byte of
	// the headers has been received. If not specified or set to 0, this timeout is disabled.
	// Disabled by default.
	RequestHeadersTimeout *string `json:"requestHeadersTimeout,omitempty"`
	// RequestTimeout The amount of time that proxy will wait for the entire request to be received.
	// The timer is activated when the request is initiated, and is disarmed when the last byte of the request is sent,
	// OR when the response is initiated. Setting this timeout to 0 will disable it.
	// Default is 15s.
	RequestTimeout *string `json:"requestTimeout,omitempty"`
	// StreamIdleTimeout is the amount of time that proxy will allow a stream to exist with no activity.
	// Setting this timeout to 0 will disable it. Default is 30m
	StreamIdleTimeout *string `json:"streamIdleTimeout,omitempty"`
}

func (m *MeshTimeoutItemSpecToHTTP) GetMaxConnectionDuration() *string {
	if m == nil {
		return nil
	}
	return m.MaxConnectionDuration
}

func (m *MeshTimeoutItemSpecToHTTP) GetMaxStreamDuration() *string {
	if m == nil {
		return nil
	}
	return m.MaxStreamDuration
}

func (m *MeshTimeoutItemSpecToHTTP) GetRequestHeadersTimeout() *string {
	if m == nil {
		return nil
	}
	return m.RequestHeadersTimeout
}

func (m *MeshTimeoutItemSpecToHTTP) GetRequestTimeout() *string {
	if m == nil {
		return nil
	}
	return m.RequestTimeout
}

func (m *MeshTimeoutItemSpecToHTTP) GetStreamIdleTimeout() *string {
	if m == nil {
		return nil
	}
	return m.StreamIdleTimeout
}

// MeshTimeoutItemSpecToDefault - Default is a configuration specific to the group of destinations referenced in
// 'targetRef'
type MeshTimeoutItemSpecToDefault struct {
	// ConnectionTimeout specifies the amount of time proxy will wait for an TCP connection to be established.
	// Default value is 5 seconds. Cannot be set to 0.
	ConnectionTimeout *string `json:"connectionTimeout,omitempty"`
	// Http provides configuration for HTTP specific timeouts
	HTTP *MeshTimeoutItemSpecToHTTP `json:"http,omitempty"`
	// IdleTimeout is defined as the period in which there are no bytes sent or received on connection
	// Setting this timeout to 0 will disable it. Be cautious when disabling it because
	// it can lead to connection leaking. Default value is 1h.
	IdleTimeout *string `json:"idleTimeout,omitempty"`
}

func (m *MeshTimeoutItemSpecToDefault) GetConnectionTimeout() *string {
	if m == nil {
		return nil
	}
	return m.ConnectionTimeout
}

func (m *MeshTimeoutItemSpecToDefault) GetHTTP() *MeshTimeoutItemSpecToHTTP {
	if m == nil {
		return nil
	}
	return m.HTTP
}

func (m *MeshTimeoutItemSpecToDefault) GetIdleTimeout() *string {
	if m == nil {
		return nil
	}
	return m.IdleTimeout
}

// MeshTimeoutItemSpecToKind - Kind of the referenced resource
type MeshTimeoutItemSpecToKind string

const (
	MeshTimeoutItemSpecToKindMesh                 MeshTimeoutItemSpecToKind = "Mesh"
	MeshTimeoutItemSpecToKindMeshSubset           MeshTimeoutItemSpecToKind = "MeshSubset"
	MeshTimeoutItemSpecToKindMeshGateway          MeshTimeoutItemSpecToKind = "MeshGateway"
	MeshTimeoutItemSpecToKindMeshService          MeshTimeoutItemSpecToKind = "MeshService"
	MeshTimeoutItemSpecToKindMeshExternalService  MeshTimeoutItemSpecToKind = "MeshExternalService"
	MeshTimeoutItemSpecToKindMeshMultiZoneService MeshTimeoutItemSpecToKind = "MeshMultiZoneService"
	MeshTimeoutItemSpecToKindMeshServiceSubset    MeshTimeoutItemSpecToKind = "MeshServiceSubset"
	MeshTimeoutItemSpecToKindMeshHTTPRoute        MeshTimeoutItemSpecToKind = "MeshHTTPRoute"
	MeshTimeoutItemSpecToKindDataplane            MeshTimeoutItemSpecToKind = "Dataplane"
)

func (e MeshTimeoutItemSpecToKind) ToPointer() *MeshTimeoutItemSpecToKind {
	return &e
}
func (e *MeshTimeoutItemSpecToKind) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Mesh":
		fallthrough
	case "MeshSubset":
		fallthrough
	case "MeshGateway":
		fallthrough
	case "MeshService":
		fallthrough
	case "MeshExternalService":
		fallthrough
	case "MeshMultiZoneService":
		fallthrough
	case "MeshServiceSubset":
		fallthrough
	case "MeshHTTPRoute":
		fallthrough
	case "Dataplane":
		*e = MeshTimeoutItemSpecToKind(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshTimeoutItemSpecToKind: %v", v)
	}
}

type MeshTimeoutItemSpecToProxyTypes string

const (
	MeshTimeoutItemSpecToProxyTypesSidecar MeshTimeoutItemSpecToProxyTypes = "Sidecar"
	MeshTimeoutItemSpecToProxyTypesGateway MeshTimeoutItemSpecToProxyTypes = "Gateway"
)

func (e MeshTimeoutItemSpecToProxyTypes) ToPointer() *MeshTimeoutItemSpecToProxyTypes {
	return &e
}
func (e *MeshTimeoutItemSpecToProxyTypes) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Sidecar":
		fallthrough
	case "Gateway":
		*e = MeshTimeoutItemSpecToProxyTypes(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshTimeoutItemSpecToProxyTypes: %v", v)
	}
}

// MeshTimeoutItemSpecToTargetRef - TargetRef is a reference to the resource that represents a group of
// destinations.
type MeshTimeoutItemSpecToTargetRef struct {
	// Kind of the referenced resource
	Kind MeshTimeoutItemSpecToKind `json:"kind"`
	// Labels are used to select group of MeshServices that match labels. Either Labels or
	// Name and Namespace can be used.
	Labels map[string]string `json:"labels,omitempty"`
	// Mesh is reserved for future use to identify cross mesh resources.
	Mesh *string `json:"mesh,omitempty"`
	// Name of the referenced resource. Can only be used with kinds: `MeshService`,
	// `MeshServiceSubset` and `MeshGatewayRoute`
	Name *string `json:"name,omitempty"`
	// Namespace specifies the namespace of target resource. If empty only resources in policy namespace
	// will be targeted.
	Namespace *string `json:"namespace,omitempty"`
	// ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
	// all data plane types are targeted by the policy.
	ProxyTypes []MeshTimeoutItemSpecToProxyTypes `json:"proxyTypes,omitempty"`
	// SectionName is used to target specific section of resource.
	// For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected.
	SectionName *string `json:"sectionName,omitempty"`
	// Tags used to select a subset of proxies by tags. Can only be used with kinds
	// `MeshSubset` and `MeshServiceSubset`
	Tags map[string]string `json:"tags,omitempty"`
}

func (m *MeshTimeoutItemSpecToTargetRef) GetKind() MeshTimeoutItemSpecToKind {
	if m == nil {
		return MeshTimeoutItemSpecToKind("")
	}
	return m.Kind
}

func (m *MeshTimeoutItemSpecToTargetRef) GetLabels() map[string]string {
	if m == nil {
		return nil
	}
	return m.Labels
}

func (m *MeshTimeoutItemSpecToTargetRef) GetMesh() *string {
	if m == nil {
		return nil
	}
	return m.Mesh
}

func (m *MeshTimeoutItemSpecToTargetRef) GetName() *string {
	if m == nil {
		return nil
	}
	return m.Name
}

func (m *MeshTimeoutItemSpecToTargetRef) GetNamespace() *string {
	if m == nil {
		return nil
	}
	return m.Namespace
}

func (m *MeshTimeoutItemSpecToTargetRef) GetProxyTypes() []MeshTimeoutItemSpecToProxyTypes {
	if m == nil {
		return nil
	}
	return m.ProxyTypes
}

func (m *MeshTimeoutItemSpecToTargetRef) GetSectionName() *string {
	if m == nil {
		return nil
	}
	return m.SectionName
}

func (m *MeshTimeoutItemSpecToTargetRef) GetTags() map[string]string {
	if m == nil {
		return nil
	}
	return m.Tags
}

type MeshTimeoutItemTo struct {
	// Default is a configuration specific to the group of destinations referenced in
	// 'targetRef'
	Default *MeshTimeoutItemSpecToDefault `json:"default,omitempty"`
	// TargetRef is a reference to the resource that represents a group of
	// destinations.
	TargetRef MeshTimeoutItemSpecToTargetRef `json:"targetRef"`
}

func (m *MeshTimeoutItemTo) GetDefault() *MeshTimeoutItemSpecToDefault {
	if m == nil {
		return nil
	}
	return m.Default
}

func (m *MeshTimeoutItemTo) GetTargetRef() MeshTimeoutItemSpecToTargetRef {
	if m == nil {
		return MeshTimeoutItemSpecToTargetRef{}
	}
	return m.TargetRef
}

// MeshTimeoutItemSpec - Spec is the specification of the Kuma MeshTimeout resource.
type MeshTimeoutItemSpec struct {
	// From list makes a match between clients and corresponding configurations
	From []MeshTimeoutItemFrom `json:"from,omitempty"`
	// Rules defines inbound timeout configurations. Currently limited to exactly one rule containing
	// default timeouts that apply to all inbound traffic, as L7 matching is not yet implemented.
	Rules []MeshTimeoutItemRules `json:"rules,omitempty"`
	// TargetRef is a reference to the resource the policy takes an effect on.
	// The resource could be either a real store object or virtual resource
	// defined inplace.
	TargetRef *MeshTimeoutItemTargetRef `json:"targetRef,omitempty"`
	// To list makes a match between the consumed services and corresponding configurations
	To []MeshTimeoutItemTo `json:"to,omitempty"`
}

func (m *MeshTimeoutItemSpec) GetFrom() []MeshTimeoutItemFrom {
	if m == nil {
		return nil
	}
	return m.From
}

func (m *MeshTimeoutItemSpec) GetRules() []MeshTimeoutItemRules {
	if m == nil {
		return nil
	}
	return m.Rules
}

func (m *MeshTimeoutItemSpec) GetTargetRef() *MeshTimeoutItemTargetRef {
	if m == nil {
		return nil
	}
	return m.TargetRef
}

func (m *MeshTimeoutItemSpec) GetTo() []MeshTimeoutItemTo {
	if m == nil {
		return nil
	}
	return m.To
}

// MeshTimeoutItem - Successful response
type MeshTimeoutItem struct {
	// the type of the resource
	Type MeshTimeoutItemType `json:"type"`
	// Mesh is the name of the Kuma mesh this resource belongs to. It may be omitted for cluster-scoped resources.
	Mesh *string `default:"default" json:"mesh"`
	// Name of the Kuma resource
	Name string `json:"name"`
	// The labels to help identity resources
	Labels map[string]string `json:"labels,omitempty"`
	// Spec is the specification of the Kuma MeshTimeout resource.
	Spec MeshTimeoutItemSpec `json:"spec"`
	// Time at which the resource was created
	CreationTime *time.Time `json:"creationTime,omitempty"`
	// Time at which the resource was updated
	ModificationTime *time.Time `json:"modificationTime,omitempty"`
}

func (m MeshTimeoutItem) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(m, "", false)
}

func (m *MeshTimeoutItem) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &m, "", false, []string{"type", "name", "spec"}); err != nil {
		return err
	}
	return nil
}

func (m *MeshTimeoutItem) GetType() MeshTimeoutItemType {
	if m == nil {
		return MeshTimeoutItemType("")
	}
	return m.Type
}

func (m *MeshTimeoutItem) GetMesh() *string {
	if m == nil {
		return nil
	}
	return m.Mesh
}

func (m *MeshTimeoutItem) GetName() string {
	if m == nil {
		return ""
	}
	return m.Name
}

func (m *MeshTimeoutItem) GetLabels() map[string]string {
	if m == nil {
		return nil
	}
	return m.Labels
}

func (m *MeshTimeoutItem) GetSpec() MeshTimeoutItemSpec {
	if m == nil {
		return MeshTimeoutItemSpec{}
	}
	return m.Spec
}

func (m *MeshTimeoutItem) GetCreationTime() *time.Time {
	if m == nil {
		return nil
	}
	return m.CreationTime
}

func (m *MeshTimeoutItem) GetModificationTime() *time.Time {
	if m == nil {
		return nil
	}
	return m.ModificationTime
}

type MeshTimeoutItemInput struct {
	// the type of the resource
	Type MeshTimeoutItemType `json:"type"`
	// Mesh is the name of the Kuma mesh this resource belongs to. It may be omitted for cluster-scoped resources.
	Mesh *string `default:"default" json:"mesh"`
	// Name of the Kuma resource
	Name string `json:"name"`
	// The labels to help identity resources
	Labels map[string]string `json:"labels,omitempty"`
	// Spec is the specification of the Kuma MeshTimeout resource.
	Spec MeshTimeoutItemSpec `json:"spec"`
}

func (m MeshTimeoutItemInput) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(m, "", false)
}

func (m *MeshTimeoutItemInput) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &m, "", false, []string{"type", "name", "spec"}); err != nil {
		return err
	}
	return nil
}

func (m *MeshTimeoutItemInput) GetType() MeshTimeoutItemType {
	if m == nil {
		return MeshTimeoutItemType("")
	}
	return m.Type
}

func (m *MeshTimeoutItemInput) GetMesh() *string {
	if m == nil {
		return nil
	}
	return m.Mesh
}

func (m *MeshTimeoutItemInput) GetName() string {
	if m == nil {
		return ""
	}
	return m.Name
}

func (m *MeshTimeoutItemInput) GetLabels() map[string]string {
	if m == nil {
		return nil
	}
	return m.Labels
}

func (m *MeshTimeoutItemInput) GetSpec() MeshTimeoutItemSpec {
	if m == nil {
		return MeshTimeoutItemSpec{}
	}
	return m.Spec
}
