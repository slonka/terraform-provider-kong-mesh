// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
	"github.com/kong/terraform-provider-kong-mesh/internal/sdk/internal/utils"
	"time"
)

// MeshGlobalRateLimitItemType - the type of the resource
type MeshGlobalRateLimitItemType string

const (
	MeshGlobalRateLimitItemTypeMeshGlobalRateLimit MeshGlobalRateLimitItemType = "MeshGlobalRateLimit"
)

func (e MeshGlobalRateLimitItemType) ToPointer() *MeshGlobalRateLimitItemType {
	return &e
}
func (e *MeshGlobalRateLimitItemType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "MeshGlobalRateLimit":
		*e = MeshGlobalRateLimitItemType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshGlobalRateLimitItemType: %v", v)
	}
}

type RateLimitService struct {
	// LimitOnServiceFail will pass limit requests if ratelimit service is not reachable.
	LimitOnServiceFail *bool `json:"limitOnServiceFail,omitempty"`
	// Timeout for rate limit request made form Data Plane Proxy to rate limit service.
	Timeout *string `json:"timeout,omitempty"`
	// Url defines address of rate limit service.
	URL *string `json:"url,omitempty"`
}

func (r *RateLimitService) GetLimitOnServiceFail() *bool {
	if r == nil {
		return nil
	}
	return r.LimitOnServiceFail
}

func (r *RateLimitService) GetTimeout() *string {
	if r == nil {
		return nil
	}
	return r.Timeout
}

func (r *RateLimitService) GetURL() *string {
	if r == nil {
		return nil
	}
	return r.URL
}

// Backend defines location of rate limit backend service.
type Backend struct {
	RateLimitService RateLimitService `json:"rateLimitService"`
}

func (b *Backend) GetRateLimitService() RateLimitService {
	if b == nil {
		return RateLimitService{}
	}
	return b.RateLimitService
}

type MeshGlobalRateLimitItemAdd struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

func (m *MeshGlobalRateLimitItemAdd) GetName() string {
	if m == nil {
		return ""
	}
	return m.Name
}

func (m *MeshGlobalRateLimitItemAdd) GetValue() string {
	if m == nil {
		return ""
	}
	return m.Value
}

type MeshGlobalRateLimitItemSet struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

func (m *MeshGlobalRateLimitItemSet) GetName() string {
	if m == nil {
		return ""
	}
	return m.Name
}

func (m *MeshGlobalRateLimitItemSet) GetValue() string {
	if m == nil {
		return ""
	}
	return m.Value
}

// MeshGlobalRateLimitItemHeaders - The Headers to be added to the HTTP response on a rate limit event
type MeshGlobalRateLimitItemHeaders struct {
	Add []MeshGlobalRateLimitItemAdd `json:"add,omitempty"`
	Set []MeshGlobalRateLimitItemSet `json:"set,omitempty"`
}

func (m *MeshGlobalRateLimitItemHeaders) GetAdd() []MeshGlobalRateLimitItemAdd {
	if m == nil {
		return nil
	}
	return m.Add
}

func (m *MeshGlobalRateLimitItemHeaders) GetSet() []MeshGlobalRateLimitItemSet {
	if m == nil {
		return nil
	}
	return m.Set
}

// OnRateLimit - Describes the actions to take on a rate limit event
type OnRateLimit struct {
	// The Headers to be added to the HTTP response on a rate limit event
	Headers *MeshGlobalRateLimitItemHeaders `json:"headers,omitempty"`
	// The HTTP status code to be set on a rate limit event
	Status *int `json:"status,omitempty"`
}

func (o *OnRateLimit) GetHeaders() *MeshGlobalRateLimitItemHeaders {
	if o == nil {
		return nil
	}
	return o.Headers
}

func (o *OnRateLimit) GetStatus() *int {
	if o == nil {
		return nil
	}
	return o.Status
}

// MeshGlobalRateLimitItemSpecFromKind - Kind defines type of rate limit config. Possible options: OnHeader.
type MeshGlobalRateLimitItemSpecFromKind string

const (
	MeshGlobalRateLimitItemSpecFromKindOnHeader MeshGlobalRateLimitItemSpecFromKind = "OnHeader"
)

func (e MeshGlobalRateLimitItemSpecFromKind) ToPointer() *MeshGlobalRateLimitItemSpecFromKind {
	return &e
}
func (e *MeshGlobalRateLimitItemSpecFromKind) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "OnHeader":
		*e = MeshGlobalRateLimitItemSpecFromKind(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshGlobalRateLimitItemSpecFromKind: %v", v)
	}
}

// MeshGlobalRateLimitItemSpecFromRequestRate - Defines how many requests are allowed per interval.
type MeshGlobalRateLimitItemSpecFromRequestRate struct {
	// The interval the number of units is accounted for. Only 1s, 1m, 1h or 24h can be configured.
	Interval string `json:"interval"`
	// Number of units per interval (depending on usage it can be a number of requests,
	// or a number of connections).
	Num int `json:"num"`
}

func (m *MeshGlobalRateLimitItemSpecFromRequestRate) GetInterval() string {
	if m == nil {
		return ""
	}
	return m.Interval
}

func (m *MeshGlobalRateLimitItemSpecFromRequestRate) GetNum() int {
	if m == nil {
		return 0
	}
	return m.Num
}

type Limits struct {
	// Defines how many requests are allowed per interval.
	RequestRate *MeshGlobalRateLimitItemSpecFromRequestRate `json:"requestRate,omitempty"`
	// Value of the request element on which rate limit should apply. E.g. header value.
	Value string `json:"value"`
}

func (l *Limits) GetRequestRate() *MeshGlobalRateLimitItemSpecFromRequestRate {
	if l == nil {
		return nil
	}
	return l.RequestRate
}

func (l *Limits) GetValue() string {
	if l == nil {
		return ""
	}
	return l.Value
}

type RatelimitOnRequest struct {
	// Kind defines type of rate limit config. Possible options: OnHeader.
	Kind MeshGlobalRateLimitItemSpecFromKind `json:"kind"`
	// Limits defines limit configuration.
	Limits []Limits `json:"limits"`
	// Name of the request element on which rate limit should apply. E.g. header name.
	Name string `json:"name"`
}

func (r *RatelimitOnRequest) GetKind() MeshGlobalRateLimitItemSpecFromKind {
	if r == nil {
		return MeshGlobalRateLimitItemSpecFromKind("")
	}
	return r.Kind
}

func (r *RatelimitOnRequest) GetLimits() []Limits {
	if r == nil {
		return []Limits{}
	}
	return r.Limits
}

func (r *RatelimitOnRequest) GetName() string {
	if r == nil {
		return ""
	}
	return r.Name
}

// RequestRate - Defines how many requests are allowed per interval.
type RequestRate struct {
	// The interval the number of units is accounted for. Only 1s, 1m, 1h or 24h can be configured.
	Interval string `json:"interval"`
	// Number of units per interval (depending on usage it can be a number of requests,
	// or a number of connections).
	Num int `json:"num"`
}

func (r *RequestRate) GetInterval() string {
	if r == nil {
		return ""
	}
	return r.Interval
}

func (r *RequestRate) GetNum() int {
	if r == nil {
		return 0
	}
	return r.Num
}

type MeshGlobalRateLimitItemHTTP struct {
	// Define if rate limiting should be disabled.
	Disabled *bool `json:"disabled,omitempty"`
	// Describes the actions to take on a rate limit event
	OnRateLimit *OnRateLimit `json:"onRateLimit,omitempty"`
	// Defines rate limit based on request content
	RatelimitOnRequest []RatelimitOnRequest `json:"ratelimitOnRequest,omitempty"`
	// Defines how many requests are allowed per interval.
	RequestRate *RequestRate `json:"requestRate,omitempty"`
}

func (m *MeshGlobalRateLimitItemHTTP) GetDisabled() *bool {
	if m == nil {
		return nil
	}
	return m.Disabled
}

func (m *MeshGlobalRateLimitItemHTTP) GetOnRateLimit() *OnRateLimit {
	if m == nil {
		return nil
	}
	return m.OnRateLimit
}

func (m *MeshGlobalRateLimitItemHTTP) GetRatelimitOnRequest() []RatelimitOnRequest {
	if m == nil {
		return nil
	}
	return m.RatelimitOnRequest
}

func (m *MeshGlobalRateLimitItemHTTP) GetRequestRate() *RequestRate {
	if m == nil {
		return nil
	}
	return m.RequestRate
}

// MeshGlobalRateLimitItemMode - Mode defines rate limit behavior when limits are reached. Possible options: Limit and Shadow. Setting Shadow will
// not block over the limit requests but will update metrics. This is useful for testing rate limit configuration.
type MeshGlobalRateLimitItemMode string

const (
	MeshGlobalRateLimitItemModeLimit  MeshGlobalRateLimitItemMode = "Limit"
	MeshGlobalRateLimitItemModeShadow MeshGlobalRateLimitItemMode = "Shadow"
)

func (e MeshGlobalRateLimitItemMode) ToPointer() *MeshGlobalRateLimitItemMode {
	return &e
}
func (e *MeshGlobalRateLimitItemMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Limit":
		fallthrough
	case "Shadow":
		*e = MeshGlobalRateLimitItemMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshGlobalRateLimitItemMode: %v", v)
	}
}

// MeshGlobalRateLimitItemDefault - Default is a configuration specific to the group of clients referenced in
// 'targetRef'
type MeshGlobalRateLimitItemDefault struct {
	// Backend defines location of rate limit backend service.
	Backend Backend                     `json:"backend"`
	HTTP    MeshGlobalRateLimitItemHTTP `json:"http"`
	// Mode defines rate limit behavior when limits are reached. Possible options: Limit and Shadow. Setting Shadow will
	// not block over the limit requests but will update metrics. This is useful for testing rate limit configuration.
	Mode *MeshGlobalRateLimitItemMode `json:"mode,omitempty"`
}

func (m *MeshGlobalRateLimitItemDefault) GetBackend() Backend {
	if m == nil {
		return Backend{}
	}
	return m.Backend
}

func (m *MeshGlobalRateLimitItemDefault) GetHTTP() MeshGlobalRateLimitItemHTTP {
	if m == nil {
		return MeshGlobalRateLimitItemHTTP{}
	}
	return m.HTTP
}

func (m *MeshGlobalRateLimitItemDefault) GetMode() *MeshGlobalRateLimitItemMode {
	if m == nil {
		return nil
	}
	return m.Mode
}

// MeshGlobalRateLimitItemSpecKind - Kind of the referenced resource
type MeshGlobalRateLimitItemSpecKind string

const (
	MeshGlobalRateLimitItemSpecKindMesh                 MeshGlobalRateLimitItemSpecKind = "Mesh"
	MeshGlobalRateLimitItemSpecKindMeshSubset           MeshGlobalRateLimitItemSpecKind = "MeshSubset"
	MeshGlobalRateLimitItemSpecKindMeshGateway          MeshGlobalRateLimitItemSpecKind = "MeshGateway"
	MeshGlobalRateLimitItemSpecKindMeshService          MeshGlobalRateLimitItemSpecKind = "MeshService"
	MeshGlobalRateLimitItemSpecKindMeshExternalService  MeshGlobalRateLimitItemSpecKind = "MeshExternalService"
	MeshGlobalRateLimitItemSpecKindMeshMultiZoneService MeshGlobalRateLimitItemSpecKind = "MeshMultiZoneService"
	MeshGlobalRateLimitItemSpecKindMeshServiceSubset    MeshGlobalRateLimitItemSpecKind = "MeshServiceSubset"
	MeshGlobalRateLimitItemSpecKindMeshHTTPRoute        MeshGlobalRateLimitItemSpecKind = "MeshHTTPRoute"
	MeshGlobalRateLimitItemSpecKindDataplane            MeshGlobalRateLimitItemSpecKind = "Dataplane"
)

func (e MeshGlobalRateLimitItemSpecKind) ToPointer() *MeshGlobalRateLimitItemSpecKind {
	return &e
}
func (e *MeshGlobalRateLimitItemSpecKind) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Mesh":
		fallthrough
	case "MeshSubset":
		fallthrough
	case "MeshGateway":
		fallthrough
	case "MeshService":
		fallthrough
	case "MeshExternalService":
		fallthrough
	case "MeshMultiZoneService":
		fallthrough
	case "MeshServiceSubset":
		fallthrough
	case "MeshHTTPRoute":
		fallthrough
	case "Dataplane":
		*e = MeshGlobalRateLimitItemSpecKind(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshGlobalRateLimitItemSpecKind: %v", v)
	}
}

type MeshGlobalRateLimitItemSpecProxyTypes string

const (
	MeshGlobalRateLimitItemSpecProxyTypesSidecar MeshGlobalRateLimitItemSpecProxyTypes = "Sidecar"
	MeshGlobalRateLimitItemSpecProxyTypesGateway MeshGlobalRateLimitItemSpecProxyTypes = "Gateway"
)

func (e MeshGlobalRateLimitItemSpecProxyTypes) ToPointer() *MeshGlobalRateLimitItemSpecProxyTypes {
	return &e
}
func (e *MeshGlobalRateLimitItemSpecProxyTypes) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Sidecar":
		fallthrough
	case "Gateway":
		*e = MeshGlobalRateLimitItemSpecProxyTypes(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshGlobalRateLimitItemSpecProxyTypes: %v", v)
	}
}

// MeshGlobalRateLimitItemSpecTargetRef - TargetRef is a reference to the resource that represents a group of
// clients.
type MeshGlobalRateLimitItemSpecTargetRef struct {
	// Kind of the referenced resource
	Kind MeshGlobalRateLimitItemSpecKind `json:"kind"`
	// Labels are used to select group of MeshServices that match labels. Either Labels or
	// Name and Namespace can be used.
	Labels map[string]string `json:"labels,omitempty"`
	// Mesh is reserved for future use to identify cross mesh resources.
	Mesh *string `json:"mesh,omitempty"`
	// Name of the referenced resource. Can only be used with kinds: `MeshService`,
	// `MeshServiceSubset` and `MeshGatewayRoute`
	Name *string `json:"name,omitempty"`
	// Namespace specifies the namespace of target resource. If empty only resources in policy namespace
	// will be targeted.
	Namespace *string `json:"namespace,omitempty"`
	// ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
	// all data plane types are targeted by the policy.
	ProxyTypes []MeshGlobalRateLimitItemSpecProxyTypes `json:"proxyTypes,omitempty"`
	// SectionName is used to target specific section of resource.
	// For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected.
	SectionName *string `json:"sectionName,omitempty"`
	// Tags used to select a subset of proxies by tags. Can only be used with kinds
	// `MeshSubset` and `MeshServiceSubset`
	Tags map[string]string `json:"tags,omitempty"`
}

func (m *MeshGlobalRateLimitItemSpecTargetRef) GetKind() MeshGlobalRateLimitItemSpecKind {
	if m == nil {
		return MeshGlobalRateLimitItemSpecKind("")
	}
	return m.Kind
}

func (m *MeshGlobalRateLimitItemSpecTargetRef) GetLabels() map[string]string {
	if m == nil {
		return nil
	}
	return m.Labels
}

func (m *MeshGlobalRateLimitItemSpecTargetRef) GetMesh() *string {
	if m == nil {
		return nil
	}
	return m.Mesh
}

func (m *MeshGlobalRateLimitItemSpecTargetRef) GetName() *string {
	if m == nil {
		return nil
	}
	return m.Name
}

func (m *MeshGlobalRateLimitItemSpecTargetRef) GetNamespace() *string {
	if m == nil {
		return nil
	}
	return m.Namespace
}

func (m *MeshGlobalRateLimitItemSpecTargetRef) GetProxyTypes() []MeshGlobalRateLimitItemSpecProxyTypes {
	if m == nil {
		return nil
	}
	return m.ProxyTypes
}

func (m *MeshGlobalRateLimitItemSpecTargetRef) GetSectionName() *string {
	if m == nil {
		return nil
	}
	return m.SectionName
}

func (m *MeshGlobalRateLimitItemSpecTargetRef) GetTags() map[string]string {
	if m == nil {
		return nil
	}
	return m.Tags
}

type MeshGlobalRateLimitItemFrom struct {
	// Default is a configuration specific to the group of clients referenced in
	// 'targetRef'
	Default *MeshGlobalRateLimitItemDefault `json:"default,omitempty"`
	// TargetRef is a reference to the resource that represents a group of
	// clients.
	TargetRef MeshGlobalRateLimitItemSpecTargetRef `json:"targetRef"`
}

func (m *MeshGlobalRateLimitItemFrom) GetDefault() *MeshGlobalRateLimitItemDefault {
	if m == nil {
		return nil
	}
	return m.Default
}

func (m *MeshGlobalRateLimitItemFrom) GetTargetRef() MeshGlobalRateLimitItemSpecTargetRef {
	if m == nil {
		return MeshGlobalRateLimitItemSpecTargetRef{}
	}
	return m.TargetRef
}

// MeshGlobalRateLimitItemKind - Kind of the referenced resource
type MeshGlobalRateLimitItemKind string

const (
	MeshGlobalRateLimitItemKindMesh                 MeshGlobalRateLimitItemKind = "Mesh"
	MeshGlobalRateLimitItemKindMeshSubset           MeshGlobalRateLimitItemKind = "MeshSubset"
	MeshGlobalRateLimitItemKindMeshGateway          MeshGlobalRateLimitItemKind = "MeshGateway"
	MeshGlobalRateLimitItemKindMeshService          MeshGlobalRateLimitItemKind = "MeshService"
	MeshGlobalRateLimitItemKindMeshExternalService  MeshGlobalRateLimitItemKind = "MeshExternalService"
	MeshGlobalRateLimitItemKindMeshMultiZoneService MeshGlobalRateLimitItemKind = "MeshMultiZoneService"
	MeshGlobalRateLimitItemKindMeshServiceSubset    MeshGlobalRateLimitItemKind = "MeshServiceSubset"
	MeshGlobalRateLimitItemKindMeshHTTPRoute        MeshGlobalRateLimitItemKind = "MeshHTTPRoute"
	MeshGlobalRateLimitItemKindDataplane            MeshGlobalRateLimitItemKind = "Dataplane"
)

func (e MeshGlobalRateLimitItemKind) ToPointer() *MeshGlobalRateLimitItemKind {
	return &e
}
func (e *MeshGlobalRateLimitItemKind) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Mesh":
		fallthrough
	case "MeshSubset":
		fallthrough
	case "MeshGateway":
		fallthrough
	case "MeshService":
		fallthrough
	case "MeshExternalService":
		fallthrough
	case "MeshMultiZoneService":
		fallthrough
	case "MeshServiceSubset":
		fallthrough
	case "MeshHTTPRoute":
		fallthrough
	case "Dataplane":
		*e = MeshGlobalRateLimitItemKind(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshGlobalRateLimitItemKind: %v", v)
	}
}

type MeshGlobalRateLimitItemProxyTypes string

const (
	MeshGlobalRateLimitItemProxyTypesSidecar MeshGlobalRateLimitItemProxyTypes = "Sidecar"
	MeshGlobalRateLimitItemProxyTypesGateway MeshGlobalRateLimitItemProxyTypes = "Gateway"
)

func (e MeshGlobalRateLimitItemProxyTypes) ToPointer() *MeshGlobalRateLimitItemProxyTypes {
	return &e
}
func (e *MeshGlobalRateLimitItemProxyTypes) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Sidecar":
		fallthrough
	case "Gateway":
		*e = MeshGlobalRateLimitItemProxyTypes(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshGlobalRateLimitItemProxyTypes: %v", v)
	}
}

// MeshGlobalRateLimitItemTargetRef - TargetRef is a reference to the resource the policy takes an effect on.
// The resource could be either a real store object or virtual resource
// defined inplace.
type MeshGlobalRateLimitItemTargetRef struct {
	// Kind of the referenced resource
	Kind MeshGlobalRateLimitItemKind `json:"kind"`
	// Labels are used to select group of MeshServices that match labels. Either Labels or
	// Name and Namespace can be used.
	Labels map[string]string `json:"labels,omitempty"`
	// Mesh is reserved for future use to identify cross mesh resources.
	Mesh *string `json:"mesh,omitempty"`
	// Name of the referenced resource. Can only be used with kinds: `MeshService`,
	// `MeshServiceSubset` and `MeshGatewayRoute`
	Name *string `json:"name,omitempty"`
	// Namespace specifies the namespace of target resource. If empty only resources in policy namespace
	// will be targeted.
	Namespace *string `json:"namespace,omitempty"`
	// ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
	// all data plane types are targeted by the policy.
	ProxyTypes []MeshGlobalRateLimitItemProxyTypes `json:"proxyTypes,omitempty"`
	// SectionName is used to target specific section of resource.
	// For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected.
	SectionName *string `json:"sectionName,omitempty"`
	// Tags used to select a subset of proxies by tags. Can only be used with kinds
	// `MeshSubset` and `MeshServiceSubset`
	Tags map[string]string `json:"tags,omitempty"`
}

func (m *MeshGlobalRateLimitItemTargetRef) GetKind() MeshGlobalRateLimitItemKind {
	if m == nil {
		return MeshGlobalRateLimitItemKind("")
	}
	return m.Kind
}

func (m *MeshGlobalRateLimitItemTargetRef) GetLabels() map[string]string {
	if m == nil {
		return nil
	}
	return m.Labels
}

func (m *MeshGlobalRateLimitItemTargetRef) GetMesh() *string {
	if m == nil {
		return nil
	}
	return m.Mesh
}

func (m *MeshGlobalRateLimitItemTargetRef) GetName() *string {
	if m == nil {
		return nil
	}
	return m.Name
}

func (m *MeshGlobalRateLimitItemTargetRef) GetNamespace() *string {
	if m == nil {
		return nil
	}
	return m.Namespace
}

func (m *MeshGlobalRateLimitItemTargetRef) GetProxyTypes() []MeshGlobalRateLimitItemProxyTypes {
	if m == nil {
		return nil
	}
	return m.ProxyTypes
}

func (m *MeshGlobalRateLimitItemTargetRef) GetSectionName() *string {
	if m == nil {
		return nil
	}
	return m.SectionName
}

func (m *MeshGlobalRateLimitItemTargetRef) GetTags() map[string]string {
	if m == nil {
		return nil
	}
	return m.Tags
}

type MeshGlobalRateLimitItemRateLimitService struct {
	// LimitOnServiceFail will pass limit requests if ratelimit service is not reachable.
	LimitOnServiceFail *bool `json:"limitOnServiceFail,omitempty"`
	// Timeout for rate limit request made form Data Plane Proxy to rate limit service.
	Timeout *string `json:"timeout,omitempty"`
	// Url defines address of rate limit service.
	URL *string `json:"url,omitempty"`
}

func (m *MeshGlobalRateLimitItemRateLimitService) GetLimitOnServiceFail() *bool {
	if m == nil {
		return nil
	}
	return m.LimitOnServiceFail
}

func (m *MeshGlobalRateLimitItemRateLimitService) GetTimeout() *string {
	if m == nil {
		return nil
	}
	return m.Timeout
}

func (m *MeshGlobalRateLimitItemRateLimitService) GetURL() *string {
	if m == nil {
		return nil
	}
	return m.URL
}

// MeshGlobalRateLimitItemBackend - Backend defines location of rate limit backend service.
type MeshGlobalRateLimitItemBackend struct {
	RateLimitService MeshGlobalRateLimitItemRateLimitService `json:"rateLimitService"`
}

func (m *MeshGlobalRateLimitItemBackend) GetRateLimitService() MeshGlobalRateLimitItemRateLimitService {
	if m == nil {
		return MeshGlobalRateLimitItemRateLimitService{}
	}
	return m.RateLimitService
}

type MeshGlobalRateLimitItemSpecAdd struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

func (m *MeshGlobalRateLimitItemSpecAdd) GetName() string {
	if m == nil {
		return ""
	}
	return m.Name
}

func (m *MeshGlobalRateLimitItemSpecAdd) GetValue() string {
	if m == nil {
		return ""
	}
	return m.Value
}

type MeshGlobalRateLimitItemSpecSet struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

func (m *MeshGlobalRateLimitItemSpecSet) GetName() string {
	if m == nil {
		return ""
	}
	return m.Name
}

func (m *MeshGlobalRateLimitItemSpecSet) GetValue() string {
	if m == nil {
		return ""
	}
	return m.Value
}

// MeshGlobalRateLimitItemSpecHeaders - The Headers to be added to the HTTP response on a rate limit event
type MeshGlobalRateLimitItemSpecHeaders struct {
	Add []MeshGlobalRateLimitItemSpecAdd `json:"add,omitempty"`
	Set []MeshGlobalRateLimitItemSpecSet `json:"set,omitempty"`
}

func (m *MeshGlobalRateLimitItemSpecHeaders) GetAdd() []MeshGlobalRateLimitItemSpecAdd {
	if m == nil {
		return nil
	}
	return m.Add
}

func (m *MeshGlobalRateLimitItemSpecHeaders) GetSet() []MeshGlobalRateLimitItemSpecSet {
	if m == nil {
		return nil
	}
	return m.Set
}

// MeshGlobalRateLimitItemOnRateLimit - Describes the actions to take on a rate limit event
type MeshGlobalRateLimitItemOnRateLimit struct {
	// The Headers to be added to the HTTP response on a rate limit event
	Headers *MeshGlobalRateLimitItemSpecHeaders `json:"headers,omitempty"`
	// The HTTP status code to be set on a rate limit event
	Status *int `json:"status,omitempty"`
}

func (m *MeshGlobalRateLimitItemOnRateLimit) GetHeaders() *MeshGlobalRateLimitItemSpecHeaders {
	if m == nil {
		return nil
	}
	return m.Headers
}

func (m *MeshGlobalRateLimitItemOnRateLimit) GetStatus() *int {
	if m == nil {
		return nil
	}
	return m.Status
}

// MeshGlobalRateLimitItemSpecToDefaultKind - Kind defines type of rate limit config. Possible options: OnHeader.
type MeshGlobalRateLimitItemSpecToDefaultKind string

const (
	MeshGlobalRateLimitItemSpecToDefaultKindOnHeader MeshGlobalRateLimitItemSpecToDefaultKind = "OnHeader"
)

func (e MeshGlobalRateLimitItemSpecToDefaultKind) ToPointer() *MeshGlobalRateLimitItemSpecToDefaultKind {
	return &e
}
func (e *MeshGlobalRateLimitItemSpecToDefaultKind) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "OnHeader":
		*e = MeshGlobalRateLimitItemSpecToDefaultKind(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshGlobalRateLimitItemSpecToDefaultKind: %v", v)
	}
}

// MeshGlobalRateLimitItemSpecRequestRate - Defines how many requests are allowed per interval.
type MeshGlobalRateLimitItemSpecRequestRate struct {
	// The interval the number of units is accounted for. Only 1s, 1m, 1h or 24h can be configured.
	Interval string `json:"interval"`
	// Number of units per interval (depending on usage it can be a number of requests,
	// or a number of connections).
	Num int `json:"num"`
}

func (m *MeshGlobalRateLimitItemSpecRequestRate) GetInterval() string {
	if m == nil {
		return ""
	}
	return m.Interval
}

func (m *MeshGlobalRateLimitItemSpecRequestRate) GetNum() int {
	if m == nil {
		return 0
	}
	return m.Num
}

type MeshGlobalRateLimitItemLimits struct {
	// Defines how many requests are allowed per interval.
	RequestRate *MeshGlobalRateLimitItemSpecRequestRate `json:"requestRate,omitempty"`
	// Value of the request element on which rate limit should apply. E.g. header value.
	Value string `json:"value"`
}

func (m *MeshGlobalRateLimitItemLimits) GetRequestRate() *MeshGlobalRateLimitItemSpecRequestRate {
	if m == nil {
		return nil
	}
	return m.RequestRate
}

func (m *MeshGlobalRateLimitItemLimits) GetValue() string {
	if m == nil {
		return ""
	}
	return m.Value
}

type MeshGlobalRateLimitItemRatelimitOnRequest struct {
	// Kind defines type of rate limit config. Possible options: OnHeader.
	Kind MeshGlobalRateLimitItemSpecToDefaultKind `json:"kind"`
	// Limits defines limit configuration.
	Limits []MeshGlobalRateLimitItemLimits `json:"limits"`
	// Name of the request element on which rate limit should apply. E.g. header name.
	Name string `json:"name"`
}

func (m *MeshGlobalRateLimitItemRatelimitOnRequest) GetKind() MeshGlobalRateLimitItemSpecToDefaultKind {
	if m == nil {
		return MeshGlobalRateLimitItemSpecToDefaultKind("")
	}
	return m.Kind
}

func (m *MeshGlobalRateLimitItemRatelimitOnRequest) GetLimits() []MeshGlobalRateLimitItemLimits {
	if m == nil {
		return []MeshGlobalRateLimitItemLimits{}
	}
	return m.Limits
}

func (m *MeshGlobalRateLimitItemRatelimitOnRequest) GetName() string {
	if m == nil {
		return ""
	}
	return m.Name
}

// MeshGlobalRateLimitItemRequestRate - Defines how many requests are allowed per interval.
type MeshGlobalRateLimitItemRequestRate struct {
	// The interval the number of units is accounted for. Only 1s, 1m, 1h or 24h can be configured.
	Interval string `json:"interval"`
	// Number of units per interval (depending on usage it can be a number of requests,
	// or a number of connections).
	Num int `json:"num"`
}

func (m *MeshGlobalRateLimitItemRequestRate) GetInterval() string {
	if m == nil {
		return ""
	}
	return m.Interval
}

func (m *MeshGlobalRateLimitItemRequestRate) GetNum() int {
	if m == nil {
		return 0
	}
	return m.Num
}

type MeshGlobalRateLimitItemSpecHTTP struct {
	// Define if rate limiting should be disabled.
	Disabled *bool `json:"disabled,omitempty"`
	// Describes the actions to take on a rate limit event
	OnRateLimit *MeshGlobalRateLimitItemOnRateLimit `json:"onRateLimit,omitempty"`
	// Defines rate limit based on request content
	RatelimitOnRequest []MeshGlobalRateLimitItemRatelimitOnRequest `json:"ratelimitOnRequest,omitempty"`
	// Defines how many requests are allowed per interval.
	RequestRate *MeshGlobalRateLimitItemRequestRate `json:"requestRate,omitempty"`
}

func (m *MeshGlobalRateLimitItemSpecHTTP) GetDisabled() *bool {
	if m == nil {
		return nil
	}
	return m.Disabled
}

func (m *MeshGlobalRateLimitItemSpecHTTP) GetOnRateLimit() *MeshGlobalRateLimitItemOnRateLimit {
	if m == nil {
		return nil
	}
	return m.OnRateLimit
}

func (m *MeshGlobalRateLimitItemSpecHTTP) GetRatelimitOnRequest() []MeshGlobalRateLimitItemRatelimitOnRequest {
	if m == nil {
		return nil
	}
	return m.RatelimitOnRequest
}

func (m *MeshGlobalRateLimitItemSpecHTTP) GetRequestRate() *MeshGlobalRateLimitItemRequestRate {
	if m == nil {
		return nil
	}
	return m.RequestRate
}

// MeshGlobalRateLimitItemSpecMode - Mode defines rate limit behavior when limits are reached. Possible options: Limit and Shadow. Setting Shadow will
// not block over the limit requests but will update metrics. This is useful for testing rate limit configuration.
type MeshGlobalRateLimitItemSpecMode string

const (
	MeshGlobalRateLimitItemSpecModeLimit  MeshGlobalRateLimitItemSpecMode = "Limit"
	MeshGlobalRateLimitItemSpecModeShadow MeshGlobalRateLimitItemSpecMode = "Shadow"
)

func (e MeshGlobalRateLimitItemSpecMode) ToPointer() *MeshGlobalRateLimitItemSpecMode {
	return &e
}
func (e *MeshGlobalRateLimitItemSpecMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Limit":
		fallthrough
	case "Shadow":
		*e = MeshGlobalRateLimitItemSpecMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshGlobalRateLimitItemSpecMode: %v", v)
	}
}

// MeshGlobalRateLimitItemSpecDefault - Default is a configuration specific to the group of clients referenced in
// 'targetRef'
type MeshGlobalRateLimitItemSpecDefault struct {
	// Backend defines location of rate limit backend service.
	Backend MeshGlobalRateLimitItemBackend  `json:"backend"`
	HTTP    MeshGlobalRateLimitItemSpecHTTP `json:"http"`
	// Mode defines rate limit behavior when limits are reached. Possible options: Limit and Shadow. Setting Shadow will
	// not block over the limit requests but will update metrics. This is useful for testing rate limit configuration.
	Mode *MeshGlobalRateLimitItemSpecMode `json:"mode,omitempty"`
}

func (m *MeshGlobalRateLimitItemSpecDefault) GetBackend() MeshGlobalRateLimitItemBackend {
	if m == nil {
		return MeshGlobalRateLimitItemBackend{}
	}
	return m.Backend
}

func (m *MeshGlobalRateLimitItemSpecDefault) GetHTTP() MeshGlobalRateLimitItemSpecHTTP {
	if m == nil {
		return MeshGlobalRateLimitItemSpecHTTP{}
	}
	return m.HTTP
}

func (m *MeshGlobalRateLimitItemSpecDefault) GetMode() *MeshGlobalRateLimitItemSpecMode {
	if m == nil {
		return nil
	}
	return m.Mode
}

// MeshGlobalRateLimitItemSpecToKind - Kind of the referenced resource
type MeshGlobalRateLimitItemSpecToKind string

const (
	MeshGlobalRateLimitItemSpecToKindMesh                 MeshGlobalRateLimitItemSpecToKind = "Mesh"
	MeshGlobalRateLimitItemSpecToKindMeshSubset           MeshGlobalRateLimitItemSpecToKind = "MeshSubset"
	MeshGlobalRateLimitItemSpecToKindMeshGateway          MeshGlobalRateLimitItemSpecToKind = "MeshGateway"
	MeshGlobalRateLimitItemSpecToKindMeshService          MeshGlobalRateLimitItemSpecToKind = "MeshService"
	MeshGlobalRateLimitItemSpecToKindMeshExternalService  MeshGlobalRateLimitItemSpecToKind = "MeshExternalService"
	MeshGlobalRateLimitItemSpecToKindMeshMultiZoneService MeshGlobalRateLimitItemSpecToKind = "MeshMultiZoneService"
	MeshGlobalRateLimitItemSpecToKindMeshServiceSubset    MeshGlobalRateLimitItemSpecToKind = "MeshServiceSubset"
	MeshGlobalRateLimitItemSpecToKindMeshHTTPRoute        MeshGlobalRateLimitItemSpecToKind = "MeshHTTPRoute"
	MeshGlobalRateLimitItemSpecToKindDataplane            MeshGlobalRateLimitItemSpecToKind = "Dataplane"
)

func (e MeshGlobalRateLimitItemSpecToKind) ToPointer() *MeshGlobalRateLimitItemSpecToKind {
	return &e
}
func (e *MeshGlobalRateLimitItemSpecToKind) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Mesh":
		fallthrough
	case "MeshSubset":
		fallthrough
	case "MeshGateway":
		fallthrough
	case "MeshService":
		fallthrough
	case "MeshExternalService":
		fallthrough
	case "MeshMultiZoneService":
		fallthrough
	case "MeshServiceSubset":
		fallthrough
	case "MeshHTTPRoute":
		fallthrough
	case "Dataplane":
		*e = MeshGlobalRateLimitItemSpecToKind(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshGlobalRateLimitItemSpecToKind: %v", v)
	}
}

type MeshGlobalRateLimitItemSpecToProxyTypes string

const (
	MeshGlobalRateLimitItemSpecToProxyTypesSidecar MeshGlobalRateLimitItemSpecToProxyTypes = "Sidecar"
	MeshGlobalRateLimitItemSpecToProxyTypesGateway MeshGlobalRateLimitItemSpecToProxyTypes = "Gateway"
)

func (e MeshGlobalRateLimitItemSpecToProxyTypes) ToPointer() *MeshGlobalRateLimitItemSpecToProxyTypes {
	return &e
}
func (e *MeshGlobalRateLimitItemSpecToProxyTypes) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Sidecar":
		fallthrough
	case "Gateway":
		*e = MeshGlobalRateLimitItemSpecToProxyTypes(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshGlobalRateLimitItemSpecToProxyTypes: %v", v)
	}
}

// MeshGlobalRateLimitItemSpecToTargetRef - TargetRef is a reference to the resource that represents a group of
// clients.
type MeshGlobalRateLimitItemSpecToTargetRef struct {
	// Kind of the referenced resource
	Kind MeshGlobalRateLimitItemSpecToKind `json:"kind"`
	// Labels are used to select group of MeshServices that match labels. Either Labels or
	// Name and Namespace can be used.
	Labels map[string]string `json:"labels,omitempty"`
	// Mesh is reserved for future use to identify cross mesh resources.
	Mesh *string `json:"mesh,omitempty"`
	// Name of the referenced resource. Can only be used with kinds: `MeshService`,
	// `MeshServiceSubset` and `MeshGatewayRoute`
	Name *string `json:"name,omitempty"`
	// Namespace specifies the namespace of target resource. If empty only resources in policy namespace
	// will be targeted.
	Namespace *string `json:"namespace,omitempty"`
	// ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
	// all data plane types are targeted by the policy.
	ProxyTypes []MeshGlobalRateLimitItemSpecToProxyTypes `json:"proxyTypes,omitempty"`
	// SectionName is used to target specific section of resource.
	// For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected.
	SectionName *string `json:"sectionName,omitempty"`
	// Tags used to select a subset of proxies by tags. Can only be used with kinds
	// `MeshSubset` and `MeshServiceSubset`
	Tags map[string]string `json:"tags,omitempty"`
}

func (m *MeshGlobalRateLimitItemSpecToTargetRef) GetKind() MeshGlobalRateLimitItemSpecToKind {
	if m == nil {
		return MeshGlobalRateLimitItemSpecToKind("")
	}
	return m.Kind
}

func (m *MeshGlobalRateLimitItemSpecToTargetRef) GetLabels() map[string]string {
	if m == nil {
		return nil
	}
	return m.Labels
}

func (m *MeshGlobalRateLimitItemSpecToTargetRef) GetMesh() *string {
	if m == nil {
		return nil
	}
	return m.Mesh
}

func (m *MeshGlobalRateLimitItemSpecToTargetRef) GetName() *string {
	if m == nil {
		return nil
	}
	return m.Name
}

func (m *MeshGlobalRateLimitItemSpecToTargetRef) GetNamespace() *string {
	if m == nil {
		return nil
	}
	return m.Namespace
}

func (m *MeshGlobalRateLimitItemSpecToTargetRef) GetProxyTypes() []MeshGlobalRateLimitItemSpecToProxyTypes {
	if m == nil {
		return nil
	}
	return m.ProxyTypes
}

func (m *MeshGlobalRateLimitItemSpecToTargetRef) GetSectionName() *string {
	if m == nil {
		return nil
	}
	return m.SectionName
}

func (m *MeshGlobalRateLimitItemSpecToTargetRef) GetTags() map[string]string {
	if m == nil {
		return nil
	}
	return m.Tags
}

type MeshGlobalRateLimitItemTo struct {
	// Default is a configuration specific to the group of clients referenced in
	// 'targetRef'
	Default *MeshGlobalRateLimitItemSpecDefault `json:"default,omitempty"`
	// TargetRef is a reference to the resource that represents a group of
	// clients.
	TargetRef MeshGlobalRateLimitItemSpecToTargetRef `json:"targetRef"`
}

func (m *MeshGlobalRateLimitItemTo) GetDefault() *MeshGlobalRateLimitItemSpecDefault {
	if m == nil {
		return nil
	}
	return m.Default
}

func (m *MeshGlobalRateLimitItemTo) GetTargetRef() MeshGlobalRateLimitItemSpecToTargetRef {
	if m == nil {
		return MeshGlobalRateLimitItemSpecToTargetRef{}
	}
	return m.TargetRef
}

// MeshGlobalRateLimitItemSpec - Spec is the specification of the Kuma MeshGlobalRateLimit resource.
type MeshGlobalRateLimitItemSpec struct {
	// From list makes a match between clients and corresponding configurations
	From []MeshGlobalRateLimitItemFrom `json:"from,omitempty"`
	// TargetRef is a reference to the resource the policy takes an effect on.
	// The resource could be either a real store object or virtual resource
	// defined inplace.
	TargetRef *MeshGlobalRateLimitItemTargetRef `json:"targetRef,omitempty"`
	// To list makes a match between clients and corresponding configurations
	To []MeshGlobalRateLimitItemTo `json:"to,omitempty"`
}

func (m *MeshGlobalRateLimitItemSpec) GetFrom() []MeshGlobalRateLimitItemFrom {
	if m == nil {
		return nil
	}
	return m.From
}

func (m *MeshGlobalRateLimitItemSpec) GetTargetRef() *MeshGlobalRateLimitItemTargetRef {
	if m == nil {
		return nil
	}
	return m.TargetRef
}

func (m *MeshGlobalRateLimitItemSpec) GetTo() []MeshGlobalRateLimitItemTo {
	if m == nil {
		return nil
	}
	return m.To
}

// MeshGlobalRateLimitItem - Successful response
type MeshGlobalRateLimitItem struct {
	// the type of the resource
	Type MeshGlobalRateLimitItemType `json:"type"`
	// Mesh is the name of the Kuma mesh this resource belongs to. It may be omitted for cluster-scoped resources.
	Mesh *string `default:"default" json:"mesh"`
	// Name of the Kuma resource
	Name string `json:"name"`
	// The labels to help identity resources
	Labels map[string]string `json:"labels,omitempty"`
	// Spec is the specification of the Kuma MeshGlobalRateLimit resource.
	Spec MeshGlobalRateLimitItemSpec `json:"spec"`
	// Time at which the resource was created
	CreationTime *time.Time `json:"creationTime,omitempty"`
	// Time at which the resource was updated
	ModificationTime *time.Time `json:"modificationTime,omitempty"`
}

func (m MeshGlobalRateLimitItem) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(m, "", false)
}

func (m *MeshGlobalRateLimitItem) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &m, "", false, []string{"type", "name", "spec"}); err != nil {
		return err
	}
	return nil
}

func (m *MeshGlobalRateLimitItem) GetType() MeshGlobalRateLimitItemType {
	if m == nil {
		return MeshGlobalRateLimitItemType("")
	}
	return m.Type
}

func (m *MeshGlobalRateLimitItem) GetMesh() *string {
	if m == nil {
		return nil
	}
	return m.Mesh
}

func (m *MeshGlobalRateLimitItem) GetName() string {
	if m == nil {
		return ""
	}
	return m.Name
}

func (m *MeshGlobalRateLimitItem) GetLabels() map[string]string {
	if m == nil {
		return nil
	}
	return m.Labels
}

func (m *MeshGlobalRateLimitItem) GetSpec() MeshGlobalRateLimitItemSpec {
	if m == nil {
		return MeshGlobalRateLimitItemSpec{}
	}
	return m.Spec
}

func (m *MeshGlobalRateLimitItem) GetCreationTime() *time.Time {
	if m == nil {
		return nil
	}
	return m.CreationTime
}

func (m *MeshGlobalRateLimitItem) GetModificationTime() *time.Time {
	if m == nil {
		return nil
	}
	return m.ModificationTime
}

type MeshGlobalRateLimitItemInput struct {
	// the type of the resource
	Type MeshGlobalRateLimitItemType `json:"type"`
	// Mesh is the name of the Kuma mesh this resource belongs to. It may be omitted for cluster-scoped resources.
	Mesh *string `default:"default" json:"mesh"`
	// Name of the Kuma resource
	Name string `json:"name"`
	// The labels to help identity resources
	Labels map[string]string `json:"labels,omitempty"`
	// Spec is the specification of the Kuma MeshGlobalRateLimit resource.
	Spec MeshGlobalRateLimitItemSpec `json:"spec"`
}

func (m MeshGlobalRateLimitItemInput) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(m, "", false)
}

func (m *MeshGlobalRateLimitItemInput) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &m, "", false, []string{"type", "name", "spec"}); err != nil {
		return err
	}
	return nil
}

func (m *MeshGlobalRateLimitItemInput) GetType() MeshGlobalRateLimitItemType {
	if m == nil {
		return MeshGlobalRateLimitItemType("")
	}
	return m.Type
}

func (m *MeshGlobalRateLimitItemInput) GetMesh() *string {
	if m == nil {
		return nil
	}
	return m.Mesh
}

func (m *MeshGlobalRateLimitItemInput) GetName() string {
	if m == nil {
		return ""
	}
	return m.Name
}

func (m *MeshGlobalRateLimitItemInput) GetLabels() map[string]string {
	if m == nil {
		return nil
	}
	return m.Labels
}

func (m *MeshGlobalRateLimitItemInput) GetSpec() MeshGlobalRateLimitItemSpec {
	if m == nil {
		return MeshGlobalRateLimitItemSpec{}
	}
	return m.Spec
}
