// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
	"github.com/kong/terraform-provider-kong-mesh/internal/sdk/internal/utils"
	"time"
)

// MeshTrafficPermissionItemType - the type of the resource
type MeshTrafficPermissionItemType string

const (
	MeshTrafficPermissionItemTypeMeshTrafficPermission MeshTrafficPermissionItemType = "MeshTrafficPermission"
)

func (e MeshTrafficPermissionItemType) ToPointer() *MeshTrafficPermissionItemType {
	return &e
}
func (e *MeshTrafficPermissionItemType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "MeshTrafficPermission":
		*e = MeshTrafficPermissionItemType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshTrafficPermissionItemType: %v", v)
	}
}

// Action defines a behavior for the specified group of clients:
type Action string

const (
	ActionAllow               Action = "Allow"
	ActionDeny                Action = "Deny"
	ActionAllowWithShadowDeny Action = "AllowWithShadowDeny"
)

func (e Action) ToPointer() *Action {
	return &e
}
func (e *Action) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Allow":
		fallthrough
	case "Deny":
		fallthrough
	case "AllowWithShadowDeny":
		*e = Action(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Action: %v", v)
	}
}

// MeshTrafficPermissionItemDefault - Default is a configuration specific to the group of clients referenced in
// 'targetRef'
type MeshTrafficPermissionItemDefault struct {
	// Action defines a behavior for the specified group of clients:
	Action *Action `json:"action,omitempty"`
}

func (m *MeshTrafficPermissionItemDefault) GetAction() *Action {
	if m == nil {
		return nil
	}
	return m.Action
}

// MeshTrafficPermissionItemSpecKind - Kind of the referenced resource
type MeshTrafficPermissionItemSpecKind string

const (
	MeshTrafficPermissionItemSpecKindMesh                 MeshTrafficPermissionItemSpecKind = "Mesh"
	MeshTrafficPermissionItemSpecKindMeshSubset           MeshTrafficPermissionItemSpecKind = "MeshSubset"
	MeshTrafficPermissionItemSpecKindMeshGateway          MeshTrafficPermissionItemSpecKind = "MeshGateway"
	MeshTrafficPermissionItemSpecKindMeshService          MeshTrafficPermissionItemSpecKind = "MeshService"
	MeshTrafficPermissionItemSpecKindMeshExternalService  MeshTrafficPermissionItemSpecKind = "MeshExternalService"
	MeshTrafficPermissionItemSpecKindMeshMultiZoneService MeshTrafficPermissionItemSpecKind = "MeshMultiZoneService"
	MeshTrafficPermissionItemSpecKindMeshServiceSubset    MeshTrafficPermissionItemSpecKind = "MeshServiceSubset"
	MeshTrafficPermissionItemSpecKindMeshHTTPRoute        MeshTrafficPermissionItemSpecKind = "MeshHTTPRoute"
	MeshTrafficPermissionItemSpecKindDataplane            MeshTrafficPermissionItemSpecKind = "Dataplane"
)

func (e MeshTrafficPermissionItemSpecKind) ToPointer() *MeshTrafficPermissionItemSpecKind {
	return &e
}
func (e *MeshTrafficPermissionItemSpecKind) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Mesh":
		fallthrough
	case "MeshSubset":
		fallthrough
	case "MeshGateway":
		fallthrough
	case "MeshService":
		fallthrough
	case "MeshExternalService":
		fallthrough
	case "MeshMultiZoneService":
		fallthrough
	case "MeshServiceSubset":
		fallthrough
	case "MeshHTTPRoute":
		fallthrough
	case "Dataplane":
		*e = MeshTrafficPermissionItemSpecKind(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshTrafficPermissionItemSpecKind: %v", v)
	}
}

type MeshTrafficPermissionItemSpecProxyTypes string

const (
	MeshTrafficPermissionItemSpecProxyTypesSidecar MeshTrafficPermissionItemSpecProxyTypes = "Sidecar"
	MeshTrafficPermissionItemSpecProxyTypesGateway MeshTrafficPermissionItemSpecProxyTypes = "Gateway"
)

func (e MeshTrafficPermissionItemSpecProxyTypes) ToPointer() *MeshTrafficPermissionItemSpecProxyTypes {
	return &e
}
func (e *MeshTrafficPermissionItemSpecProxyTypes) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Sidecar":
		fallthrough
	case "Gateway":
		*e = MeshTrafficPermissionItemSpecProxyTypes(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshTrafficPermissionItemSpecProxyTypes: %v", v)
	}
}

// MeshTrafficPermissionItemSpecTargetRef - TargetRef is a reference to the resource that represents a group of
// clients.
type MeshTrafficPermissionItemSpecTargetRef struct {
	// Kind of the referenced resource
	Kind MeshTrafficPermissionItemSpecKind `json:"kind"`
	// Labels are used to select group of MeshServices that match labels. Either Labels or
	// Name and Namespace can be used.
	Labels map[string]string `json:"labels,omitempty"`
	// Mesh is reserved for future use to identify cross mesh resources.
	Mesh *string `json:"mesh,omitempty"`
	// Name of the referenced resource. Can only be used with kinds: `MeshService`,
	// `MeshServiceSubset` and `MeshGatewayRoute`
	Name *string `json:"name,omitempty"`
	// Namespace specifies the namespace of target resource. If empty only resources in policy namespace
	// will be targeted.
	Namespace *string `json:"namespace,omitempty"`
	// ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
	// all data plane types are targeted by the policy.
	ProxyTypes []MeshTrafficPermissionItemSpecProxyTypes `json:"proxyTypes,omitempty"`
	// SectionName is used to target specific section of resource.
	// For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected.
	SectionName *string `json:"sectionName,omitempty"`
	// Tags used to select a subset of proxies by tags. Can only be used with kinds
	// `MeshSubset` and `MeshServiceSubset`
	Tags map[string]string `json:"tags,omitempty"`
}

func (m *MeshTrafficPermissionItemSpecTargetRef) GetKind() MeshTrafficPermissionItemSpecKind {
	if m == nil {
		return MeshTrafficPermissionItemSpecKind("")
	}
	return m.Kind
}

func (m *MeshTrafficPermissionItemSpecTargetRef) GetLabels() map[string]string {
	if m == nil {
		return nil
	}
	return m.Labels
}

func (m *MeshTrafficPermissionItemSpecTargetRef) GetMesh() *string {
	if m == nil {
		return nil
	}
	return m.Mesh
}

func (m *MeshTrafficPermissionItemSpecTargetRef) GetName() *string {
	if m == nil {
		return nil
	}
	return m.Name
}

func (m *MeshTrafficPermissionItemSpecTargetRef) GetNamespace() *string {
	if m == nil {
		return nil
	}
	return m.Namespace
}

func (m *MeshTrafficPermissionItemSpecTargetRef) GetProxyTypes() []MeshTrafficPermissionItemSpecProxyTypes {
	if m == nil {
		return nil
	}
	return m.ProxyTypes
}

func (m *MeshTrafficPermissionItemSpecTargetRef) GetSectionName() *string {
	if m == nil {
		return nil
	}
	return m.SectionName
}

func (m *MeshTrafficPermissionItemSpecTargetRef) GetTags() map[string]string {
	if m == nil {
		return nil
	}
	return m.Tags
}

type MeshTrafficPermissionItemFrom struct {
	// Default is a configuration specific to the group of clients referenced in
	// 'targetRef'
	Default *MeshTrafficPermissionItemDefault `json:"default,omitempty"`
	// TargetRef is a reference to the resource that represents a group of
	// clients.
	TargetRef MeshTrafficPermissionItemSpecTargetRef `json:"targetRef"`
}

func (m *MeshTrafficPermissionItemFrom) GetDefault() *MeshTrafficPermissionItemDefault {
	if m == nil {
		return nil
	}
	return m.Default
}

func (m *MeshTrafficPermissionItemFrom) GetTargetRef() MeshTrafficPermissionItemSpecTargetRef {
	if m == nil {
		return MeshTrafficPermissionItemSpecTargetRef{}
	}
	return m.TargetRef
}

// MeshTrafficPermissionItemSpecType - Type defines how to match incoming traffic by SpiffeID. `Exact` or `Prefix` are allowed.
type MeshTrafficPermissionItemSpecType string

const (
	MeshTrafficPermissionItemSpecTypeExact  MeshTrafficPermissionItemSpecType = "Exact"
	MeshTrafficPermissionItemSpecTypePrefix MeshTrafficPermissionItemSpecType = "Prefix"
)

func (e MeshTrafficPermissionItemSpecType) ToPointer() *MeshTrafficPermissionItemSpecType {
	return &e
}
func (e *MeshTrafficPermissionItemSpecType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Exact":
		fallthrough
	case "Prefix":
		*e = MeshTrafficPermissionItemSpecType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshTrafficPermissionItemSpecType: %v", v)
	}
}

// MeshTrafficPermissionItemSpiffeID - SpiffeID defines a matcher configuration for SpiffeID matching
type MeshTrafficPermissionItemSpiffeID struct {
	// Type defines how to match incoming traffic by SpiffeID. `Exact` or `Prefix` are allowed.
	Type MeshTrafficPermissionItemSpecType `json:"type"`
	// Value is SpiffeId of a client that needs to match for the configuration to be applied
	Value string `json:"value"`
}

func (m *MeshTrafficPermissionItemSpiffeID) GetType() MeshTrafficPermissionItemSpecType {
	if m == nil {
		return MeshTrafficPermissionItemSpecType("")
	}
	return m.Type
}

func (m *MeshTrafficPermissionItemSpiffeID) GetValue() string {
	if m == nil {
		return ""
	}
	return m.Value
}

type Allow struct {
	// SpiffeID defines a matcher configuration for SpiffeID matching
	SpiffeID *MeshTrafficPermissionItemSpiffeID `json:"spiffeID,omitempty"`
}

func (a *Allow) GetSpiffeID() *MeshTrafficPermissionItemSpiffeID {
	if a == nil {
		return nil
	}
	return a.SpiffeID
}

// MeshTrafficPermissionItemSpecRulesType - Type defines how to match incoming traffic by SpiffeID. `Exact` or `Prefix` are allowed.
type MeshTrafficPermissionItemSpecRulesType string

const (
	MeshTrafficPermissionItemSpecRulesTypeExact  MeshTrafficPermissionItemSpecRulesType = "Exact"
	MeshTrafficPermissionItemSpecRulesTypePrefix MeshTrafficPermissionItemSpecRulesType = "Prefix"
)

func (e MeshTrafficPermissionItemSpecRulesType) ToPointer() *MeshTrafficPermissionItemSpecRulesType {
	return &e
}
func (e *MeshTrafficPermissionItemSpecRulesType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Exact":
		fallthrough
	case "Prefix":
		*e = MeshTrafficPermissionItemSpecRulesType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshTrafficPermissionItemSpecRulesType: %v", v)
	}
}

// MeshTrafficPermissionItemSpecSpiffeID - SpiffeID defines a matcher configuration for SpiffeID matching
type MeshTrafficPermissionItemSpecSpiffeID struct {
	// Type defines how to match incoming traffic by SpiffeID. `Exact` or `Prefix` are allowed.
	Type MeshTrafficPermissionItemSpecRulesType `json:"type"`
	// Value is SpiffeId of a client that needs to match for the configuration to be applied
	Value string `json:"value"`
}

func (m *MeshTrafficPermissionItemSpecSpiffeID) GetType() MeshTrafficPermissionItemSpecRulesType {
	if m == nil {
		return MeshTrafficPermissionItemSpecRulesType("")
	}
	return m.Type
}

func (m *MeshTrafficPermissionItemSpecSpiffeID) GetValue() string {
	if m == nil {
		return ""
	}
	return m.Value
}

type AllowWithShadowDeny struct {
	// SpiffeID defines a matcher configuration for SpiffeID matching
	SpiffeID *MeshTrafficPermissionItemSpecSpiffeID `json:"spiffeID,omitempty"`
}

func (a *AllowWithShadowDeny) GetSpiffeID() *MeshTrafficPermissionItemSpecSpiffeID {
	if a == nil {
		return nil
	}
	return a.SpiffeID
}

// MeshTrafficPermissionItemSpecRulesDefaultType - Type defines how to match incoming traffic by SpiffeID. `Exact` or `Prefix` are allowed.
type MeshTrafficPermissionItemSpecRulesDefaultType string

const (
	MeshTrafficPermissionItemSpecRulesDefaultTypeExact  MeshTrafficPermissionItemSpecRulesDefaultType = "Exact"
	MeshTrafficPermissionItemSpecRulesDefaultTypePrefix MeshTrafficPermissionItemSpecRulesDefaultType = "Prefix"
)

func (e MeshTrafficPermissionItemSpecRulesDefaultType) ToPointer() *MeshTrafficPermissionItemSpecRulesDefaultType {
	return &e
}
func (e *MeshTrafficPermissionItemSpecRulesDefaultType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Exact":
		fallthrough
	case "Prefix":
		*e = MeshTrafficPermissionItemSpecRulesDefaultType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshTrafficPermissionItemSpecRulesDefaultType: %v", v)
	}
}

// MeshTrafficPermissionItemSpecRulesSpiffeID - SpiffeID defines a matcher configuration for SpiffeID matching
type MeshTrafficPermissionItemSpecRulesSpiffeID struct {
	// Type defines how to match incoming traffic by SpiffeID. `Exact` or `Prefix` are allowed.
	Type MeshTrafficPermissionItemSpecRulesDefaultType `json:"type"`
	// Value is SpiffeId of a client that needs to match for the configuration to be applied
	Value string `json:"value"`
}

func (m *MeshTrafficPermissionItemSpecRulesSpiffeID) GetType() MeshTrafficPermissionItemSpecRulesDefaultType {
	if m == nil {
		return MeshTrafficPermissionItemSpecRulesDefaultType("")
	}
	return m.Type
}

func (m *MeshTrafficPermissionItemSpecRulesSpiffeID) GetValue() string {
	if m == nil {
		return ""
	}
	return m.Value
}

type Deny struct {
	// SpiffeID defines a matcher configuration for SpiffeID matching
	SpiffeID *MeshTrafficPermissionItemSpecRulesSpiffeID `json:"spiffeID,omitempty"`
}

func (d *Deny) GetSpiffeID() *MeshTrafficPermissionItemSpecRulesSpiffeID {
	if d == nil {
		return nil
	}
	return d.SpiffeID
}

type MeshTrafficPermissionItemSpecDefault struct {
	// Allow definees a list of matches for which access will be allowed
	Allow []Allow `json:"allow,omitempty"`
	// AllowWithShadowDeny defines a list of matches for which access will be allowed but emits logs as if
	// requests are denied
	AllowWithShadowDeny []AllowWithShadowDeny `json:"allowWithShadowDeny,omitempty"`
	// Deny defines a list of matches for which access will be denied
	Deny []Deny `json:"deny,omitempty"`
}

func (m *MeshTrafficPermissionItemSpecDefault) GetAllow() []Allow {
	if m == nil {
		return nil
	}
	return m.Allow
}

func (m *MeshTrafficPermissionItemSpecDefault) GetAllowWithShadowDeny() []AllowWithShadowDeny {
	if m == nil {
		return nil
	}
	return m.AllowWithShadowDeny
}

func (m *MeshTrafficPermissionItemSpecDefault) GetDeny() []Deny {
	if m == nil {
		return nil
	}
	return m.Deny
}

type MeshTrafficPermissionItemRules struct {
	Default MeshTrafficPermissionItemSpecDefault `json:"default"`
}

func (m *MeshTrafficPermissionItemRules) GetDefault() MeshTrafficPermissionItemSpecDefault {
	if m == nil {
		return MeshTrafficPermissionItemSpecDefault{}
	}
	return m.Default
}

// MeshTrafficPermissionItemKind - Kind of the referenced resource
type MeshTrafficPermissionItemKind string

const (
	MeshTrafficPermissionItemKindMesh                 MeshTrafficPermissionItemKind = "Mesh"
	MeshTrafficPermissionItemKindMeshSubset           MeshTrafficPermissionItemKind = "MeshSubset"
	MeshTrafficPermissionItemKindMeshGateway          MeshTrafficPermissionItemKind = "MeshGateway"
	MeshTrafficPermissionItemKindMeshService          MeshTrafficPermissionItemKind = "MeshService"
	MeshTrafficPermissionItemKindMeshExternalService  MeshTrafficPermissionItemKind = "MeshExternalService"
	MeshTrafficPermissionItemKindMeshMultiZoneService MeshTrafficPermissionItemKind = "MeshMultiZoneService"
	MeshTrafficPermissionItemKindMeshServiceSubset    MeshTrafficPermissionItemKind = "MeshServiceSubset"
	MeshTrafficPermissionItemKindMeshHTTPRoute        MeshTrafficPermissionItemKind = "MeshHTTPRoute"
	MeshTrafficPermissionItemKindDataplane            MeshTrafficPermissionItemKind = "Dataplane"
)

func (e MeshTrafficPermissionItemKind) ToPointer() *MeshTrafficPermissionItemKind {
	return &e
}
func (e *MeshTrafficPermissionItemKind) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Mesh":
		fallthrough
	case "MeshSubset":
		fallthrough
	case "MeshGateway":
		fallthrough
	case "MeshService":
		fallthrough
	case "MeshExternalService":
		fallthrough
	case "MeshMultiZoneService":
		fallthrough
	case "MeshServiceSubset":
		fallthrough
	case "MeshHTTPRoute":
		fallthrough
	case "Dataplane":
		*e = MeshTrafficPermissionItemKind(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshTrafficPermissionItemKind: %v", v)
	}
}

type MeshTrafficPermissionItemProxyTypes string

const (
	MeshTrafficPermissionItemProxyTypesSidecar MeshTrafficPermissionItemProxyTypes = "Sidecar"
	MeshTrafficPermissionItemProxyTypesGateway MeshTrafficPermissionItemProxyTypes = "Gateway"
)

func (e MeshTrafficPermissionItemProxyTypes) ToPointer() *MeshTrafficPermissionItemProxyTypes {
	return &e
}
func (e *MeshTrafficPermissionItemProxyTypes) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Sidecar":
		fallthrough
	case "Gateway":
		*e = MeshTrafficPermissionItemProxyTypes(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshTrafficPermissionItemProxyTypes: %v", v)
	}
}

// MeshTrafficPermissionItemTargetRef - TargetRef is a reference to the resource the policy takes an effect on.
// The resource could be either a real store object or virtual resource
// defined inplace.
type MeshTrafficPermissionItemTargetRef struct {
	// Kind of the referenced resource
	Kind MeshTrafficPermissionItemKind `json:"kind"`
	// Labels are used to select group of MeshServices that match labels. Either Labels or
	// Name and Namespace can be used.
	Labels map[string]string `json:"labels,omitempty"`
	// Mesh is reserved for future use to identify cross mesh resources.
	Mesh *string `json:"mesh,omitempty"`
	// Name of the referenced resource. Can only be used with kinds: `MeshService`,
	// `MeshServiceSubset` and `MeshGatewayRoute`
	Name *string `json:"name,omitempty"`
	// Namespace specifies the namespace of target resource. If empty only resources in policy namespace
	// will be targeted.
	Namespace *string `json:"namespace,omitempty"`
	// ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
	// all data plane types are targeted by the policy.
	ProxyTypes []MeshTrafficPermissionItemProxyTypes `json:"proxyTypes,omitempty"`
	// SectionName is used to target specific section of resource.
	// For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected.
	SectionName *string `json:"sectionName,omitempty"`
	// Tags used to select a subset of proxies by tags. Can only be used with kinds
	// `MeshSubset` and `MeshServiceSubset`
	Tags map[string]string `json:"tags,omitempty"`
}

func (m *MeshTrafficPermissionItemTargetRef) GetKind() MeshTrafficPermissionItemKind {
	if m == nil {
		return MeshTrafficPermissionItemKind("")
	}
	return m.Kind
}

func (m *MeshTrafficPermissionItemTargetRef) GetLabels() map[string]string {
	if m == nil {
		return nil
	}
	return m.Labels
}

func (m *MeshTrafficPermissionItemTargetRef) GetMesh() *string {
	if m == nil {
		return nil
	}
	return m.Mesh
}

func (m *MeshTrafficPermissionItemTargetRef) GetName() *string {
	if m == nil {
		return nil
	}
	return m.Name
}

func (m *MeshTrafficPermissionItemTargetRef) GetNamespace() *string {
	if m == nil {
		return nil
	}
	return m.Namespace
}

func (m *MeshTrafficPermissionItemTargetRef) GetProxyTypes() []MeshTrafficPermissionItemProxyTypes {
	if m == nil {
		return nil
	}
	return m.ProxyTypes
}

func (m *MeshTrafficPermissionItemTargetRef) GetSectionName() *string {
	if m == nil {
		return nil
	}
	return m.SectionName
}

func (m *MeshTrafficPermissionItemTargetRef) GetTags() map[string]string {
	if m == nil {
		return nil
	}
	return m.Tags
}

// MeshTrafficPermissionItemSpec - Spec is the specification of the Kuma MeshTrafficPermission resource.
type MeshTrafficPermissionItemSpec struct {
	// From list makes a match between clients and corresponding configurations
	From []MeshTrafficPermissionItemFrom `json:"from,omitempty"`
	// Rules defines inbound permissions configuration
	Rules []MeshTrafficPermissionItemRules `json:"rules,omitempty"`
	// TargetRef is a reference to the resource the policy takes an effect on.
	// The resource could be either a real store object or virtual resource
	// defined inplace.
	TargetRef *MeshTrafficPermissionItemTargetRef `json:"targetRef,omitempty"`
}

func (m *MeshTrafficPermissionItemSpec) GetFrom() []MeshTrafficPermissionItemFrom {
	if m == nil {
		return nil
	}
	return m.From
}

func (m *MeshTrafficPermissionItemSpec) GetRules() []MeshTrafficPermissionItemRules {
	if m == nil {
		return nil
	}
	return m.Rules
}

func (m *MeshTrafficPermissionItemSpec) GetTargetRef() *MeshTrafficPermissionItemTargetRef {
	if m == nil {
		return nil
	}
	return m.TargetRef
}

// MeshTrafficPermissionItem - Successful response
type MeshTrafficPermissionItem struct {
	// the type of the resource
	Type MeshTrafficPermissionItemType `json:"type"`
	// Mesh is the name of the Kuma mesh this resource belongs to. It may be omitted for cluster-scoped resources.
	Mesh *string `default:"default" json:"mesh"`
	// Name of the Kuma resource
	Name string `json:"name"`
	// The labels to help identity resources
	Labels map[string]string `json:"labels,omitempty"`
	// Spec is the specification of the Kuma MeshTrafficPermission resource.
	Spec MeshTrafficPermissionItemSpec `json:"spec"`
	// Time at which the resource was created
	CreationTime *time.Time `json:"creationTime,omitempty"`
	// Time at which the resource was updated
	ModificationTime *time.Time `json:"modificationTime,omitempty"`
}

func (m MeshTrafficPermissionItem) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(m, "", false)
}

func (m *MeshTrafficPermissionItem) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &m, "", false, []string{"type", "name", "spec"}); err != nil {
		return err
	}
	return nil
}

func (m *MeshTrafficPermissionItem) GetType() MeshTrafficPermissionItemType {
	if m == nil {
		return MeshTrafficPermissionItemType("")
	}
	return m.Type
}

func (m *MeshTrafficPermissionItem) GetMesh() *string {
	if m == nil {
		return nil
	}
	return m.Mesh
}

func (m *MeshTrafficPermissionItem) GetName() string {
	if m == nil {
		return ""
	}
	return m.Name
}

func (m *MeshTrafficPermissionItem) GetLabels() map[string]string {
	if m == nil {
		return nil
	}
	return m.Labels
}

func (m *MeshTrafficPermissionItem) GetSpec() MeshTrafficPermissionItemSpec {
	if m == nil {
		return MeshTrafficPermissionItemSpec{}
	}
	return m.Spec
}

func (m *MeshTrafficPermissionItem) GetCreationTime() *time.Time {
	if m == nil {
		return nil
	}
	return m.CreationTime
}

func (m *MeshTrafficPermissionItem) GetModificationTime() *time.Time {
	if m == nil {
		return nil
	}
	return m.ModificationTime
}

type MeshTrafficPermissionItemInput struct {
	// the type of the resource
	Type MeshTrafficPermissionItemType `json:"type"`
	// Mesh is the name of the Kuma mesh this resource belongs to. It may be omitted for cluster-scoped resources.
	Mesh *string `default:"default" json:"mesh"`
	// Name of the Kuma resource
	Name string `json:"name"`
	// The labels to help identity resources
	Labels map[string]string `json:"labels,omitempty"`
	// Spec is the specification of the Kuma MeshTrafficPermission resource.
	Spec MeshTrafficPermissionItemSpec `json:"spec"`
}

func (m MeshTrafficPermissionItemInput) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(m, "", false)
}

func (m *MeshTrafficPermissionItemInput) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &m, "", false, []string{"type", "name", "spec"}); err != nil {
		return err
	}
	return nil
}

func (m *MeshTrafficPermissionItemInput) GetType() MeshTrafficPermissionItemType {
	if m == nil {
		return MeshTrafficPermissionItemType("")
	}
	return m.Type
}

func (m *MeshTrafficPermissionItemInput) GetMesh() *string {
	if m == nil {
		return nil
	}
	return m.Mesh
}

func (m *MeshTrafficPermissionItemInput) GetName() string {
	if m == nil {
		return ""
	}
	return m.Name
}

func (m *MeshTrafficPermissionItemInput) GetLabels() map[string]string {
	if m == nil {
		return nil
	}
	return m.Labels
}

func (m *MeshTrafficPermissionItemInput) GetSpec() MeshTrafficPermissionItemSpec {
	if m == nil {
		return MeshTrafficPermissionItemSpec{}
	}
	return m.Spec
}
