// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
	"github.com/kong/terraform-provider-kong-mesh/internal/sdk/internal/utils"
	"time"
)

// MeshPassthroughItemType - the type of the resource
type MeshPassthroughItemType string

const (
	MeshPassthroughItemTypeMeshPassthrough MeshPassthroughItemType = "MeshPassthrough"
)

func (e MeshPassthroughItemType) ToPointer() *MeshPassthroughItemType {
	return &e
}
func (e *MeshPassthroughItemType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "MeshPassthrough":
		*e = MeshPassthroughItemType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshPassthroughItemType: %v", v)
	}
}

// MeshPassthroughItemProtocol - Protocol defines the communication protocol. Possible values: `tcp`, `tls`, `grpc`, `http`, `http2`, `mysql`.
type MeshPassthroughItemProtocol string

const (
	MeshPassthroughItemProtocolTCP   MeshPassthroughItemProtocol = "tcp"
	MeshPassthroughItemProtocolTLS   MeshPassthroughItemProtocol = "tls"
	MeshPassthroughItemProtocolGrpc  MeshPassthroughItemProtocol = "grpc"
	MeshPassthroughItemProtocolHTTP  MeshPassthroughItemProtocol = "http"
	MeshPassthroughItemProtocolHttp2 MeshPassthroughItemProtocol = "http2"
	MeshPassthroughItemProtocolMysql MeshPassthroughItemProtocol = "mysql"
)

func (e MeshPassthroughItemProtocol) ToPointer() *MeshPassthroughItemProtocol {
	return &e
}
func (e *MeshPassthroughItemProtocol) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "tcp":
		fallthrough
	case "tls":
		fallthrough
	case "grpc":
		fallthrough
	case "http":
		fallthrough
	case "http2":
		fallthrough
	case "mysql":
		*e = MeshPassthroughItemProtocol(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshPassthroughItemProtocol: %v", v)
	}
}

// MeshPassthroughItemSpecType - Type of the match, one of `Domain`, `IP` or `CIDR` is available.
type MeshPassthroughItemSpecType string

const (
	MeshPassthroughItemSpecTypeDomain MeshPassthroughItemSpecType = "Domain"
	MeshPassthroughItemSpecTypeIP     MeshPassthroughItemSpecType = "IP"
	MeshPassthroughItemSpecTypeCidr   MeshPassthroughItemSpecType = "CIDR"
)

func (e MeshPassthroughItemSpecType) ToPointer() *MeshPassthroughItemSpecType {
	return &e
}
func (e *MeshPassthroughItemSpecType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Domain":
		fallthrough
	case "IP":
		fallthrough
	case "CIDR":
		*e = MeshPassthroughItemSpecType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshPassthroughItemSpecType: %v", v)
	}
}

type AppendMatch struct {
	// Port defines the port to which a user makes a request.
	Port *int `json:"port,omitempty"`
	// Protocol defines the communication protocol. Possible values: `tcp`, `tls`, `grpc`, `http`, `http2`, `mysql`.
	Protocol *MeshPassthroughItemProtocol `default:"tcp" json:"protocol"`
	// Type of the match, one of `Domain`, `IP` or `CIDR` is available.
	Type MeshPassthroughItemSpecType `json:"type"`
	// Value for the specified Type.
	Value string `json:"value"`
}

func (a AppendMatch) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AppendMatch) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, []string{"type", "value"}); err != nil {
		return err
	}
	return nil
}

func (a *AppendMatch) GetPort() *int {
	if a == nil {
		return nil
	}
	return a.Port
}

func (a *AppendMatch) GetProtocol() *MeshPassthroughItemProtocol {
	if a == nil {
		return nil
	}
	return a.Protocol
}

func (a *AppendMatch) GetType() MeshPassthroughItemSpecType {
	if a == nil {
		return MeshPassthroughItemSpecType("")
	}
	return a.Type
}

func (a *AppendMatch) GetValue() string {
	if a == nil {
		return ""
	}
	return a.Value
}

// PassthroughMode - Defines the passthrough behavior. Possible values: `All`, `None`, `Matched`
// When `All` or `None` `appendMatch` has no effect.
// If not specified then the default value is "Matched".
type PassthroughMode string

const (
	PassthroughModeAll     PassthroughMode = "All"
	PassthroughModeMatched PassthroughMode = "Matched"
	PassthroughModeNone    PassthroughMode = "None"
)

func (e PassthroughMode) ToPointer() *PassthroughMode {
	return &e
}
func (e *PassthroughMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "All":
		fallthrough
	case "Matched":
		fallthrough
	case "None":
		*e = PassthroughMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PassthroughMode: %v", v)
	}
}

// MeshPassthroughItemDefault - MeshPassthrough configuration.
type MeshPassthroughItemDefault struct {
	// AppendMatch is a list of destinations that should be allowed through the sidecar.
	AppendMatch []AppendMatch `json:"appendMatch,omitempty"`
	// Defines the passthrough behavior. Possible values: `All`, `None`, `Matched`
	// When `All` or `None` `appendMatch` has no effect.
	// If not specified then the default value is "Matched".
	PassthroughMode *PassthroughMode `json:"passthroughMode,omitempty"`
}

func (m *MeshPassthroughItemDefault) GetAppendMatch() []AppendMatch {
	if m == nil {
		return nil
	}
	return m.AppendMatch
}

func (m *MeshPassthroughItemDefault) GetPassthroughMode() *PassthroughMode {
	if m == nil {
		return nil
	}
	return m.PassthroughMode
}

// MeshPassthroughItemKind - Kind of the referenced resource
type MeshPassthroughItemKind string

const (
	MeshPassthroughItemKindMesh                 MeshPassthroughItemKind = "Mesh"
	MeshPassthroughItemKindMeshSubset           MeshPassthroughItemKind = "MeshSubset"
	MeshPassthroughItemKindMeshGateway          MeshPassthroughItemKind = "MeshGateway"
	MeshPassthroughItemKindMeshService          MeshPassthroughItemKind = "MeshService"
	MeshPassthroughItemKindMeshExternalService  MeshPassthroughItemKind = "MeshExternalService"
	MeshPassthroughItemKindMeshMultiZoneService MeshPassthroughItemKind = "MeshMultiZoneService"
	MeshPassthroughItemKindMeshServiceSubset    MeshPassthroughItemKind = "MeshServiceSubset"
	MeshPassthroughItemKindMeshHTTPRoute        MeshPassthroughItemKind = "MeshHTTPRoute"
	MeshPassthroughItemKindDataplane            MeshPassthroughItemKind = "Dataplane"
)

func (e MeshPassthroughItemKind) ToPointer() *MeshPassthroughItemKind {
	return &e
}
func (e *MeshPassthroughItemKind) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Mesh":
		fallthrough
	case "MeshSubset":
		fallthrough
	case "MeshGateway":
		fallthrough
	case "MeshService":
		fallthrough
	case "MeshExternalService":
		fallthrough
	case "MeshMultiZoneService":
		fallthrough
	case "MeshServiceSubset":
		fallthrough
	case "MeshHTTPRoute":
		fallthrough
	case "Dataplane":
		*e = MeshPassthroughItemKind(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshPassthroughItemKind: %v", v)
	}
}

type MeshPassthroughItemProxyTypes string

const (
	MeshPassthroughItemProxyTypesSidecar MeshPassthroughItemProxyTypes = "Sidecar"
	MeshPassthroughItemProxyTypesGateway MeshPassthroughItemProxyTypes = "Gateway"
)

func (e MeshPassthroughItemProxyTypes) ToPointer() *MeshPassthroughItemProxyTypes {
	return &e
}
func (e *MeshPassthroughItemProxyTypes) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Sidecar":
		fallthrough
	case "Gateway":
		*e = MeshPassthroughItemProxyTypes(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshPassthroughItemProxyTypes: %v", v)
	}
}

// MeshPassthroughItemTargetRef - TargetRef is a reference to the resource the policy takes an effect on.
// The resource could be either a real store object or virtual resource
// defined in-place.
type MeshPassthroughItemTargetRef struct {
	// Kind of the referenced resource
	Kind MeshPassthroughItemKind `json:"kind"`
	// Labels are used to select group of MeshServices that match labels. Either Labels or
	// Name and Namespace can be used.
	Labels map[string]string `json:"labels,omitempty"`
	// Mesh is reserved for future use to identify cross mesh resources.
	Mesh *string `json:"mesh,omitempty"`
	// Name of the referenced resource. Can only be used with kinds: `MeshService`,
	// `MeshServiceSubset` and `MeshGatewayRoute`
	Name *string `json:"name,omitempty"`
	// Namespace specifies the namespace of target resource. If empty only resources in policy namespace
	// will be targeted.
	Namespace *string `json:"namespace,omitempty"`
	// ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
	// all data plane types are targeted by the policy.
	ProxyTypes []MeshPassthroughItemProxyTypes `json:"proxyTypes,omitempty"`
	// SectionName is used to target specific section of resource.
	// For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected.
	SectionName *string `json:"sectionName,omitempty"`
	// Tags used to select a subset of proxies by tags. Can only be used with kinds
	// `MeshSubset` and `MeshServiceSubset`
	Tags map[string]string `json:"tags,omitempty"`
}

func (m *MeshPassthroughItemTargetRef) GetKind() MeshPassthroughItemKind {
	if m == nil {
		return MeshPassthroughItemKind("")
	}
	return m.Kind
}

func (m *MeshPassthroughItemTargetRef) GetLabels() map[string]string {
	if m == nil {
		return nil
	}
	return m.Labels
}

func (m *MeshPassthroughItemTargetRef) GetMesh() *string {
	if m == nil {
		return nil
	}
	return m.Mesh
}

func (m *MeshPassthroughItemTargetRef) GetName() *string {
	if m == nil {
		return nil
	}
	return m.Name
}

func (m *MeshPassthroughItemTargetRef) GetNamespace() *string {
	if m == nil {
		return nil
	}
	return m.Namespace
}

func (m *MeshPassthroughItemTargetRef) GetProxyTypes() []MeshPassthroughItemProxyTypes {
	if m == nil {
		return nil
	}
	return m.ProxyTypes
}

func (m *MeshPassthroughItemTargetRef) GetSectionName() *string {
	if m == nil {
		return nil
	}
	return m.SectionName
}

func (m *MeshPassthroughItemTargetRef) GetTags() map[string]string {
	if m == nil {
		return nil
	}
	return m.Tags
}

// MeshPassthroughItemSpec - Spec is the specification of the Kuma MeshPassthrough resource.
type MeshPassthroughItemSpec struct {
	// MeshPassthrough configuration.
	Default *MeshPassthroughItemDefault `json:"default,omitempty"`
	// TargetRef is a reference to the resource the policy takes an effect on.
	// The resource could be either a real store object or virtual resource
	// defined in-place.
	TargetRef *MeshPassthroughItemTargetRef `json:"targetRef,omitempty"`
}

func (m *MeshPassthroughItemSpec) GetDefault() *MeshPassthroughItemDefault {
	if m == nil {
		return nil
	}
	return m.Default
}

func (m *MeshPassthroughItemSpec) GetTargetRef() *MeshPassthroughItemTargetRef {
	if m == nil {
		return nil
	}
	return m.TargetRef
}

// MeshPassthroughItem - Successful response
type MeshPassthroughItem struct {
	// the type of the resource
	Type MeshPassthroughItemType `json:"type"`
	// Mesh is the name of the Kuma mesh this resource belongs to. It may be omitted for cluster-scoped resources.
	Mesh *string `default:"default" json:"mesh"`
	// Name of the Kuma resource
	Name string `json:"name"`
	// The labels to help identity resources
	Labels map[string]string `json:"labels,omitempty"`
	// Spec is the specification of the Kuma MeshPassthrough resource.
	Spec MeshPassthroughItemSpec `json:"spec"`
	// Time at which the resource was created
	CreationTime *time.Time `json:"creationTime,omitempty"`
	// Time at which the resource was updated
	ModificationTime *time.Time `json:"modificationTime,omitempty"`
}

func (m MeshPassthroughItem) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(m, "", false)
}

func (m *MeshPassthroughItem) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &m, "", false, []string{"type", "name", "spec"}); err != nil {
		return err
	}
	return nil
}

func (m *MeshPassthroughItem) GetType() MeshPassthroughItemType {
	if m == nil {
		return MeshPassthroughItemType("")
	}
	return m.Type
}

func (m *MeshPassthroughItem) GetMesh() *string {
	if m == nil {
		return nil
	}
	return m.Mesh
}

func (m *MeshPassthroughItem) GetName() string {
	if m == nil {
		return ""
	}
	return m.Name
}

func (m *MeshPassthroughItem) GetLabels() map[string]string {
	if m == nil {
		return nil
	}
	return m.Labels
}

func (m *MeshPassthroughItem) GetSpec() MeshPassthroughItemSpec {
	if m == nil {
		return MeshPassthroughItemSpec{}
	}
	return m.Spec
}

func (m *MeshPassthroughItem) GetCreationTime() *time.Time {
	if m == nil {
		return nil
	}
	return m.CreationTime
}

func (m *MeshPassthroughItem) GetModificationTime() *time.Time {
	if m == nil {
		return nil
	}
	return m.ModificationTime
}

type MeshPassthroughItemInput struct {
	// the type of the resource
	Type MeshPassthroughItemType `json:"type"`
	// Mesh is the name of the Kuma mesh this resource belongs to. It may be omitted for cluster-scoped resources.
	Mesh *string `default:"default" json:"mesh"`
	// Name of the Kuma resource
	Name string `json:"name"`
	// The labels to help identity resources
	Labels map[string]string `json:"labels,omitempty"`
	// Spec is the specification of the Kuma MeshPassthrough resource.
	Spec MeshPassthroughItemSpec `json:"spec"`
}

func (m MeshPassthroughItemInput) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(m, "", false)
}

func (m *MeshPassthroughItemInput) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &m, "", false, []string{"type", "name", "spec"}); err != nil {
		return err
	}
	return nil
}

func (m *MeshPassthroughItemInput) GetType() MeshPassthroughItemType {
	if m == nil {
		return MeshPassthroughItemType("")
	}
	return m.Type
}

func (m *MeshPassthroughItemInput) GetMesh() *string {
	if m == nil {
		return nil
	}
	return m.Mesh
}

func (m *MeshPassthroughItemInput) GetName() string {
	if m == nil {
		return ""
	}
	return m.Name
}

func (m *MeshPassthroughItemInput) GetLabels() map[string]string {
	if m == nil {
		return nil
	}
	return m.Labels
}

func (m *MeshPassthroughItemInput) GetSpec() MeshPassthroughItemSpec {
	if m == nil {
		return MeshPassthroughItemSpec{}
	}
	return m.Spec
}
