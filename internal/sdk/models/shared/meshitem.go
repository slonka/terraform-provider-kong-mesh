// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"errors"
	"fmt"
	"github.com/kong/terraform-provider-kong-mesh/internal/sdk/internal/utils"
)

// Requirements - Rules defines a set of rules for data plane proxies to be member of the mesh.
type Requirements struct {
	// Tags defines set of required tags. You can specify '*' in value to
	// require non empty value of tag
	Tags map[string]string `json:"tags,omitempty"`
}

func (r *Requirements) GetTags() map[string]string {
	if r == nil {
		return nil
	}
	return r.Tags
}

// Restrictions - Rules defines a set of rules for data plane proxies to be member of the mesh.
type Restrictions struct {
	// Tags defines set of required tags. You can specify '*' in value to
	// require non empty value of tag
	Tags map[string]string `json:"tags,omitempty"`
}

func (r *Restrictions) GetTags() map[string]string {
	if r == nil {
		return nil
	}
	return r.Tags
}

// DataplaneProxy - DataplaneProxyMembership defines a set of requirements for data plane
// proxies to be a member of the mesh.
type DataplaneProxy struct {
	// Requirements defines a set of requirements that data plane proxies must
	// fulfill in order to join the mesh. A data plane proxy must fulfill at
	// least one requirement in order to join the mesh. Empty list of allowed
	// requirements means that any proxy that is not explicitly denied can join.
	Requirements []Requirements `json:"requirements,omitempty"`
	// Restrictions defines a set of restrictions that data plane proxies cannot
	// fulfill in order to join the mesh. A data plane proxy cannot fulfill any
	// requirement in order to join the mesh.
	// Restrictions takes precedence over requirements.
	Restrictions []Restrictions `json:"restrictions,omitempty"`
}

func (d *DataplaneProxy) GetRequirements() []Requirements {
	if d == nil {
		return nil
	}
	return d.Requirements
}

func (d *DataplaneProxy) GetRestrictions() []Restrictions {
	if d == nil {
		return nil
	}
	return d.Restrictions
}

// Constraints that applies to the mesh and its entities
type Constraints struct {
	// DataplaneProxyMembership defines a set of requirements for data plane
	// proxies to be a member of the mesh.
	DataplaneProxy *DataplaneProxy `json:"dataplaneProxy,omitempty"`
}

func (c *Constraints) GetDataplaneProxy() *DataplaneProxy {
	if c == nil {
		return nil
	}
	return c.DataplaneProxy
}

// TCPLoggingBackendConfig - TcpLoggingBackendConfig defines configuration for TCP based access logs
type TCPLoggingBackendConfig struct {
	// Address to TCP service that will receive logs
	Address *string `json:"address,omitempty"`
}

func (t TCPLoggingBackendConfig) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(t, "", false)
}

func (t *TCPLoggingBackendConfig) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &t, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (t *TCPLoggingBackendConfig) GetAddress() *string {
	if t == nil {
		return nil
	}
	return t.Address
}

// FileLoggingBackendConfig defines configuration for file based access logs
type FileLoggingBackendConfig struct {
	// Path to a file that logs will be written to
	Path *string `json:"path,omitempty"`
}

func (f FileLoggingBackendConfig) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(f, "", false)
}

func (f *FileLoggingBackendConfig) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &f, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (f *FileLoggingBackendConfig) GetPath() *string {
	if f == nil {
		return nil
	}
	return f.Path
}

type MeshItemLoggingConfType string

const (
	MeshItemLoggingConfTypeFileLoggingBackendConfig MeshItemLoggingConfType = "FileLoggingBackendConfig"
	MeshItemLoggingConfTypeTCPLoggingBackendConfig  MeshItemLoggingConfType = "TcpLoggingBackendConfig"
)

type MeshItemLoggingConf struct {
	FileLoggingBackendConfig *FileLoggingBackendConfig `queryParam:"inline,name=conf"`
	TCPLoggingBackendConfig  *TCPLoggingBackendConfig  `queryParam:"inline,name=conf"`

	Type MeshItemLoggingConfType
}

func CreateMeshItemLoggingConfFileLoggingBackendConfig(fileLoggingBackendConfig FileLoggingBackendConfig) MeshItemLoggingConf {
	typ := MeshItemLoggingConfTypeFileLoggingBackendConfig

	return MeshItemLoggingConf{
		FileLoggingBackendConfig: &fileLoggingBackendConfig,
		Type:                     typ,
	}
}

func CreateMeshItemLoggingConfTCPLoggingBackendConfig(tcpLoggingBackendConfig TCPLoggingBackendConfig) MeshItemLoggingConf {
	typ := MeshItemLoggingConfTypeTCPLoggingBackendConfig

	return MeshItemLoggingConf{
		TCPLoggingBackendConfig: &tcpLoggingBackendConfig,
		Type:                    typ,
	}
}

func (u *MeshItemLoggingConf) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var fileLoggingBackendConfig FileLoggingBackendConfig = FileLoggingBackendConfig{}
	if err := utils.UnmarshalJSON(data, &fileLoggingBackendConfig, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  MeshItemLoggingConfTypeFileLoggingBackendConfig,
			Value: &fileLoggingBackendConfig,
		})
	}

	var tcpLoggingBackendConfig TCPLoggingBackendConfig = TCPLoggingBackendConfig{}
	if err := utils.UnmarshalJSON(data, &tcpLoggingBackendConfig, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  MeshItemLoggingConfTypeTCPLoggingBackendConfig,
			Value: &tcpLoggingBackendConfig,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for MeshItemLoggingConf", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestCandidate(candidates)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for MeshItemLoggingConf", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(MeshItemLoggingConfType)
	switch best.Type {
	case MeshItemLoggingConfTypeFileLoggingBackendConfig:
		u.FileLoggingBackendConfig = best.Value.(*FileLoggingBackendConfig)
		return nil
	case MeshItemLoggingConfTypeTCPLoggingBackendConfig:
		u.TCPLoggingBackendConfig = best.Value.(*TCPLoggingBackendConfig)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for MeshItemLoggingConf", string(data))
}

func (u MeshItemLoggingConf) MarshalJSON() ([]byte, error) {
	if u.FileLoggingBackendConfig != nil {
		return utils.MarshalJSON(u.FileLoggingBackendConfig, "", true)
	}

	if u.TCPLoggingBackendConfig != nil {
		return utils.MarshalJSON(u.TCPLoggingBackendConfig, "", true)
	}

	return nil, errors.New("could not marshal union type MeshItemLoggingConf: all fields are null")
}

// Backends - LoggingBackend defines logging backend available to mesh.
type Backends struct {
	Conf *MeshItemLoggingConf `json:"conf,omitempty"`
	// Format of access logs. Placeholders available on
	// https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log
	Format *string `json:"format,omitempty"`
	// Name of the backend, can be then used in Mesh.logging.defaultBackend or in
	// TrafficLogging
	Name *string `json:"name,omitempty"`
	// Type of the backend (Kuma ships with 'tcp' and 'file')
	Type *string `json:"type,omitempty"`
}

func (b *Backends) GetConf() *MeshItemLoggingConf {
	if b == nil {
		return nil
	}
	return b.Conf
}

func (b *Backends) GetFormat() *string {
	if b == nil {
		return nil
	}
	return b.Format
}

func (b *Backends) GetName() *string {
	if b == nil {
		return nil
	}
	return b.Name
}

func (b *Backends) GetType() *string {
	if b == nil {
		return nil
	}
	return b.Type
}

// Logging settings.
// +optional
type Logging struct {
	// List of available logging backends
	Backends []Backends `json:"backends,omitempty"`
	// Name of the default backend
	DefaultBackend *string `json:"defaultBackend,omitempty"`
}

func (l *Logging) GetBackends() []Backends {
	if l == nil {
		return nil
	}
	return l.Backends
}

func (l *Logging) GetDefaultBackend() *string {
	if l == nil {
		return nil
	}
	return l.DefaultBackend
}

type ModeType string

const (
	ModeTypeStr     ModeType = "str"
	ModeTypeInteger ModeType = "integer"
)

type Mode struct {
	Str     *string `queryParam:"inline,name=mode"`
	Integer *int64  `queryParam:"inline,name=mode"`

	Type ModeType
}

func CreateModeStr(str string) Mode {
	typ := ModeTypeStr

	return Mode{
		Str:  &str,
		Type: typ,
	}
}

func CreateModeInteger(integer int64) Mode {
	typ := ModeTypeInteger

	return Mode{
		Integer: &integer,
		Type:    typ,
	}
}

func (u *Mode) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  ModeTypeStr,
			Value: &str,
		})
	}

	var integer int64 = int64(0)
	if err := utils.UnmarshalJSON(data, &integer, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  ModeTypeInteger,
			Value: &integer,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for Mode", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestCandidate(candidates)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for Mode", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(ModeType)
	switch best.Type {
	case ModeTypeStr:
		u.Str = best.Value.(*string)
		return nil
	case ModeTypeInteger:
		u.Integer = best.Value.(*int64)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Mode", string(data))
}

func (u Mode) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Integer != nil {
		return utils.MarshalJSON(u.Integer, "", true)
	}

	return nil, errors.New("could not marshal union type Mode: all fields are null")
}

type MeshServices struct {
	Mode *Mode `json:"mode,omitempty"`
}

func (m *MeshServices) GetMode() *Mode {
	if m == nil {
		return nil
	}
	return m.Mode
}

// Aggregate - PrometheusAggregateMetricsConfig defines endpoints that should be scrapped by kuma-dp for prometheus metrics.
type Aggregate struct {
	// Address on which a service expose HTTP endpoint with Prometheus metrics.
	Address *string `json:"address,omitempty"`
	// If false then the application won't be scrapped. If nil, then it is treated
	// as true and kuma-dp scrapes metrics from the service.
	Enabled *bool `json:"enabled,omitempty"`
	// Name which identify given configuration.
	Name *string `json:"name,omitempty"`
	// Path on which a service expose HTTP endpoint with Prometheus metrics.
	Path *string `json:"path,omitempty"`
	// Port on which a service expose HTTP endpoint with Prometheus metrics.
	Port *int64 `json:"port,omitempty"`
}

func (a Aggregate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *Aggregate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (a *Aggregate) GetAddress() *string {
	if a == nil {
		return nil
	}
	return a.Address
}

func (a *Aggregate) GetEnabled() *bool {
	if a == nil {
		return nil
	}
	return a.Enabled
}

func (a *Aggregate) GetName() *string {
	if a == nil {
		return nil
	}
	return a.Name
}

func (a *Aggregate) GetPath() *string {
	if a == nil {
		return nil
	}
	return a.Path
}

func (a *Aggregate) GetPort() *int64 {
	if a == nil {
		return nil
	}
	return a.Port
}

// Envoy - Configuration of Envoy's metrics.
type Envoy struct {
	// FilterRegex value that is going to be passed to Envoy for filtering
	// Envoy metrics.
	FilterRegex *string `json:"filterRegex,omitempty"`
	// If true then return metrics that Envoy has updated (counters incremented
	// at least once, gauges changed at least once, and histograms added to at
	// least once). If nil, then it is treated as false.
	UsedOnly *bool `json:"usedOnly,omitempty"`
}

func (e Envoy) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(e, "", false)
}

func (e *Envoy) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &e, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (e *Envoy) GetFilterRegex() *string {
	if e == nil {
		return nil
	}
	return e.FilterRegex
}

func (e *Envoy) GetUsedOnly() *bool {
	if e == nil {
		return nil
	}
	return e.UsedOnly
}

type ConfModeType string

const (
	ConfModeTypeStr     ConfModeType = "str"
	ConfModeTypeInteger ConfModeType = "integer"
)

// ConfMode - mode defines how configured is the TLS for Prometheus.
// Supported values, delegated, disabled, activeMTLSBackend. Default to
// `activeMTLSBackend`.
type ConfMode struct {
	Str     *string `queryParam:"inline,name=mode"`
	Integer *int64  `queryParam:"inline,name=mode"`

	Type ConfModeType
}

func CreateConfModeStr(str string) ConfMode {
	typ := ConfModeTypeStr

	return ConfMode{
		Str:  &str,
		Type: typ,
	}
}

func CreateConfModeInteger(integer int64) ConfMode {
	typ := ConfModeTypeInteger

	return ConfMode{
		Integer: &integer,
		Type:    typ,
	}
}

func (u *ConfMode) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  ConfModeTypeStr,
			Value: &str,
		})
	}

	var integer int64 = int64(0)
	if err := utils.UnmarshalJSON(data, &integer, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  ConfModeTypeInteger,
			Value: &integer,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for ConfMode", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestCandidate(candidates)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for ConfMode", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(ConfModeType)
	switch best.Type {
	case ConfModeTypeStr:
		u.Str = best.Value.(*string)
		return nil
	case ConfModeTypeInteger:
		u.Integer = best.Value.(*int64)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ConfMode", string(data))
}

func (u ConfMode) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Integer != nil {
		return utils.MarshalJSON(u.Integer, "", true)
	}

	return nil, errors.New("could not marshal union type ConfMode: all fields are null")
}

// ConfTLS - Configuration of TLS for prometheus listener.
type ConfTLS struct {
	// mode defines how configured is the TLS for Prometheus.
	// Supported values, delegated, disabled, activeMTLSBackend. Default to
	// `activeMTLSBackend`.
	Mode *ConfMode `json:"mode,omitempty"`
}

func (c ConfTLS) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *ConfTLS) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *ConfTLS) GetMode() *ConfMode {
	if c == nil {
		return nil
	}
	return c.Mode
}

// PrometheusMetricsBackendConfig defines configuration of Prometheus backend
type PrometheusMetricsBackendConfig struct {
	// Map with the configuration of applications which metrics are going to be
	// scrapped by kuma-dp.
	Aggregate []Aggregate `json:"aggregate,omitempty"`
	// Configuration of Envoy's metrics.
	Envoy *Envoy `json:"envoy,omitempty"`
	// Path on which a dataplane should expose HTTP endpoint with Prometheus
	// metrics.
	Path *string `json:"path,omitempty"`
	// Port on which a dataplane should expose HTTP endpoint with Prometheus
	// metrics.
	Port *int64 `json:"port,omitempty"`
	// If true then endpoints for scraping metrics won't require mTLS even if mTLS
	// is enabled in Mesh. If nil, then it is treated as false.
	SkipMTLS *bool `json:"skipMTLS,omitempty"`
	// Tags associated with an application this dataplane is deployed next to,
	// e.g. service=web, version=1.0.
	// `service` tag is mandatory.
	Tags map[string]string `json:"tags,omitempty"`
	// Configuration of TLS for prometheus listener.
	TLS *ConfTLS `json:"tls,omitempty"`
}

func (p PrometheusMetricsBackendConfig) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *PrometheusMetricsBackendConfig) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (p *PrometheusMetricsBackendConfig) GetAggregate() []Aggregate {
	if p == nil {
		return nil
	}
	return p.Aggregate
}

func (p *PrometheusMetricsBackendConfig) GetEnvoy() *Envoy {
	if p == nil {
		return nil
	}
	return p.Envoy
}

func (p *PrometheusMetricsBackendConfig) GetPath() *string {
	if p == nil {
		return nil
	}
	return p.Path
}

func (p *PrometheusMetricsBackendConfig) GetPort() *int64 {
	if p == nil {
		return nil
	}
	return p.Port
}

func (p *PrometheusMetricsBackendConfig) GetSkipMTLS() *bool {
	if p == nil {
		return nil
	}
	return p.SkipMTLS
}

func (p *PrometheusMetricsBackendConfig) GetTags() map[string]string {
	if p == nil {
		return nil
	}
	return p.Tags
}

func (p *PrometheusMetricsBackendConfig) GetTLS() *ConfTLS {
	if p == nil {
		return nil
	}
	return p.TLS
}

type MeshItemConfType string

const (
	MeshItemConfTypePrometheusMetricsBackendConfig MeshItemConfType = "PrometheusMetricsBackendConfig"
)

type MeshItemConf struct {
	PrometheusMetricsBackendConfig *PrometheusMetricsBackendConfig `queryParam:"inline,name=conf"`

	Type MeshItemConfType
}

func CreateMeshItemConfPrometheusMetricsBackendConfig(prometheusMetricsBackendConfig PrometheusMetricsBackendConfig) MeshItemConf {
	typ := MeshItemConfTypePrometheusMetricsBackendConfig

	return MeshItemConf{
		PrometheusMetricsBackendConfig: &prometheusMetricsBackendConfig,
		Type:                           typ,
	}
}

func (u *MeshItemConf) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var prometheusMetricsBackendConfig PrometheusMetricsBackendConfig = PrometheusMetricsBackendConfig{}
	if err := utils.UnmarshalJSON(data, &prometheusMetricsBackendConfig, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  MeshItemConfTypePrometheusMetricsBackendConfig,
			Value: &prometheusMetricsBackendConfig,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for MeshItemConf", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestCandidate(candidates)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for MeshItemConf", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(MeshItemConfType)
	switch best.Type {
	case MeshItemConfTypePrometheusMetricsBackendConfig:
		u.PrometheusMetricsBackendConfig = best.Value.(*PrometheusMetricsBackendConfig)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for MeshItemConf", string(data))
}

func (u MeshItemConf) MarshalJSON() ([]byte, error) {
	if u.PrometheusMetricsBackendConfig != nil {
		return utils.MarshalJSON(u.PrometheusMetricsBackendConfig, "", true)
	}

	return nil, errors.New("could not marshal union type MeshItemConf: all fields are null")
}

// MeshItemBackends - MetricsBackend defines metric backends
type MeshItemBackends struct {
	Conf *MeshItemConf `json:"conf,omitempty"`
	// Name of the backend, can be then used in Mesh.metrics.enabledBackend
	Name *string `json:"name,omitempty"`
	// Type of the backend (Kuma ships with 'prometheus')
	Type *string `json:"type,omitempty"`
}

func (m *MeshItemBackends) GetConf() *MeshItemConf {
	if m == nil {
		return nil
	}
	return m.Conf
}

func (m *MeshItemBackends) GetName() *string {
	if m == nil {
		return nil
	}
	return m.Name
}

func (m *MeshItemBackends) GetType() *string {
	if m == nil {
		return nil
	}
	return m.Type
}

// Metrics - Configuration for metrics collected and exposed by dataplanes.
//
// Settings defined here become defaults for every dataplane in a given Mesh.
// Additionally, it is also possible to further customize this configuration
// for each dataplane individually using Dataplane resource.
// +optional
type Metrics struct {
	// List of available Metrics backends
	Backends []MeshItemBackends `json:"backends,omitempty"`
	// Name of the enabled backend
	EnabledBackend *string `json:"enabledBackend,omitempty"`
}

func (m *Metrics) GetBackends() []MeshItemBackends {
	if m == nil {
		return nil
	}
	return m.Backends
}

func (m *Metrics) GetEnabledBackend() *string {
	if m == nil {
		return nil
	}
	return m.EnabledBackend
}

type CertManagerCertificateAuthorityConfigCaCertDataSourceSecret struct {
	// Data source is a secret with given Secret key.
	Secret *string `json:"secret,omitempty"`
}

func (c CertManagerCertificateAuthorityConfigCaCertDataSourceSecret) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CertManagerCertificateAuthorityConfigCaCertDataSourceSecret) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CertManagerCertificateAuthorityConfigCaCertDataSourceSecret) GetSecret() *string {
	if c == nil {
		return nil
	}
	return c.Secret
}

type CertManagerCertificateAuthorityConfigCaCertDataSourceInlineString struct {
	// Data source is inline string
	InlineString *string `json:"inlineString,omitempty"`
}

func (c CertManagerCertificateAuthorityConfigCaCertDataSourceInlineString) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CertManagerCertificateAuthorityConfigCaCertDataSourceInlineString) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CertManagerCertificateAuthorityConfigCaCertDataSourceInlineString) GetInlineString() *string {
	if c == nil {
		return nil
	}
	return c.InlineString
}

type CertManagerCertificateAuthorityConfigCaCertDataSourceInline struct {
	// Data source is inline bytes.
	Inline *string `json:"inline,omitempty"`
}

func (c CertManagerCertificateAuthorityConfigCaCertDataSourceInline) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CertManagerCertificateAuthorityConfigCaCertDataSourceInline) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CertManagerCertificateAuthorityConfigCaCertDataSourceInline) GetInline() *string {
	if c == nil {
		return nil
	}
	return c.Inline
}

type CertManagerCertificateAuthorityConfigCaCertDataSourceFile struct {
	// Data source is a path to a file.
	// Deprecated, use other sources of a data.
	File *string `json:"file,omitempty"`
}

func (c CertManagerCertificateAuthorityConfigCaCertDataSourceFile) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CertManagerCertificateAuthorityConfigCaCertDataSourceFile) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CertManagerCertificateAuthorityConfigCaCertDataSourceFile) GetFile() *string {
	if c == nil {
		return nil
	}
	return c.File
}

type CertManagerCertificateAuthorityConfigConfCaCertType string

const (
	CertManagerCertificateAuthorityConfigConfCaCertTypeCertManagerCertificateAuthorityConfigCaCertDataSourceFile         CertManagerCertificateAuthorityConfigConfCaCertType = "CertManagerCertificateAuthorityConfig_caCert_DataSource_File"
	CertManagerCertificateAuthorityConfigConfCaCertTypeCertManagerCertificateAuthorityConfigCaCertDataSourceInline       CertManagerCertificateAuthorityConfigConfCaCertType = "CertManagerCertificateAuthorityConfig_caCert_DataSource_Inline"
	CertManagerCertificateAuthorityConfigConfCaCertTypeCertManagerCertificateAuthorityConfigCaCertDataSourceInlineString CertManagerCertificateAuthorityConfigConfCaCertType = "CertManagerCertificateAuthorityConfig_caCert_DataSource_InlineString"
	CertManagerCertificateAuthorityConfigConfCaCertTypeCertManagerCertificateAuthorityConfigCaCertDataSourceSecret       CertManagerCertificateAuthorityConfigConfCaCertType = "CertManagerCertificateAuthorityConfig_caCert_DataSource_Secret"
)

type CertManagerCertificateAuthorityConfigConfCaCert struct {
	CertManagerCertificateAuthorityConfigCaCertDataSourceFile         *CertManagerCertificateAuthorityConfigCaCertDataSourceFile         `queryParam:"inline,name=caCert"`
	CertManagerCertificateAuthorityConfigCaCertDataSourceInline       *CertManagerCertificateAuthorityConfigCaCertDataSourceInline       `queryParam:"inline,name=caCert"`
	CertManagerCertificateAuthorityConfigCaCertDataSourceInlineString *CertManagerCertificateAuthorityConfigCaCertDataSourceInlineString `queryParam:"inline,name=caCert"`
	CertManagerCertificateAuthorityConfigCaCertDataSourceSecret       *CertManagerCertificateAuthorityConfigCaCertDataSourceSecret       `queryParam:"inline,name=caCert"`

	Type CertManagerCertificateAuthorityConfigConfCaCertType
}

func CreateCertManagerCertificateAuthorityConfigConfCaCertCertManagerCertificateAuthorityConfigCaCertDataSourceFile(certManagerCertificateAuthorityConfigCaCertDataSourceFile CertManagerCertificateAuthorityConfigCaCertDataSourceFile) CertManagerCertificateAuthorityConfigConfCaCert {
	typ := CertManagerCertificateAuthorityConfigConfCaCertTypeCertManagerCertificateAuthorityConfigCaCertDataSourceFile

	return CertManagerCertificateAuthorityConfigConfCaCert{
		CertManagerCertificateAuthorityConfigCaCertDataSourceFile: &certManagerCertificateAuthorityConfigCaCertDataSourceFile,
		Type: typ,
	}
}

func CreateCertManagerCertificateAuthorityConfigConfCaCertCertManagerCertificateAuthorityConfigCaCertDataSourceInline(certManagerCertificateAuthorityConfigCaCertDataSourceInline CertManagerCertificateAuthorityConfigCaCertDataSourceInline) CertManagerCertificateAuthorityConfigConfCaCert {
	typ := CertManagerCertificateAuthorityConfigConfCaCertTypeCertManagerCertificateAuthorityConfigCaCertDataSourceInline

	return CertManagerCertificateAuthorityConfigConfCaCert{
		CertManagerCertificateAuthorityConfigCaCertDataSourceInline: &certManagerCertificateAuthorityConfigCaCertDataSourceInline,
		Type: typ,
	}
}

func CreateCertManagerCertificateAuthorityConfigConfCaCertCertManagerCertificateAuthorityConfigCaCertDataSourceInlineString(certManagerCertificateAuthorityConfigCaCertDataSourceInlineString CertManagerCertificateAuthorityConfigCaCertDataSourceInlineString) CertManagerCertificateAuthorityConfigConfCaCert {
	typ := CertManagerCertificateAuthorityConfigConfCaCertTypeCertManagerCertificateAuthorityConfigCaCertDataSourceInlineString

	return CertManagerCertificateAuthorityConfigConfCaCert{
		CertManagerCertificateAuthorityConfigCaCertDataSourceInlineString: &certManagerCertificateAuthorityConfigCaCertDataSourceInlineString,
		Type: typ,
	}
}

func CreateCertManagerCertificateAuthorityConfigConfCaCertCertManagerCertificateAuthorityConfigCaCertDataSourceSecret(certManagerCertificateAuthorityConfigCaCertDataSourceSecret CertManagerCertificateAuthorityConfigCaCertDataSourceSecret) CertManagerCertificateAuthorityConfigConfCaCert {
	typ := CertManagerCertificateAuthorityConfigConfCaCertTypeCertManagerCertificateAuthorityConfigCaCertDataSourceSecret

	return CertManagerCertificateAuthorityConfigConfCaCert{
		CertManagerCertificateAuthorityConfigCaCertDataSourceSecret: &certManagerCertificateAuthorityConfigCaCertDataSourceSecret,
		Type: typ,
	}
}

func (u *CertManagerCertificateAuthorityConfigConfCaCert) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var certManagerCertificateAuthorityConfigCaCertDataSourceFile CertManagerCertificateAuthorityConfigCaCertDataSourceFile = CertManagerCertificateAuthorityConfigCaCertDataSourceFile{}
	if err := utils.UnmarshalJSON(data, &certManagerCertificateAuthorityConfigCaCertDataSourceFile, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  CertManagerCertificateAuthorityConfigConfCaCertTypeCertManagerCertificateAuthorityConfigCaCertDataSourceFile,
			Value: &certManagerCertificateAuthorityConfigCaCertDataSourceFile,
		})
	}

	var certManagerCertificateAuthorityConfigCaCertDataSourceInline CertManagerCertificateAuthorityConfigCaCertDataSourceInline = CertManagerCertificateAuthorityConfigCaCertDataSourceInline{}
	if err := utils.UnmarshalJSON(data, &certManagerCertificateAuthorityConfigCaCertDataSourceInline, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  CertManagerCertificateAuthorityConfigConfCaCertTypeCertManagerCertificateAuthorityConfigCaCertDataSourceInline,
			Value: &certManagerCertificateAuthorityConfigCaCertDataSourceInline,
		})
	}

	var certManagerCertificateAuthorityConfigCaCertDataSourceInlineString CertManagerCertificateAuthorityConfigCaCertDataSourceInlineString = CertManagerCertificateAuthorityConfigCaCertDataSourceInlineString{}
	if err := utils.UnmarshalJSON(data, &certManagerCertificateAuthorityConfigCaCertDataSourceInlineString, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  CertManagerCertificateAuthorityConfigConfCaCertTypeCertManagerCertificateAuthorityConfigCaCertDataSourceInlineString,
			Value: &certManagerCertificateAuthorityConfigCaCertDataSourceInlineString,
		})
	}

	var certManagerCertificateAuthorityConfigCaCertDataSourceSecret CertManagerCertificateAuthorityConfigCaCertDataSourceSecret = CertManagerCertificateAuthorityConfigCaCertDataSourceSecret{}
	if err := utils.UnmarshalJSON(data, &certManagerCertificateAuthorityConfigCaCertDataSourceSecret, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  CertManagerCertificateAuthorityConfigConfCaCertTypeCertManagerCertificateAuthorityConfigCaCertDataSourceSecret,
			Value: &certManagerCertificateAuthorityConfigCaCertDataSourceSecret,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for CertManagerCertificateAuthorityConfigConfCaCert", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestCandidate(candidates)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for CertManagerCertificateAuthorityConfigConfCaCert", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(CertManagerCertificateAuthorityConfigConfCaCertType)
	switch best.Type {
	case CertManagerCertificateAuthorityConfigConfCaCertTypeCertManagerCertificateAuthorityConfigCaCertDataSourceFile:
		u.CertManagerCertificateAuthorityConfigCaCertDataSourceFile = best.Value.(*CertManagerCertificateAuthorityConfigCaCertDataSourceFile)
		return nil
	case CertManagerCertificateAuthorityConfigConfCaCertTypeCertManagerCertificateAuthorityConfigCaCertDataSourceInline:
		u.CertManagerCertificateAuthorityConfigCaCertDataSourceInline = best.Value.(*CertManagerCertificateAuthorityConfigCaCertDataSourceInline)
		return nil
	case CertManagerCertificateAuthorityConfigConfCaCertTypeCertManagerCertificateAuthorityConfigCaCertDataSourceInlineString:
		u.CertManagerCertificateAuthorityConfigCaCertDataSourceInlineString = best.Value.(*CertManagerCertificateAuthorityConfigCaCertDataSourceInlineString)
		return nil
	case CertManagerCertificateAuthorityConfigConfCaCertTypeCertManagerCertificateAuthorityConfigCaCertDataSourceSecret:
		u.CertManagerCertificateAuthorityConfigCaCertDataSourceSecret = best.Value.(*CertManagerCertificateAuthorityConfigCaCertDataSourceSecret)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for CertManagerCertificateAuthorityConfigConfCaCert", string(data))
}

func (u CertManagerCertificateAuthorityConfigConfCaCert) MarshalJSON() ([]byte, error) {
	if u.CertManagerCertificateAuthorityConfigCaCertDataSourceFile != nil {
		return utils.MarshalJSON(u.CertManagerCertificateAuthorityConfigCaCertDataSourceFile, "", true)
	}

	if u.CertManagerCertificateAuthorityConfigCaCertDataSourceInline != nil {
		return utils.MarshalJSON(u.CertManagerCertificateAuthorityConfigCaCertDataSourceInline, "", true)
	}

	if u.CertManagerCertificateAuthorityConfigCaCertDataSourceInlineString != nil {
		return utils.MarshalJSON(u.CertManagerCertificateAuthorityConfigCaCertDataSourceInlineString, "", true)
	}

	if u.CertManagerCertificateAuthorityConfigCaCertDataSourceSecret != nil {
		return utils.MarshalJSON(u.CertManagerCertificateAuthorityConfigCaCertDataSourceSecret, "", true)
	}

	return nil, errors.New("could not marshal union type CertManagerCertificateAuthorityConfigConfCaCert: all fields are null")
}

type IssuerRef struct {
	Group *string `json:"group,omitempty"`
	Kind  *string `json:"kind,omitempty"`
	Name  *string `json:"name,omitempty"`
}

func (i IssuerRef) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *IssuerRef) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (i *IssuerRef) GetGroup() *string {
	if i == nil {
		return nil
	}
	return i.Group
}

func (i *IssuerRef) GetKind() *string {
	if i == nil {
		return nil
	}
	return i.Kind
}

func (i *IssuerRef) GetName() *string {
	if i == nil {
		return nil
	}
	return i.Name
}

type CertManagerCertificateAuthorityConfig struct {
	CaCert     *CertManagerCertificateAuthorityConfigConfCaCert `json:"caCert,omitempty"`
	CommonName *string                                          `json:"commonName,omitempty"`
	DNSNames   []string                                         `json:"dnsNames,omitempty"`
	IssuerRef  *IssuerRef                                       `json:"issuerRef,omitempty"`
}

func (c CertManagerCertificateAuthorityConfig) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CertManagerCertificateAuthorityConfig) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CertManagerCertificateAuthorityConfig) GetCaCert() *CertManagerCertificateAuthorityConfigConfCaCert {
	if c == nil {
		return nil
	}
	return c.CaCert
}

func (c *CertManagerCertificateAuthorityConfig) GetCommonName() *string {
	if c == nil {
		return nil
	}
	return c.CommonName
}

func (c *CertManagerCertificateAuthorityConfig) GetDNSNames() []string {
	if c == nil {
		return nil
	}
	return c.DNSNames
}

func (c *CertManagerCertificateAuthorityConfig) GetIssuerRef() *IssuerRef {
	if c == nil {
		return nil
	}
	return c.IssuerRef
}

type AccessKeyDataSourceSecret struct {
	// Data source is a secret with given Secret key.
	Secret *string `json:"secret,omitempty"`
}

func (a AccessKeyDataSourceSecret) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AccessKeyDataSourceSecret) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (a *AccessKeyDataSourceSecret) GetSecret() *string {
	if a == nil {
		return nil
	}
	return a.Secret
}

type AccessKeyDataSourceInlineString struct {
	// Data source is inline string
	InlineString *string `json:"inlineString,omitempty"`
}

func (a AccessKeyDataSourceInlineString) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AccessKeyDataSourceInlineString) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (a *AccessKeyDataSourceInlineString) GetInlineString() *string {
	if a == nil {
		return nil
	}
	return a.InlineString
}

type AccessKeyDataSourceInline struct {
	// Data source is inline bytes.
	Inline *string `json:"inline,omitempty"`
}

func (a AccessKeyDataSourceInline) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AccessKeyDataSourceInline) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (a *AccessKeyDataSourceInline) GetInline() *string {
	if a == nil {
		return nil
	}
	return a.Inline
}

type AccessKeyDataSourceFile struct {
	// Data source is a path to a file.
	// Deprecated, use other sources of a data.
	File *string `json:"file,omitempty"`
}

func (a AccessKeyDataSourceFile) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AccessKeyDataSourceFile) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (a *AccessKeyDataSourceFile) GetFile() *string {
	if a == nil {
		return nil
	}
	return a.File
}

type AccessKeyType string

const (
	AccessKeyTypeAccessKeyDataSourceFile         AccessKeyType = "accessKey_DataSource_File"
	AccessKeyTypeAccessKeyDataSourceInline       AccessKeyType = "accessKey_DataSource_Inline"
	AccessKeyTypeAccessKeyDataSourceInlineString AccessKeyType = "accessKey_DataSource_InlineString"
	AccessKeyTypeAccessKeyDataSourceSecret       AccessKeyType = "accessKey_DataSource_Secret"
)

type AccessKey struct {
	AccessKeyDataSourceFile         *AccessKeyDataSourceFile         `queryParam:"inline,name=accessKey"`
	AccessKeyDataSourceInline       *AccessKeyDataSourceInline       `queryParam:"inline,name=accessKey"`
	AccessKeyDataSourceInlineString *AccessKeyDataSourceInlineString `queryParam:"inline,name=accessKey"`
	AccessKeyDataSourceSecret       *AccessKeyDataSourceSecret       `queryParam:"inline,name=accessKey"`

	Type AccessKeyType
}

func CreateAccessKeyAccessKeyDataSourceFile(accessKeyDataSourceFile AccessKeyDataSourceFile) AccessKey {
	typ := AccessKeyTypeAccessKeyDataSourceFile

	return AccessKey{
		AccessKeyDataSourceFile: &accessKeyDataSourceFile,
		Type:                    typ,
	}
}

func CreateAccessKeyAccessKeyDataSourceInline(accessKeyDataSourceInline AccessKeyDataSourceInline) AccessKey {
	typ := AccessKeyTypeAccessKeyDataSourceInline

	return AccessKey{
		AccessKeyDataSourceInline: &accessKeyDataSourceInline,
		Type:                      typ,
	}
}

func CreateAccessKeyAccessKeyDataSourceInlineString(accessKeyDataSourceInlineString AccessKeyDataSourceInlineString) AccessKey {
	typ := AccessKeyTypeAccessKeyDataSourceInlineString

	return AccessKey{
		AccessKeyDataSourceInlineString: &accessKeyDataSourceInlineString,
		Type:                            typ,
	}
}

func CreateAccessKeyAccessKeyDataSourceSecret(accessKeyDataSourceSecret AccessKeyDataSourceSecret) AccessKey {
	typ := AccessKeyTypeAccessKeyDataSourceSecret

	return AccessKey{
		AccessKeyDataSourceSecret: &accessKeyDataSourceSecret,
		Type:                      typ,
	}
}

func (u *AccessKey) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var accessKeyDataSourceFile AccessKeyDataSourceFile = AccessKeyDataSourceFile{}
	if err := utils.UnmarshalJSON(data, &accessKeyDataSourceFile, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  AccessKeyTypeAccessKeyDataSourceFile,
			Value: &accessKeyDataSourceFile,
		})
	}

	var accessKeyDataSourceInline AccessKeyDataSourceInline = AccessKeyDataSourceInline{}
	if err := utils.UnmarshalJSON(data, &accessKeyDataSourceInline, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  AccessKeyTypeAccessKeyDataSourceInline,
			Value: &accessKeyDataSourceInline,
		})
	}

	var accessKeyDataSourceInlineString AccessKeyDataSourceInlineString = AccessKeyDataSourceInlineString{}
	if err := utils.UnmarshalJSON(data, &accessKeyDataSourceInlineString, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  AccessKeyTypeAccessKeyDataSourceInlineString,
			Value: &accessKeyDataSourceInlineString,
		})
	}

	var accessKeyDataSourceSecret AccessKeyDataSourceSecret = AccessKeyDataSourceSecret{}
	if err := utils.UnmarshalJSON(data, &accessKeyDataSourceSecret, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  AccessKeyTypeAccessKeyDataSourceSecret,
			Value: &accessKeyDataSourceSecret,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for AccessKey", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestCandidate(candidates)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for AccessKey", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(AccessKeyType)
	switch best.Type {
	case AccessKeyTypeAccessKeyDataSourceFile:
		u.AccessKeyDataSourceFile = best.Value.(*AccessKeyDataSourceFile)
		return nil
	case AccessKeyTypeAccessKeyDataSourceInline:
		u.AccessKeyDataSourceInline = best.Value.(*AccessKeyDataSourceInline)
		return nil
	case AccessKeyTypeAccessKeyDataSourceInlineString:
		u.AccessKeyDataSourceInlineString = best.Value.(*AccessKeyDataSourceInlineString)
		return nil
	case AccessKeyTypeAccessKeyDataSourceSecret:
		u.AccessKeyDataSourceSecret = best.Value.(*AccessKeyDataSourceSecret)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for AccessKey", string(data))
}

func (u AccessKey) MarshalJSON() ([]byte, error) {
	if u.AccessKeyDataSourceFile != nil {
		return utils.MarshalJSON(u.AccessKeyDataSourceFile, "", true)
	}

	if u.AccessKeyDataSourceInline != nil {
		return utils.MarshalJSON(u.AccessKeyDataSourceInline, "", true)
	}

	if u.AccessKeyDataSourceInlineString != nil {
		return utils.MarshalJSON(u.AccessKeyDataSourceInlineString, "", true)
	}

	if u.AccessKeyDataSourceSecret != nil {
		return utils.MarshalJSON(u.AccessKeyDataSourceSecret, "", true)
	}

	return nil, errors.New("could not marshal union type AccessKey: all fields are null")
}

type AccessKeySecretDataSourceSecret struct {
	// Data source is a secret with given Secret key.
	Secret *string `json:"secret,omitempty"`
}

func (a AccessKeySecretDataSourceSecret) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AccessKeySecretDataSourceSecret) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (a *AccessKeySecretDataSourceSecret) GetSecret() *string {
	if a == nil {
		return nil
	}
	return a.Secret
}

type AccessKeySecretDataSourceInlineString struct {
	// Data source is inline string
	InlineString *string `json:"inlineString,omitempty"`
}

func (a AccessKeySecretDataSourceInlineString) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AccessKeySecretDataSourceInlineString) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (a *AccessKeySecretDataSourceInlineString) GetInlineString() *string {
	if a == nil {
		return nil
	}
	return a.InlineString
}

type AccessKeySecretDataSourceInline struct {
	// Data source is inline bytes.
	Inline *string `json:"inline,omitempty"`
}

func (a AccessKeySecretDataSourceInline) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AccessKeySecretDataSourceInline) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (a *AccessKeySecretDataSourceInline) GetInline() *string {
	if a == nil {
		return nil
	}
	return a.Inline
}

type AccessKeySecretDataSourceFile struct {
	// Data source is a path to a file.
	// Deprecated, use other sources of a data.
	File *string `json:"file,omitempty"`
}

func (a AccessKeySecretDataSourceFile) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AccessKeySecretDataSourceFile) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (a *AccessKeySecretDataSourceFile) GetFile() *string {
	if a == nil {
		return nil
	}
	return a.File
}

type AccessKeySecretType string

const (
	AccessKeySecretTypeAccessKeySecretDataSourceFile         AccessKeySecretType = "accessKeySecret_DataSource_File"
	AccessKeySecretTypeAccessKeySecretDataSourceInline       AccessKeySecretType = "accessKeySecret_DataSource_Inline"
	AccessKeySecretTypeAccessKeySecretDataSourceInlineString AccessKeySecretType = "accessKeySecret_DataSource_InlineString"
	AccessKeySecretTypeAccessKeySecretDataSourceSecret       AccessKeySecretType = "accessKeySecret_DataSource_Secret"
)

type AccessKeySecret struct {
	AccessKeySecretDataSourceFile         *AccessKeySecretDataSourceFile         `queryParam:"inline,name=accessKeySecret"`
	AccessKeySecretDataSourceInline       *AccessKeySecretDataSourceInline       `queryParam:"inline,name=accessKeySecret"`
	AccessKeySecretDataSourceInlineString *AccessKeySecretDataSourceInlineString `queryParam:"inline,name=accessKeySecret"`
	AccessKeySecretDataSourceSecret       *AccessKeySecretDataSourceSecret       `queryParam:"inline,name=accessKeySecret"`

	Type AccessKeySecretType
}

func CreateAccessKeySecretAccessKeySecretDataSourceFile(accessKeySecretDataSourceFile AccessKeySecretDataSourceFile) AccessKeySecret {
	typ := AccessKeySecretTypeAccessKeySecretDataSourceFile

	return AccessKeySecret{
		AccessKeySecretDataSourceFile: &accessKeySecretDataSourceFile,
		Type:                          typ,
	}
}

func CreateAccessKeySecretAccessKeySecretDataSourceInline(accessKeySecretDataSourceInline AccessKeySecretDataSourceInline) AccessKeySecret {
	typ := AccessKeySecretTypeAccessKeySecretDataSourceInline

	return AccessKeySecret{
		AccessKeySecretDataSourceInline: &accessKeySecretDataSourceInline,
		Type:                            typ,
	}
}

func CreateAccessKeySecretAccessKeySecretDataSourceInlineString(accessKeySecretDataSourceInlineString AccessKeySecretDataSourceInlineString) AccessKeySecret {
	typ := AccessKeySecretTypeAccessKeySecretDataSourceInlineString

	return AccessKeySecret{
		AccessKeySecretDataSourceInlineString: &accessKeySecretDataSourceInlineString,
		Type:                                  typ,
	}
}

func CreateAccessKeySecretAccessKeySecretDataSourceSecret(accessKeySecretDataSourceSecret AccessKeySecretDataSourceSecret) AccessKeySecret {
	typ := AccessKeySecretTypeAccessKeySecretDataSourceSecret

	return AccessKeySecret{
		AccessKeySecretDataSourceSecret: &accessKeySecretDataSourceSecret,
		Type:                            typ,
	}
}

func (u *AccessKeySecret) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var accessKeySecretDataSourceFile AccessKeySecretDataSourceFile = AccessKeySecretDataSourceFile{}
	if err := utils.UnmarshalJSON(data, &accessKeySecretDataSourceFile, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  AccessKeySecretTypeAccessKeySecretDataSourceFile,
			Value: &accessKeySecretDataSourceFile,
		})
	}

	var accessKeySecretDataSourceInline AccessKeySecretDataSourceInline = AccessKeySecretDataSourceInline{}
	if err := utils.UnmarshalJSON(data, &accessKeySecretDataSourceInline, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  AccessKeySecretTypeAccessKeySecretDataSourceInline,
			Value: &accessKeySecretDataSourceInline,
		})
	}

	var accessKeySecretDataSourceInlineString AccessKeySecretDataSourceInlineString = AccessKeySecretDataSourceInlineString{}
	if err := utils.UnmarshalJSON(data, &accessKeySecretDataSourceInlineString, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  AccessKeySecretTypeAccessKeySecretDataSourceInlineString,
			Value: &accessKeySecretDataSourceInlineString,
		})
	}

	var accessKeySecretDataSourceSecret AccessKeySecretDataSourceSecret = AccessKeySecretDataSourceSecret{}
	if err := utils.UnmarshalJSON(data, &accessKeySecretDataSourceSecret, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  AccessKeySecretTypeAccessKeySecretDataSourceSecret,
			Value: &accessKeySecretDataSourceSecret,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for AccessKeySecret", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestCandidate(candidates)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for AccessKeySecret", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(AccessKeySecretType)
	switch best.Type {
	case AccessKeySecretTypeAccessKeySecretDataSourceFile:
		u.AccessKeySecretDataSourceFile = best.Value.(*AccessKeySecretDataSourceFile)
		return nil
	case AccessKeySecretTypeAccessKeySecretDataSourceInline:
		u.AccessKeySecretDataSourceInline = best.Value.(*AccessKeySecretDataSourceInline)
		return nil
	case AccessKeySecretTypeAccessKeySecretDataSourceInlineString:
		u.AccessKeySecretDataSourceInlineString = best.Value.(*AccessKeySecretDataSourceInlineString)
		return nil
	case AccessKeySecretTypeAccessKeySecretDataSourceSecret:
		u.AccessKeySecretDataSourceSecret = best.Value.(*AccessKeySecretDataSourceSecret)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for AccessKeySecret", string(data))
}

func (u AccessKeySecret) MarshalJSON() ([]byte, error) {
	if u.AccessKeySecretDataSourceFile != nil {
		return utils.MarshalJSON(u.AccessKeySecretDataSourceFile, "", true)
	}

	if u.AccessKeySecretDataSourceInline != nil {
		return utils.MarshalJSON(u.AccessKeySecretDataSourceInline, "", true)
	}

	if u.AccessKeySecretDataSourceInlineString != nil {
		return utils.MarshalJSON(u.AccessKeySecretDataSourceInlineString, "", true)
	}

	if u.AccessKeySecretDataSourceSecret != nil {
		return utils.MarshalJSON(u.AccessKeySecretDataSourceSecret, "", true)
	}

	return nil, errors.New("could not marshal union type AccessKeySecret: all fields are null")
}

type AwsCredentials struct {
	AccessKey       *AccessKey       `json:"accessKey,omitempty"`
	AccessKeySecret *AccessKeySecret `json:"accessKeySecret,omitempty"`
}

func (a AwsCredentials) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AwsCredentials) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (a *AwsCredentials) GetAccessKey() *AccessKey {
	if a == nil {
		return nil
	}
	return a.AccessKey
}

func (a *AwsCredentials) GetAccessKeySecret() *AccessKeySecret {
	if a == nil {
		return nil
	}
	return a.AccessKeySecret
}

type Auth struct {
	AwsCredentials *AwsCredentials `json:"awsCredentials,omitempty"`
}

func (a Auth) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *Auth) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (a *Auth) GetAwsCredentials() *AwsCredentials {
	if a == nil {
		return nil
	}
	return a.AwsCredentials
}

type CaCertDataSourceSecret struct {
	// Data source is a secret with given Secret key.
	Secret *string `json:"secret,omitempty"`
}

func (c CaCertDataSourceSecret) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CaCertDataSourceSecret) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CaCertDataSourceSecret) GetSecret() *string {
	if c == nil {
		return nil
	}
	return c.Secret
}

type CaCertDataSourceInlineString struct {
	// Data source is inline string
	InlineString *string `json:"inlineString,omitempty"`
}

func (c CaCertDataSourceInlineString) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CaCertDataSourceInlineString) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CaCertDataSourceInlineString) GetInlineString() *string {
	if c == nil {
		return nil
	}
	return c.InlineString
}

type CaCertDataSourceInline struct {
	// Data source is inline bytes.
	Inline *string `json:"inline,omitempty"`
}

func (c CaCertDataSourceInline) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CaCertDataSourceInline) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CaCertDataSourceInline) GetInline() *string {
	if c == nil {
		return nil
	}
	return c.Inline
}

type CaCertDataSourceFile struct {
	// Data source is a path to a file.
	// Deprecated, use other sources of a data.
	File *string `json:"file,omitempty"`
}

func (c CaCertDataSourceFile) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CaCertDataSourceFile) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CaCertDataSourceFile) GetFile() *string {
	if c == nil {
		return nil
	}
	return c.File
}

type ConfCaCertType string

const (
	ConfCaCertTypeCaCertDataSourceFile         ConfCaCertType = "caCert_DataSource_File"
	ConfCaCertTypeCaCertDataSourceInline       ConfCaCertType = "caCert_DataSource_Inline"
	ConfCaCertTypeCaCertDataSourceInlineString ConfCaCertType = "caCert_DataSource_InlineString"
	ConfCaCertTypeCaCertDataSourceSecret       ConfCaCertType = "caCert_DataSource_Secret"
)

type ConfCaCert struct {
	CaCertDataSourceFile         *CaCertDataSourceFile         `queryParam:"inline,name=caCert"`
	CaCertDataSourceInline       *CaCertDataSourceInline       `queryParam:"inline,name=caCert"`
	CaCertDataSourceInlineString *CaCertDataSourceInlineString `queryParam:"inline,name=caCert"`
	CaCertDataSourceSecret       *CaCertDataSourceSecret       `queryParam:"inline,name=caCert"`

	Type ConfCaCertType
}

func CreateConfCaCertCaCertDataSourceFile(caCertDataSourceFile CaCertDataSourceFile) ConfCaCert {
	typ := ConfCaCertTypeCaCertDataSourceFile

	return ConfCaCert{
		CaCertDataSourceFile: &caCertDataSourceFile,
		Type:                 typ,
	}
}

func CreateConfCaCertCaCertDataSourceInline(caCertDataSourceInline CaCertDataSourceInline) ConfCaCert {
	typ := ConfCaCertTypeCaCertDataSourceInline

	return ConfCaCert{
		CaCertDataSourceInline: &caCertDataSourceInline,
		Type:                   typ,
	}
}

func CreateConfCaCertCaCertDataSourceInlineString(caCertDataSourceInlineString CaCertDataSourceInlineString) ConfCaCert {
	typ := ConfCaCertTypeCaCertDataSourceInlineString

	return ConfCaCert{
		CaCertDataSourceInlineString: &caCertDataSourceInlineString,
		Type:                         typ,
	}
}

func CreateConfCaCertCaCertDataSourceSecret(caCertDataSourceSecret CaCertDataSourceSecret) ConfCaCert {
	typ := ConfCaCertTypeCaCertDataSourceSecret

	return ConfCaCert{
		CaCertDataSourceSecret: &caCertDataSourceSecret,
		Type:                   typ,
	}
}

func (u *ConfCaCert) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var caCertDataSourceFile CaCertDataSourceFile = CaCertDataSourceFile{}
	if err := utils.UnmarshalJSON(data, &caCertDataSourceFile, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  ConfCaCertTypeCaCertDataSourceFile,
			Value: &caCertDataSourceFile,
		})
	}

	var caCertDataSourceInline CaCertDataSourceInline = CaCertDataSourceInline{}
	if err := utils.UnmarshalJSON(data, &caCertDataSourceInline, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  ConfCaCertTypeCaCertDataSourceInline,
			Value: &caCertDataSourceInline,
		})
	}

	var caCertDataSourceInlineString CaCertDataSourceInlineString = CaCertDataSourceInlineString{}
	if err := utils.UnmarshalJSON(data, &caCertDataSourceInlineString, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  ConfCaCertTypeCaCertDataSourceInlineString,
			Value: &caCertDataSourceInlineString,
		})
	}

	var caCertDataSourceSecret CaCertDataSourceSecret = CaCertDataSourceSecret{}
	if err := utils.UnmarshalJSON(data, &caCertDataSourceSecret, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  ConfCaCertTypeCaCertDataSourceSecret,
			Value: &caCertDataSourceSecret,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for ConfCaCert", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestCandidate(candidates)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for ConfCaCert", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(ConfCaCertType)
	switch best.Type {
	case ConfCaCertTypeCaCertDataSourceFile:
		u.CaCertDataSourceFile = best.Value.(*CaCertDataSourceFile)
		return nil
	case ConfCaCertTypeCaCertDataSourceInline:
		u.CaCertDataSourceInline = best.Value.(*CaCertDataSourceInline)
		return nil
	case ConfCaCertTypeCaCertDataSourceInlineString:
		u.CaCertDataSourceInlineString = best.Value.(*CaCertDataSourceInlineString)
		return nil
	case ConfCaCertTypeCaCertDataSourceSecret:
		u.CaCertDataSourceSecret = best.Value.(*CaCertDataSourceSecret)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ConfCaCert", string(data))
}

func (u ConfCaCert) MarshalJSON() ([]byte, error) {
	if u.CaCertDataSourceFile != nil {
		return utils.MarshalJSON(u.CaCertDataSourceFile, "", true)
	}

	if u.CaCertDataSourceInline != nil {
		return utils.MarshalJSON(u.CaCertDataSourceInline, "", true)
	}

	if u.CaCertDataSourceInlineString != nil {
		return utils.MarshalJSON(u.CaCertDataSourceInlineString, "", true)
	}

	if u.CaCertDataSourceSecret != nil {
		return utils.MarshalJSON(u.CaCertDataSourceSecret, "", true)
	}

	return nil, errors.New("could not marshal union type ConfCaCert: all fields are null")
}

type ACMCertificateAuthorityConfig struct {
	Arn        *string     `json:"arn,omitempty"`
	Auth       *Auth       `json:"auth,omitempty"`
	CaCert     *ConfCaCert `json:"caCert,omitempty"`
	CommonName *string     `json:"commonName,omitempty"`
}

func (a ACMCertificateAuthorityConfig) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *ACMCertificateAuthorityConfig) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (a *ACMCertificateAuthorityConfig) GetArn() *string {
	if a == nil {
		return nil
	}
	return a.Arn
}

func (a *ACMCertificateAuthorityConfig) GetAuth() *Auth {
	if a == nil {
		return nil
	}
	return a.Auth
}

func (a *ACMCertificateAuthorityConfig) GetCaCert() *ConfCaCert {
	if a == nil {
		return nil
	}
	return a.CaCert
}

func (a *ACMCertificateAuthorityConfig) GetCommonName() *string {
	if a == nil {
		return nil
	}
	return a.CommonName
}

type TokenDataSourceSecret struct {
	// Data source is a secret with given Secret key.
	Secret *string `json:"secret,omitempty"`
}

func (t TokenDataSourceSecret) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(t, "", false)
}

func (t *TokenDataSourceSecret) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &t, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (t *TokenDataSourceSecret) GetSecret() *string {
	if t == nil {
		return nil
	}
	return t.Secret
}

type TokenDataSourceInlineString struct {
	// Data source is inline string
	InlineString *string `json:"inlineString,omitempty"`
}

func (t TokenDataSourceInlineString) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(t, "", false)
}

func (t *TokenDataSourceInlineString) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &t, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (t *TokenDataSourceInlineString) GetInlineString() *string {
	if t == nil {
		return nil
	}
	return t.InlineString
}

type TokenDataSourceInline struct {
	// Data source is inline bytes.
	Inline *string `json:"inline,omitempty"`
}

func (t TokenDataSourceInline) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(t, "", false)
}

func (t *TokenDataSourceInline) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &t, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (t *TokenDataSourceInline) GetInline() *string {
	if t == nil {
		return nil
	}
	return t.Inline
}

type TokenDataSourceFile struct {
	// Data source is a path to a file.
	// Deprecated, use other sources of a data.
	File *string `json:"file,omitempty"`
}

func (t TokenDataSourceFile) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(t, "", false)
}

func (t *TokenDataSourceFile) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &t, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (t *TokenDataSourceFile) GetFile() *string {
	if t == nil {
		return nil
	}
	return t.File
}

type TokenType string

const (
	TokenTypeTokenDataSourceFile         TokenType = "token_DataSource_File"
	TokenTypeTokenDataSourceInline       TokenType = "token_DataSource_Inline"
	TokenTypeTokenDataSourceInlineString TokenType = "token_DataSource_InlineString"
	TokenTypeTokenDataSourceSecret       TokenType = "token_DataSource_Secret"
)

type Token struct {
	TokenDataSourceFile         *TokenDataSourceFile         `queryParam:"inline,name=token"`
	TokenDataSourceInline       *TokenDataSourceInline       `queryParam:"inline,name=token"`
	TokenDataSourceInlineString *TokenDataSourceInlineString `queryParam:"inline,name=token"`
	TokenDataSourceSecret       *TokenDataSourceSecret       `queryParam:"inline,name=token"`

	Type TokenType
}

func CreateTokenTokenDataSourceFile(tokenDataSourceFile TokenDataSourceFile) Token {
	typ := TokenTypeTokenDataSourceFile

	return Token{
		TokenDataSourceFile: &tokenDataSourceFile,
		Type:                typ,
	}
}

func CreateTokenTokenDataSourceInline(tokenDataSourceInline TokenDataSourceInline) Token {
	typ := TokenTypeTokenDataSourceInline

	return Token{
		TokenDataSourceInline: &tokenDataSourceInline,
		Type:                  typ,
	}
}

func CreateTokenTokenDataSourceInlineString(tokenDataSourceInlineString TokenDataSourceInlineString) Token {
	typ := TokenTypeTokenDataSourceInlineString

	return Token{
		TokenDataSourceInlineString: &tokenDataSourceInlineString,
		Type:                        typ,
	}
}

func CreateTokenTokenDataSourceSecret(tokenDataSourceSecret TokenDataSourceSecret) Token {
	typ := TokenTypeTokenDataSourceSecret

	return Token{
		TokenDataSourceSecret: &tokenDataSourceSecret,
		Type:                  typ,
	}
}

func (u *Token) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var tokenDataSourceFile TokenDataSourceFile = TokenDataSourceFile{}
	if err := utils.UnmarshalJSON(data, &tokenDataSourceFile, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  TokenTypeTokenDataSourceFile,
			Value: &tokenDataSourceFile,
		})
	}

	var tokenDataSourceInline TokenDataSourceInline = TokenDataSourceInline{}
	if err := utils.UnmarshalJSON(data, &tokenDataSourceInline, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  TokenTypeTokenDataSourceInline,
			Value: &tokenDataSourceInline,
		})
	}

	var tokenDataSourceInlineString TokenDataSourceInlineString = TokenDataSourceInlineString{}
	if err := utils.UnmarshalJSON(data, &tokenDataSourceInlineString, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  TokenTypeTokenDataSourceInlineString,
			Value: &tokenDataSourceInlineString,
		})
	}

	var tokenDataSourceSecret TokenDataSourceSecret = TokenDataSourceSecret{}
	if err := utils.UnmarshalJSON(data, &tokenDataSourceSecret, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  TokenTypeTokenDataSourceSecret,
			Value: &tokenDataSourceSecret,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for Token", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestCandidate(candidates)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for Token", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(TokenType)
	switch best.Type {
	case TokenTypeTokenDataSourceFile:
		u.TokenDataSourceFile = best.Value.(*TokenDataSourceFile)
		return nil
	case TokenTypeTokenDataSourceInline:
		u.TokenDataSourceInline = best.Value.(*TokenDataSourceInline)
		return nil
	case TokenTypeTokenDataSourceInlineString:
		u.TokenDataSourceInlineString = best.Value.(*TokenDataSourceInlineString)
		return nil
	case TokenTypeTokenDataSourceSecret:
		u.TokenDataSourceSecret = best.Value.(*TokenDataSourceSecret)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Token", string(data))
}

func (u Token) MarshalJSON() ([]byte, error) {
	if u.TokenDataSourceFile != nil {
		return utils.MarshalJSON(u.TokenDataSourceFile, "", true)
	}

	if u.TokenDataSourceInline != nil {
		return utils.MarshalJSON(u.TokenDataSourceInline, "", true)
	}

	if u.TokenDataSourceInlineString != nil {
		return utils.MarshalJSON(u.TokenDataSourceInlineString, "", true)
	}

	if u.TokenDataSourceSecret != nil {
		return utils.MarshalJSON(u.TokenDataSourceSecret, "", true)
	}

	return nil, errors.New("could not marshal union type Token: all fields are null")
}

type VaultCertificateAuthorityConfigFromCpAuthToken struct {
	Token *Token `json:"token,omitempty"`
}

func (v VaultCertificateAuthorityConfigFromCpAuthToken) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(v, "", false)
}

func (v *VaultCertificateAuthorityConfigFromCpAuthToken) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &v, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (v *VaultCertificateAuthorityConfigFromCpAuthToken) GetToken() *Token {
	if v == nil {
		return nil
	}
	return v.Token
}

type ClientCertDataSourceSecret struct {
	// Data source is a secret with given Secret key.
	Secret *string `json:"secret,omitempty"`
}

func (c ClientCertDataSourceSecret) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *ClientCertDataSourceSecret) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *ClientCertDataSourceSecret) GetSecret() *string {
	if c == nil {
		return nil
	}
	return c.Secret
}

type ClientCertDataSourceInlineString struct {
	// Data source is inline string
	InlineString *string `json:"inlineString,omitempty"`
}

func (c ClientCertDataSourceInlineString) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *ClientCertDataSourceInlineString) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *ClientCertDataSourceInlineString) GetInlineString() *string {
	if c == nil {
		return nil
	}
	return c.InlineString
}

type ClientCertDataSourceInline struct {
	// Data source is inline bytes.
	Inline *string `json:"inline,omitempty"`
}

func (c ClientCertDataSourceInline) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *ClientCertDataSourceInline) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *ClientCertDataSourceInline) GetInline() *string {
	if c == nil {
		return nil
	}
	return c.Inline
}

type ClientCertDataSourceFile struct {
	// Data source is a path to a file.
	// Deprecated, use other sources of a data.
	File *string `json:"file,omitempty"`
}

func (c ClientCertDataSourceFile) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *ClientCertDataSourceFile) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *ClientCertDataSourceFile) GetFile() *string {
	if c == nil {
		return nil
	}
	return c.File
}

type AuthClientCertType string

const (
	AuthClientCertTypeClientCertDataSourceFile         AuthClientCertType = "clientCert_DataSource_File"
	AuthClientCertTypeClientCertDataSourceInline       AuthClientCertType = "clientCert_DataSource_Inline"
	AuthClientCertTypeClientCertDataSourceInlineString AuthClientCertType = "clientCert_DataSource_InlineString"
	AuthClientCertTypeClientCertDataSourceSecret       AuthClientCertType = "clientCert_DataSource_Secret"
)

type AuthClientCert struct {
	ClientCertDataSourceFile         *ClientCertDataSourceFile         `queryParam:"inline,name=clientCert"`
	ClientCertDataSourceInline       *ClientCertDataSourceInline       `queryParam:"inline,name=clientCert"`
	ClientCertDataSourceInlineString *ClientCertDataSourceInlineString `queryParam:"inline,name=clientCert"`
	ClientCertDataSourceSecret       *ClientCertDataSourceSecret       `queryParam:"inline,name=clientCert"`

	Type AuthClientCertType
}

func CreateAuthClientCertClientCertDataSourceFile(clientCertDataSourceFile ClientCertDataSourceFile) AuthClientCert {
	typ := AuthClientCertTypeClientCertDataSourceFile

	return AuthClientCert{
		ClientCertDataSourceFile: &clientCertDataSourceFile,
		Type:                     typ,
	}
}

func CreateAuthClientCertClientCertDataSourceInline(clientCertDataSourceInline ClientCertDataSourceInline) AuthClientCert {
	typ := AuthClientCertTypeClientCertDataSourceInline

	return AuthClientCert{
		ClientCertDataSourceInline: &clientCertDataSourceInline,
		Type:                       typ,
	}
}

func CreateAuthClientCertClientCertDataSourceInlineString(clientCertDataSourceInlineString ClientCertDataSourceInlineString) AuthClientCert {
	typ := AuthClientCertTypeClientCertDataSourceInlineString

	return AuthClientCert{
		ClientCertDataSourceInlineString: &clientCertDataSourceInlineString,
		Type:                             typ,
	}
}

func CreateAuthClientCertClientCertDataSourceSecret(clientCertDataSourceSecret ClientCertDataSourceSecret) AuthClientCert {
	typ := AuthClientCertTypeClientCertDataSourceSecret

	return AuthClientCert{
		ClientCertDataSourceSecret: &clientCertDataSourceSecret,
		Type:                       typ,
	}
}

func (u *AuthClientCert) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var clientCertDataSourceFile ClientCertDataSourceFile = ClientCertDataSourceFile{}
	if err := utils.UnmarshalJSON(data, &clientCertDataSourceFile, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  AuthClientCertTypeClientCertDataSourceFile,
			Value: &clientCertDataSourceFile,
		})
	}

	var clientCertDataSourceInline ClientCertDataSourceInline = ClientCertDataSourceInline{}
	if err := utils.UnmarshalJSON(data, &clientCertDataSourceInline, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  AuthClientCertTypeClientCertDataSourceInline,
			Value: &clientCertDataSourceInline,
		})
	}

	var clientCertDataSourceInlineString ClientCertDataSourceInlineString = ClientCertDataSourceInlineString{}
	if err := utils.UnmarshalJSON(data, &clientCertDataSourceInlineString, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  AuthClientCertTypeClientCertDataSourceInlineString,
			Value: &clientCertDataSourceInlineString,
		})
	}

	var clientCertDataSourceSecret ClientCertDataSourceSecret = ClientCertDataSourceSecret{}
	if err := utils.UnmarshalJSON(data, &clientCertDataSourceSecret, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  AuthClientCertTypeClientCertDataSourceSecret,
			Value: &clientCertDataSourceSecret,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for AuthClientCert", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestCandidate(candidates)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for AuthClientCert", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(AuthClientCertType)
	switch best.Type {
	case AuthClientCertTypeClientCertDataSourceFile:
		u.ClientCertDataSourceFile = best.Value.(*ClientCertDataSourceFile)
		return nil
	case AuthClientCertTypeClientCertDataSourceInline:
		u.ClientCertDataSourceInline = best.Value.(*ClientCertDataSourceInline)
		return nil
	case AuthClientCertTypeClientCertDataSourceInlineString:
		u.ClientCertDataSourceInlineString = best.Value.(*ClientCertDataSourceInlineString)
		return nil
	case AuthClientCertTypeClientCertDataSourceSecret:
		u.ClientCertDataSourceSecret = best.Value.(*ClientCertDataSourceSecret)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for AuthClientCert", string(data))
}

func (u AuthClientCert) MarshalJSON() ([]byte, error) {
	if u.ClientCertDataSourceFile != nil {
		return utils.MarshalJSON(u.ClientCertDataSourceFile, "", true)
	}

	if u.ClientCertDataSourceInline != nil {
		return utils.MarshalJSON(u.ClientCertDataSourceInline, "", true)
	}

	if u.ClientCertDataSourceInlineString != nil {
		return utils.MarshalJSON(u.ClientCertDataSourceInlineString, "", true)
	}

	if u.ClientCertDataSourceSecret != nil {
		return utils.MarshalJSON(u.ClientCertDataSourceSecret, "", true)
	}

	return nil, errors.New("could not marshal union type AuthClientCert: all fields are null")
}

type ClientKeyDataSourceSecret struct {
	// Data source is a secret with given Secret key.
	Secret *string `json:"secret,omitempty"`
}

func (c ClientKeyDataSourceSecret) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *ClientKeyDataSourceSecret) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *ClientKeyDataSourceSecret) GetSecret() *string {
	if c == nil {
		return nil
	}
	return c.Secret
}

type ClientKeyDataSourceInlineString struct {
	// Data source is inline string
	InlineString *string `json:"inlineString,omitempty"`
}

func (c ClientKeyDataSourceInlineString) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *ClientKeyDataSourceInlineString) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *ClientKeyDataSourceInlineString) GetInlineString() *string {
	if c == nil {
		return nil
	}
	return c.InlineString
}

type ClientKeyDataSourceInline struct {
	// Data source is inline bytes.
	Inline *string `json:"inline,omitempty"`
}

func (c ClientKeyDataSourceInline) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *ClientKeyDataSourceInline) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *ClientKeyDataSourceInline) GetInline() *string {
	if c == nil {
		return nil
	}
	return c.Inline
}

type ClientKeyDataSourceFile struct {
	// Data source is a path to a file.
	// Deprecated, use other sources of a data.
	File *string `json:"file,omitempty"`
}

func (c ClientKeyDataSourceFile) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *ClientKeyDataSourceFile) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *ClientKeyDataSourceFile) GetFile() *string {
	if c == nil {
		return nil
	}
	return c.File
}

type AuthClientKeyType string

const (
	AuthClientKeyTypeClientKeyDataSourceFile         AuthClientKeyType = "clientKey_DataSource_File"
	AuthClientKeyTypeClientKeyDataSourceInline       AuthClientKeyType = "clientKey_DataSource_Inline"
	AuthClientKeyTypeClientKeyDataSourceInlineString AuthClientKeyType = "clientKey_DataSource_InlineString"
	AuthClientKeyTypeClientKeyDataSourceSecret       AuthClientKeyType = "clientKey_DataSource_Secret"
)

type AuthClientKey struct {
	ClientKeyDataSourceFile         *ClientKeyDataSourceFile         `queryParam:"inline,name=clientKey"`
	ClientKeyDataSourceInline       *ClientKeyDataSourceInline       `queryParam:"inline,name=clientKey"`
	ClientKeyDataSourceInlineString *ClientKeyDataSourceInlineString `queryParam:"inline,name=clientKey"`
	ClientKeyDataSourceSecret       *ClientKeyDataSourceSecret       `queryParam:"inline,name=clientKey"`

	Type AuthClientKeyType
}

func CreateAuthClientKeyClientKeyDataSourceFile(clientKeyDataSourceFile ClientKeyDataSourceFile) AuthClientKey {
	typ := AuthClientKeyTypeClientKeyDataSourceFile

	return AuthClientKey{
		ClientKeyDataSourceFile: &clientKeyDataSourceFile,
		Type:                    typ,
	}
}

func CreateAuthClientKeyClientKeyDataSourceInline(clientKeyDataSourceInline ClientKeyDataSourceInline) AuthClientKey {
	typ := AuthClientKeyTypeClientKeyDataSourceInline

	return AuthClientKey{
		ClientKeyDataSourceInline: &clientKeyDataSourceInline,
		Type:                      typ,
	}
}

func CreateAuthClientKeyClientKeyDataSourceInlineString(clientKeyDataSourceInlineString ClientKeyDataSourceInlineString) AuthClientKey {
	typ := AuthClientKeyTypeClientKeyDataSourceInlineString

	return AuthClientKey{
		ClientKeyDataSourceInlineString: &clientKeyDataSourceInlineString,
		Type:                            typ,
	}
}

func CreateAuthClientKeyClientKeyDataSourceSecret(clientKeyDataSourceSecret ClientKeyDataSourceSecret) AuthClientKey {
	typ := AuthClientKeyTypeClientKeyDataSourceSecret

	return AuthClientKey{
		ClientKeyDataSourceSecret: &clientKeyDataSourceSecret,
		Type:                      typ,
	}
}

func (u *AuthClientKey) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var clientKeyDataSourceFile ClientKeyDataSourceFile = ClientKeyDataSourceFile{}
	if err := utils.UnmarshalJSON(data, &clientKeyDataSourceFile, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  AuthClientKeyTypeClientKeyDataSourceFile,
			Value: &clientKeyDataSourceFile,
		})
	}

	var clientKeyDataSourceInline ClientKeyDataSourceInline = ClientKeyDataSourceInline{}
	if err := utils.UnmarshalJSON(data, &clientKeyDataSourceInline, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  AuthClientKeyTypeClientKeyDataSourceInline,
			Value: &clientKeyDataSourceInline,
		})
	}

	var clientKeyDataSourceInlineString ClientKeyDataSourceInlineString = ClientKeyDataSourceInlineString{}
	if err := utils.UnmarshalJSON(data, &clientKeyDataSourceInlineString, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  AuthClientKeyTypeClientKeyDataSourceInlineString,
			Value: &clientKeyDataSourceInlineString,
		})
	}

	var clientKeyDataSourceSecret ClientKeyDataSourceSecret = ClientKeyDataSourceSecret{}
	if err := utils.UnmarshalJSON(data, &clientKeyDataSourceSecret, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  AuthClientKeyTypeClientKeyDataSourceSecret,
			Value: &clientKeyDataSourceSecret,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for AuthClientKey", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestCandidate(candidates)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for AuthClientKey", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(AuthClientKeyType)
	switch best.Type {
	case AuthClientKeyTypeClientKeyDataSourceFile:
		u.ClientKeyDataSourceFile = best.Value.(*ClientKeyDataSourceFile)
		return nil
	case AuthClientKeyTypeClientKeyDataSourceInline:
		u.ClientKeyDataSourceInline = best.Value.(*ClientKeyDataSourceInline)
		return nil
	case AuthClientKeyTypeClientKeyDataSourceInlineString:
		u.ClientKeyDataSourceInlineString = best.Value.(*ClientKeyDataSourceInlineString)
		return nil
	case AuthClientKeyTypeClientKeyDataSourceSecret:
		u.ClientKeyDataSourceSecret = best.Value.(*ClientKeyDataSourceSecret)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for AuthClientKey", string(data))
}

func (u AuthClientKey) MarshalJSON() ([]byte, error) {
	if u.ClientKeyDataSourceFile != nil {
		return utils.MarshalJSON(u.ClientKeyDataSourceFile, "", true)
	}

	if u.ClientKeyDataSourceInline != nil {
		return utils.MarshalJSON(u.ClientKeyDataSourceInline, "", true)
	}

	if u.ClientKeyDataSourceInlineString != nil {
		return utils.MarshalJSON(u.ClientKeyDataSourceInlineString, "", true)
	}

	if u.ClientKeyDataSourceSecret != nil {
		return utils.MarshalJSON(u.ClientKeyDataSourceSecret, "", true)
	}

	return nil, errors.New("could not marshal union type AuthClientKey: all fields are null")
}

type AuthTLS struct {
	ClientCert *AuthClientCert `json:"clientCert,omitempty"`
	ClientKey  *AuthClientKey  `json:"clientKey,omitempty"`
}

func (a AuthTLS) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AuthTLS) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (a *AuthTLS) GetClientCert() *AuthClientCert {
	if a == nil {
		return nil
	}
	return a.ClientCert
}

func (a *AuthTLS) GetClientKey() *AuthClientKey {
	if a == nil {
		return nil
	}
	return a.ClientKey
}

type VaultCertificateAuthorityConfigFromCpAuthTLS struct {
	TLS *AuthTLS `json:"tls,omitempty"`
}

func (v VaultCertificateAuthorityConfigFromCpAuthTLS) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(v, "", false)
}

func (v *VaultCertificateAuthorityConfigFromCpAuthTLS) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &v, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (v *VaultCertificateAuthorityConfigFromCpAuthTLS) GetTLS() *AuthTLS {
	if v == nil {
		return nil
	}
	return v.TLS
}

type AuthTypeType string

const (
	AuthTypeTypeStr     AuthTypeType = "str"
	AuthTypeTypeInteger AuthTypeType = "integer"
)

type AuthType struct {
	Str     *string `queryParam:"inline,name=type"`
	Integer *int64  `queryParam:"inline,name=type"`

	Type AuthTypeType
}

func CreateAuthTypeStr(str string) AuthType {
	typ := AuthTypeTypeStr

	return AuthType{
		Str:  &str,
		Type: typ,
	}
}

func CreateAuthTypeInteger(integer int64) AuthType {
	typ := AuthTypeTypeInteger

	return AuthType{
		Integer: &integer,
		Type:    typ,
	}
}

func (u *AuthType) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  AuthTypeTypeStr,
			Value: &str,
		})
	}

	var integer int64 = int64(0)
	if err := utils.UnmarshalJSON(data, &integer, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  AuthTypeTypeInteger,
			Value: &integer,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for AuthType", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestCandidate(candidates)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for AuthType", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(AuthTypeType)
	switch best.Type {
	case AuthTypeTypeStr:
		u.Str = best.Value.(*string)
		return nil
	case AuthTypeTypeInteger:
		u.Integer = best.Value.(*int64)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for AuthType", string(data))
}

func (u AuthType) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Integer != nil {
		return utils.MarshalJSON(u.Integer, "", true)
	}

	return nil, errors.New("could not marshal union type AuthType: all fields are null")
}

type Aws struct {
	IamServerIDHeader *string   `json:"iamServerIdHeader,omitempty"`
	Role              *string   `json:"role,omitempty"`
	Type              *AuthType `json:"type,omitempty"`
}

func (a Aws) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *Aws) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (a *Aws) GetIamServerIDHeader() *string {
	if a == nil {
		return nil
	}
	return a.IamServerIDHeader
}

func (a *Aws) GetRole() *string {
	if a == nil {
		return nil
	}
	return a.Role
}

func (a *Aws) GetType() *AuthType {
	if a == nil {
		return nil
	}
	return a.Type
}

type VaultCertificateAuthorityConfigFromCpAuthAws struct {
	Aws *Aws `json:"aws,omitempty"`
}

func (v VaultCertificateAuthorityConfigFromCpAuthAws) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(v, "", false)
}

func (v *VaultCertificateAuthorityConfigFromCpAuthAws) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &v, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (v *VaultCertificateAuthorityConfigFromCpAuthAws) GetAws() *Aws {
	if v == nil {
		return nil
	}
	return v.Aws
}

type VaultCertificateAuthorityConfigAuthType string

const (
	VaultCertificateAuthorityConfigAuthTypeVaultCertificateAuthorityConfigFromCpAuthAws   VaultCertificateAuthorityConfigAuthType = "VaultCertificateAuthorityConfig_FromCp_Auth_Aws"
	VaultCertificateAuthorityConfigAuthTypeVaultCertificateAuthorityConfigFromCpAuthTLS   VaultCertificateAuthorityConfigAuthType = "VaultCertificateAuthorityConfig_FromCp_Auth_Tls"
	VaultCertificateAuthorityConfigAuthTypeVaultCertificateAuthorityConfigFromCpAuthToken VaultCertificateAuthorityConfigAuthType = "VaultCertificateAuthorityConfig_FromCp_Auth_Token"
)

type VaultCertificateAuthorityConfigAuth struct {
	VaultCertificateAuthorityConfigFromCpAuthAws   *VaultCertificateAuthorityConfigFromCpAuthAws   `queryParam:"inline,name=auth"`
	VaultCertificateAuthorityConfigFromCpAuthTLS   *VaultCertificateAuthorityConfigFromCpAuthTLS   `queryParam:"inline,name=auth"`
	VaultCertificateAuthorityConfigFromCpAuthToken *VaultCertificateAuthorityConfigFromCpAuthToken `queryParam:"inline,name=auth"`

	Type VaultCertificateAuthorityConfigAuthType
}

func CreateVaultCertificateAuthorityConfigAuthVaultCertificateAuthorityConfigFromCpAuthAws(vaultCertificateAuthorityConfigFromCpAuthAws VaultCertificateAuthorityConfigFromCpAuthAws) VaultCertificateAuthorityConfigAuth {
	typ := VaultCertificateAuthorityConfigAuthTypeVaultCertificateAuthorityConfigFromCpAuthAws

	return VaultCertificateAuthorityConfigAuth{
		VaultCertificateAuthorityConfigFromCpAuthAws: &vaultCertificateAuthorityConfigFromCpAuthAws,
		Type: typ,
	}
}

func CreateVaultCertificateAuthorityConfigAuthVaultCertificateAuthorityConfigFromCpAuthTLS(vaultCertificateAuthorityConfigFromCpAuthTLS VaultCertificateAuthorityConfigFromCpAuthTLS) VaultCertificateAuthorityConfigAuth {
	typ := VaultCertificateAuthorityConfigAuthTypeVaultCertificateAuthorityConfigFromCpAuthTLS

	return VaultCertificateAuthorityConfigAuth{
		VaultCertificateAuthorityConfigFromCpAuthTLS: &vaultCertificateAuthorityConfigFromCpAuthTLS,
		Type: typ,
	}
}

func CreateVaultCertificateAuthorityConfigAuthVaultCertificateAuthorityConfigFromCpAuthToken(vaultCertificateAuthorityConfigFromCpAuthToken VaultCertificateAuthorityConfigFromCpAuthToken) VaultCertificateAuthorityConfigAuth {
	typ := VaultCertificateAuthorityConfigAuthTypeVaultCertificateAuthorityConfigFromCpAuthToken

	return VaultCertificateAuthorityConfigAuth{
		VaultCertificateAuthorityConfigFromCpAuthToken: &vaultCertificateAuthorityConfigFromCpAuthToken,
		Type: typ,
	}
}

func (u *VaultCertificateAuthorityConfigAuth) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var vaultCertificateAuthorityConfigFromCpAuthAws VaultCertificateAuthorityConfigFromCpAuthAws = VaultCertificateAuthorityConfigFromCpAuthAws{}
	if err := utils.UnmarshalJSON(data, &vaultCertificateAuthorityConfigFromCpAuthAws, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  VaultCertificateAuthorityConfigAuthTypeVaultCertificateAuthorityConfigFromCpAuthAws,
			Value: &vaultCertificateAuthorityConfigFromCpAuthAws,
		})
	}

	var vaultCertificateAuthorityConfigFromCpAuthTLS VaultCertificateAuthorityConfigFromCpAuthTLS = VaultCertificateAuthorityConfigFromCpAuthTLS{}
	if err := utils.UnmarshalJSON(data, &vaultCertificateAuthorityConfigFromCpAuthTLS, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  VaultCertificateAuthorityConfigAuthTypeVaultCertificateAuthorityConfigFromCpAuthTLS,
			Value: &vaultCertificateAuthorityConfigFromCpAuthTLS,
		})
	}

	var vaultCertificateAuthorityConfigFromCpAuthToken VaultCertificateAuthorityConfigFromCpAuthToken = VaultCertificateAuthorityConfigFromCpAuthToken{}
	if err := utils.UnmarshalJSON(data, &vaultCertificateAuthorityConfigFromCpAuthToken, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  VaultCertificateAuthorityConfigAuthTypeVaultCertificateAuthorityConfigFromCpAuthToken,
			Value: &vaultCertificateAuthorityConfigFromCpAuthToken,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for VaultCertificateAuthorityConfigAuth", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestCandidate(candidates)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for VaultCertificateAuthorityConfigAuth", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(VaultCertificateAuthorityConfigAuthType)
	switch best.Type {
	case VaultCertificateAuthorityConfigAuthTypeVaultCertificateAuthorityConfigFromCpAuthAws:
		u.VaultCertificateAuthorityConfigFromCpAuthAws = best.Value.(*VaultCertificateAuthorityConfigFromCpAuthAws)
		return nil
	case VaultCertificateAuthorityConfigAuthTypeVaultCertificateAuthorityConfigFromCpAuthTLS:
		u.VaultCertificateAuthorityConfigFromCpAuthTLS = best.Value.(*VaultCertificateAuthorityConfigFromCpAuthTLS)
		return nil
	case VaultCertificateAuthorityConfigAuthTypeVaultCertificateAuthorityConfigFromCpAuthToken:
		u.VaultCertificateAuthorityConfigFromCpAuthToken = best.Value.(*VaultCertificateAuthorityConfigFromCpAuthToken)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for VaultCertificateAuthorityConfigAuth", string(data))
}

func (u VaultCertificateAuthorityConfigAuth) MarshalJSON() ([]byte, error) {
	if u.VaultCertificateAuthorityConfigFromCpAuthAws != nil {
		return utils.MarshalJSON(u.VaultCertificateAuthorityConfigFromCpAuthAws, "", true)
	}

	if u.VaultCertificateAuthorityConfigFromCpAuthTLS != nil {
		return utils.MarshalJSON(u.VaultCertificateAuthorityConfigFromCpAuthTLS, "", true)
	}

	if u.VaultCertificateAuthorityConfigFromCpAuthToken != nil {
		return utils.MarshalJSON(u.VaultCertificateAuthorityConfigFromCpAuthToken, "", true)
	}

	return nil, errors.New("could not marshal union type VaultCertificateAuthorityConfigAuth: all fields are null")
}

type VaultCertificateAuthorityConfigFromCpCaCertDataSourceSecret struct {
	// Data source is a secret with given Secret key.
	Secret *string `json:"secret,omitempty"`
}

func (v VaultCertificateAuthorityConfigFromCpCaCertDataSourceSecret) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(v, "", false)
}

func (v *VaultCertificateAuthorityConfigFromCpCaCertDataSourceSecret) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &v, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (v *VaultCertificateAuthorityConfigFromCpCaCertDataSourceSecret) GetSecret() *string {
	if v == nil {
		return nil
	}
	return v.Secret
}

type VaultCertificateAuthorityConfigFromCpCaCertDataSourceInlineString struct {
	// Data source is inline string
	InlineString *string `json:"inlineString,omitempty"`
}

func (v VaultCertificateAuthorityConfigFromCpCaCertDataSourceInlineString) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(v, "", false)
}

func (v *VaultCertificateAuthorityConfigFromCpCaCertDataSourceInlineString) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &v, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (v *VaultCertificateAuthorityConfigFromCpCaCertDataSourceInlineString) GetInlineString() *string {
	if v == nil {
		return nil
	}
	return v.InlineString
}

type VaultCertificateAuthorityConfigFromCpCaCertDataSourceInline struct {
	// Data source is inline bytes.
	Inline *string `json:"inline,omitempty"`
}

func (v VaultCertificateAuthorityConfigFromCpCaCertDataSourceInline) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(v, "", false)
}

func (v *VaultCertificateAuthorityConfigFromCpCaCertDataSourceInline) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &v, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (v *VaultCertificateAuthorityConfigFromCpCaCertDataSourceInline) GetInline() *string {
	if v == nil {
		return nil
	}
	return v.Inline
}

type VaultCertificateAuthorityConfigFromCpCaCertDataSourceFile struct {
	// Data source is a path to a file.
	// Deprecated, use other sources of a data.
	File *string `json:"file,omitempty"`
}

func (v VaultCertificateAuthorityConfigFromCpCaCertDataSourceFile) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(v, "", false)
}

func (v *VaultCertificateAuthorityConfigFromCpCaCertDataSourceFile) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &v, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (v *VaultCertificateAuthorityConfigFromCpCaCertDataSourceFile) GetFile() *string {
	if v == nil {
		return nil
	}
	return v.File
}

type VaultCertificateAuthorityConfigCaCertType string

const (
	VaultCertificateAuthorityConfigCaCertTypeVaultCertificateAuthorityConfigFromCpCaCertDataSourceFile         VaultCertificateAuthorityConfigCaCertType = "VaultCertificateAuthorityConfig_FromCp__caCert_DataSource_File"
	VaultCertificateAuthorityConfigCaCertTypeVaultCertificateAuthorityConfigFromCpCaCertDataSourceInline       VaultCertificateAuthorityConfigCaCertType = "VaultCertificateAuthorityConfig_FromCp__caCert_DataSource_Inline"
	VaultCertificateAuthorityConfigCaCertTypeVaultCertificateAuthorityConfigFromCpCaCertDataSourceInlineString VaultCertificateAuthorityConfigCaCertType = "VaultCertificateAuthorityConfig_FromCp__caCert_DataSource_InlineString"
	VaultCertificateAuthorityConfigCaCertTypeVaultCertificateAuthorityConfigFromCpCaCertDataSourceSecret       VaultCertificateAuthorityConfigCaCertType = "VaultCertificateAuthorityConfig_FromCp__caCert_DataSource_Secret"
)

type VaultCertificateAuthorityConfigCaCert struct {
	VaultCertificateAuthorityConfigFromCpCaCertDataSourceFile         *VaultCertificateAuthorityConfigFromCpCaCertDataSourceFile         `queryParam:"inline,name=caCert"`
	VaultCertificateAuthorityConfigFromCpCaCertDataSourceInline       *VaultCertificateAuthorityConfigFromCpCaCertDataSourceInline       `queryParam:"inline,name=caCert"`
	VaultCertificateAuthorityConfigFromCpCaCertDataSourceInlineString *VaultCertificateAuthorityConfigFromCpCaCertDataSourceInlineString `queryParam:"inline,name=caCert"`
	VaultCertificateAuthorityConfigFromCpCaCertDataSourceSecret       *VaultCertificateAuthorityConfigFromCpCaCertDataSourceSecret       `queryParam:"inline,name=caCert"`

	Type VaultCertificateAuthorityConfigCaCertType
}

func CreateVaultCertificateAuthorityConfigCaCertVaultCertificateAuthorityConfigFromCpCaCertDataSourceFile(vaultCertificateAuthorityConfigFromCpCaCertDataSourceFile VaultCertificateAuthorityConfigFromCpCaCertDataSourceFile) VaultCertificateAuthorityConfigCaCert {
	typ := VaultCertificateAuthorityConfigCaCertTypeVaultCertificateAuthorityConfigFromCpCaCertDataSourceFile

	return VaultCertificateAuthorityConfigCaCert{
		VaultCertificateAuthorityConfigFromCpCaCertDataSourceFile: &vaultCertificateAuthorityConfigFromCpCaCertDataSourceFile,
		Type: typ,
	}
}

func CreateVaultCertificateAuthorityConfigCaCertVaultCertificateAuthorityConfigFromCpCaCertDataSourceInline(vaultCertificateAuthorityConfigFromCpCaCertDataSourceInline VaultCertificateAuthorityConfigFromCpCaCertDataSourceInline) VaultCertificateAuthorityConfigCaCert {
	typ := VaultCertificateAuthorityConfigCaCertTypeVaultCertificateAuthorityConfigFromCpCaCertDataSourceInline

	return VaultCertificateAuthorityConfigCaCert{
		VaultCertificateAuthorityConfigFromCpCaCertDataSourceInline: &vaultCertificateAuthorityConfigFromCpCaCertDataSourceInline,
		Type: typ,
	}
}

func CreateVaultCertificateAuthorityConfigCaCertVaultCertificateAuthorityConfigFromCpCaCertDataSourceInlineString(vaultCertificateAuthorityConfigFromCpCaCertDataSourceInlineString VaultCertificateAuthorityConfigFromCpCaCertDataSourceInlineString) VaultCertificateAuthorityConfigCaCert {
	typ := VaultCertificateAuthorityConfigCaCertTypeVaultCertificateAuthorityConfigFromCpCaCertDataSourceInlineString

	return VaultCertificateAuthorityConfigCaCert{
		VaultCertificateAuthorityConfigFromCpCaCertDataSourceInlineString: &vaultCertificateAuthorityConfigFromCpCaCertDataSourceInlineString,
		Type: typ,
	}
}

func CreateVaultCertificateAuthorityConfigCaCertVaultCertificateAuthorityConfigFromCpCaCertDataSourceSecret(vaultCertificateAuthorityConfigFromCpCaCertDataSourceSecret VaultCertificateAuthorityConfigFromCpCaCertDataSourceSecret) VaultCertificateAuthorityConfigCaCert {
	typ := VaultCertificateAuthorityConfigCaCertTypeVaultCertificateAuthorityConfigFromCpCaCertDataSourceSecret

	return VaultCertificateAuthorityConfigCaCert{
		VaultCertificateAuthorityConfigFromCpCaCertDataSourceSecret: &vaultCertificateAuthorityConfigFromCpCaCertDataSourceSecret,
		Type: typ,
	}
}

func (u *VaultCertificateAuthorityConfigCaCert) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var vaultCertificateAuthorityConfigFromCpCaCertDataSourceFile VaultCertificateAuthorityConfigFromCpCaCertDataSourceFile = VaultCertificateAuthorityConfigFromCpCaCertDataSourceFile{}
	if err := utils.UnmarshalJSON(data, &vaultCertificateAuthorityConfigFromCpCaCertDataSourceFile, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  VaultCertificateAuthorityConfigCaCertTypeVaultCertificateAuthorityConfigFromCpCaCertDataSourceFile,
			Value: &vaultCertificateAuthorityConfigFromCpCaCertDataSourceFile,
		})
	}

	var vaultCertificateAuthorityConfigFromCpCaCertDataSourceInline VaultCertificateAuthorityConfigFromCpCaCertDataSourceInline = VaultCertificateAuthorityConfigFromCpCaCertDataSourceInline{}
	if err := utils.UnmarshalJSON(data, &vaultCertificateAuthorityConfigFromCpCaCertDataSourceInline, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  VaultCertificateAuthorityConfigCaCertTypeVaultCertificateAuthorityConfigFromCpCaCertDataSourceInline,
			Value: &vaultCertificateAuthorityConfigFromCpCaCertDataSourceInline,
		})
	}

	var vaultCertificateAuthorityConfigFromCpCaCertDataSourceInlineString VaultCertificateAuthorityConfigFromCpCaCertDataSourceInlineString = VaultCertificateAuthorityConfigFromCpCaCertDataSourceInlineString{}
	if err := utils.UnmarshalJSON(data, &vaultCertificateAuthorityConfigFromCpCaCertDataSourceInlineString, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  VaultCertificateAuthorityConfigCaCertTypeVaultCertificateAuthorityConfigFromCpCaCertDataSourceInlineString,
			Value: &vaultCertificateAuthorityConfigFromCpCaCertDataSourceInlineString,
		})
	}

	var vaultCertificateAuthorityConfigFromCpCaCertDataSourceSecret VaultCertificateAuthorityConfigFromCpCaCertDataSourceSecret = VaultCertificateAuthorityConfigFromCpCaCertDataSourceSecret{}
	if err := utils.UnmarshalJSON(data, &vaultCertificateAuthorityConfigFromCpCaCertDataSourceSecret, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  VaultCertificateAuthorityConfigCaCertTypeVaultCertificateAuthorityConfigFromCpCaCertDataSourceSecret,
			Value: &vaultCertificateAuthorityConfigFromCpCaCertDataSourceSecret,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for VaultCertificateAuthorityConfigCaCert", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestCandidate(candidates)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for VaultCertificateAuthorityConfigCaCert", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(VaultCertificateAuthorityConfigCaCertType)
	switch best.Type {
	case VaultCertificateAuthorityConfigCaCertTypeVaultCertificateAuthorityConfigFromCpCaCertDataSourceFile:
		u.VaultCertificateAuthorityConfigFromCpCaCertDataSourceFile = best.Value.(*VaultCertificateAuthorityConfigFromCpCaCertDataSourceFile)
		return nil
	case VaultCertificateAuthorityConfigCaCertTypeVaultCertificateAuthorityConfigFromCpCaCertDataSourceInline:
		u.VaultCertificateAuthorityConfigFromCpCaCertDataSourceInline = best.Value.(*VaultCertificateAuthorityConfigFromCpCaCertDataSourceInline)
		return nil
	case VaultCertificateAuthorityConfigCaCertTypeVaultCertificateAuthorityConfigFromCpCaCertDataSourceInlineString:
		u.VaultCertificateAuthorityConfigFromCpCaCertDataSourceInlineString = best.Value.(*VaultCertificateAuthorityConfigFromCpCaCertDataSourceInlineString)
		return nil
	case VaultCertificateAuthorityConfigCaCertTypeVaultCertificateAuthorityConfigFromCpCaCertDataSourceSecret:
		u.VaultCertificateAuthorityConfigFromCpCaCertDataSourceSecret = best.Value.(*VaultCertificateAuthorityConfigFromCpCaCertDataSourceSecret)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for VaultCertificateAuthorityConfigCaCert", string(data))
}

func (u VaultCertificateAuthorityConfigCaCert) MarshalJSON() ([]byte, error) {
	if u.VaultCertificateAuthorityConfigFromCpCaCertDataSourceFile != nil {
		return utils.MarshalJSON(u.VaultCertificateAuthorityConfigFromCpCaCertDataSourceFile, "", true)
	}

	if u.VaultCertificateAuthorityConfigFromCpCaCertDataSourceInline != nil {
		return utils.MarshalJSON(u.VaultCertificateAuthorityConfigFromCpCaCertDataSourceInline, "", true)
	}

	if u.VaultCertificateAuthorityConfigFromCpCaCertDataSourceInlineString != nil {
		return utils.MarshalJSON(u.VaultCertificateAuthorityConfigFromCpCaCertDataSourceInlineString, "", true)
	}

	if u.VaultCertificateAuthorityConfigFromCpCaCertDataSourceSecret != nil {
		return utils.MarshalJSON(u.VaultCertificateAuthorityConfigFromCpCaCertDataSourceSecret, "", true)
	}

	return nil, errors.New("could not marshal union type VaultCertificateAuthorityConfigCaCert: all fields are null")
}

type VaultCertificateAuthorityConfigTLS struct {
	CaCert     *VaultCertificateAuthorityConfigCaCert `json:"caCert,omitempty"`
	ServerName *string                                `json:"serverName,omitempty"`
	SkipVerify *bool                                  `json:"skipVerify,omitempty"`
}

func (v VaultCertificateAuthorityConfigTLS) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(v, "", false)
}

func (v *VaultCertificateAuthorityConfigTLS) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &v, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (v *VaultCertificateAuthorityConfigTLS) GetCaCert() *VaultCertificateAuthorityConfigCaCert {
	if v == nil {
		return nil
	}
	return v.CaCert
}

func (v *VaultCertificateAuthorityConfigTLS) GetServerName() *string {
	if v == nil {
		return nil
	}
	return v.ServerName
}

func (v *VaultCertificateAuthorityConfigTLS) GetSkipVerify() *bool {
	if v == nil {
		return nil
	}
	return v.SkipVerify
}

type FromCp struct {
	Address      *string                              `json:"address,omitempty"`
	AgentAddress *string                              `json:"agentAddress,omitempty"`
	Auth         *VaultCertificateAuthorityConfigAuth `json:"auth,omitempty"`
	CommonName   *string                              `json:"commonName,omitempty"`
	Namespace    *string                              `json:"namespace,omitempty"`
	Pki          *string                              `json:"pki,omitempty"`
	Role         *string                              `json:"role,omitempty"`
	TLS          *VaultCertificateAuthorityConfigTLS  `json:"tls,omitempty"`
}

func (f FromCp) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(f, "", false)
}

func (f *FromCp) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &f, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (f *FromCp) GetAddress() *string {
	if f == nil {
		return nil
	}
	return f.Address
}

func (f *FromCp) GetAgentAddress() *string {
	if f == nil {
		return nil
	}
	return f.AgentAddress
}

func (f *FromCp) GetAuth() *VaultCertificateAuthorityConfigAuth {
	if f == nil {
		return nil
	}
	return f.Auth
}

func (f *FromCp) GetCommonName() *string {
	if f == nil {
		return nil
	}
	return f.CommonName
}

func (f *FromCp) GetNamespace() *string {
	if f == nil {
		return nil
	}
	return f.Namespace
}

func (f *FromCp) GetPki() *string {
	if f == nil {
		return nil
	}
	return f.Pki
}

func (f *FromCp) GetRole() *string {
	if f == nil {
		return nil
	}
	return f.Role
}

func (f *FromCp) GetTLS() *VaultCertificateAuthorityConfigTLS {
	if f == nil {
		return nil
	}
	return f.TLS
}

type VaultCertificateAuthorityConfigFromCp struct {
	FromCp *FromCp `json:"fromCp,omitempty"`
}

func (v VaultCertificateAuthorityConfigFromCp) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(v, "", false)
}

func (v *VaultCertificateAuthorityConfigFromCp) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &v, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (v *VaultCertificateAuthorityConfigFromCp) GetFromCp() *FromCp {
	if v == nil {
		return nil
	}
	return v.FromCp
}

type VaultCertificateAuthorityConfigType string

const (
	VaultCertificateAuthorityConfigTypeVaultCertificateAuthorityConfigFromCp VaultCertificateAuthorityConfigType = "VaultCertificateAuthorityConfig_FromCp_"
)

type VaultCertificateAuthorityConfig struct {
	VaultCertificateAuthorityConfigFromCp *VaultCertificateAuthorityConfigFromCp `queryParam:"inline,name=VaultCertificateAuthorityConfig"`

	Type VaultCertificateAuthorityConfigType
}

func CreateVaultCertificateAuthorityConfigVaultCertificateAuthorityConfigFromCp(vaultCertificateAuthorityConfigFromCp VaultCertificateAuthorityConfigFromCp) VaultCertificateAuthorityConfig {
	typ := VaultCertificateAuthorityConfigTypeVaultCertificateAuthorityConfigFromCp

	return VaultCertificateAuthorityConfig{
		VaultCertificateAuthorityConfigFromCp: &vaultCertificateAuthorityConfigFromCp,
		Type:                                  typ,
	}
}

func (u *VaultCertificateAuthorityConfig) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var vaultCertificateAuthorityConfigFromCp VaultCertificateAuthorityConfigFromCp = VaultCertificateAuthorityConfigFromCp{}
	if err := utils.UnmarshalJSON(data, &vaultCertificateAuthorityConfigFromCp, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  VaultCertificateAuthorityConfigTypeVaultCertificateAuthorityConfigFromCp,
			Value: &vaultCertificateAuthorityConfigFromCp,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for VaultCertificateAuthorityConfig", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestCandidate(candidates)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for VaultCertificateAuthorityConfig", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(VaultCertificateAuthorityConfigType)
	switch best.Type {
	case VaultCertificateAuthorityConfigTypeVaultCertificateAuthorityConfigFromCp:
		u.VaultCertificateAuthorityConfigFromCp = best.Value.(*VaultCertificateAuthorityConfigFromCp)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for VaultCertificateAuthorityConfig", string(data))
}

func (u VaultCertificateAuthorityConfig) MarshalJSON() ([]byte, error) {
	if u.VaultCertificateAuthorityConfigFromCp != nil {
		return utils.MarshalJSON(u.VaultCertificateAuthorityConfigFromCp, "", true)
	}

	return nil, errors.New("could not marshal union type VaultCertificateAuthorityConfig: all fields are null")
}

type BuiltinCertificateAuthorityConfigConfCaCert struct {
	Expiration *string `json:"expiration,omitempty"`
	RsaBits    *int64  `json:"rsaBits,omitempty"`
}

func (b BuiltinCertificateAuthorityConfigConfCaCert) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(b, "", false)
}

func (b *BuiltinCertificateAuthorityConfigConfCaCert) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &b, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (b *BuiltinCertificateAuthorityConfigConfCaCert) GetExpiration() *string {
	if b == nil {
		return nil
	}
	return b.Expiration
}

func (b *BuiltinCertificateAuthorityConfigConfCaCert) GetRsaBits() *int64 {
	if b == nil {
		return nil
	}
	return b.RsaBits
}

type BuiltinCertificateAuthorityConfig struct {
	CaCert *BuiltinCertificateAuthorityConfigConfCaCert `json:"caCert,omitempty"`
}

func (b BuiltinCertificateAuthorityConfig) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(b, "", false)
}

func (b *BuiltinCertificateAuthorityConfig) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &b, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (b *BuiltinCertificateAuthorityConfig) GetCaCert() *BuiltinCertificateAuthorityConfigConfCaCert {
	if b == nil {
		return nil
	}
	return b.CaCert
}

type CertDataSourceSecret struct {
	// Data source is a secret with given Secret key.
	Secret *string `json:"secret,omitempty"`
}

func (c CertDataSourceSecret) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CertDataSourceSecret) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CertDataSourceSecret) GetSecret() *string {
	if c == nil {
		return nil
	}
	return c.Secret
}

type CertDataSourceInlineString struct {
	// Data source is inline string
	InlineString *string `json:"inlineString,omitempty"`
}

func (c CertDataSourceInlineString) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CertDataSourceInlineString) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CertDataSourceInlineString) GetInlineString() *string {
	if c == nil {
		return nil
	}
	return c.InlineString
}

type CertDataSourceInline struct {
	// Data source is inline bytes.
	Inline *string `json:"inline,omitempty"`
}

func (c CertDataSourceInline) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CertDataSourceInline) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CertDataSourceInline) GetInline() *string {
	if c == nil {
		return nil
	}
	return c.Inline
}

type CertDataSourceFile struct {
	// Data source is a path to a file.
	// Deprecated, use other sources of a data.
	File *string `json:"file,omitempty"`
}

func (c CertDataSourceFile) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CertDataSourceFile) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CertDataSourceFile) GetFile() *string {
	if c == nil {
		return nil
	}
	return c.File
}

type CertType string

const (
	CertTypeCertDataSourceFile         CertType = "cert_DataSource_File"
	CertTypeCertDataSourceInline       CertType = "cert_DataSource_Inline"
	CertTypeCertDataSourceInlineString CertType = "cert_DataSource_InlineString"
	CertTypeCertDataSourceSecret       CertType = "cert_DataSource_Secret"
)

type Cert struct {
	CertDataSourceFile         *CertDataSourceFile         `queryParam:"inline,name=cert"`
	CertDataSourceInline       *CertDataSourceInline       `queryParam:"inline,name=cert"`
	CertDataSourceInlineString *CertDataSourceInlineString `queryParam:"inline,name=cert"`
	CertDataSourceSecret       *CertDataSourceSecret       `queryParam:"inline,name=cert"`

	Type CertType
}

func CreateCertCertDataSourceFile(certDataSourceFile CertDataSourceFile) Cert {
	typ := CertTypeCertDataSourceFile

	return Cert{
		CertDataSourceFile: &certDataSourceFile,
		Type:               typ,
	}
}

func CreateCertCertDataSourceInline(certDataSourceInline CertDataSourceInline) Cert {
	typ := CertTypeCertDataSourceInline

	return Cert{
		CertDataSourceInline: &certDataSourceInline,
		Type:                 typ,
	}
}

func CreateCertCertDataSourceInlineString(certDataSourceInlineString CertDataSourceInlineString) Cert {
	typ := CertTypeCertDataSourceInlineString

	return Cert{
		CertDataSourceInlineString: &certDataSourceInlineString,
		Type:                       typ,
	}
}

func CreateCertCertDataSourceSecret(certDataSourceSecret CertDataSourceSecret) Cert {
	typ := CertTypeCertDataSourceSecret

	return Cert{
		CertDataSourceSecret: &certDataSourceSecret,
		Type:                 typ,
	}
}

func (u *Cert) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var certDataSourceFile CertDataSourceFile = CertDataSourceFile{}
	if err := utils.UnmarshalJSON(data, &certDataSourceFile, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  CertTypeCertDataSourceFile,
			Value: &certDataSourceFile,
		})
	}

	var certDataSourceInline CertDataSourceInline = CertDataSourceInline{}
	if err := utils.UnmarshalJSON(data, &certDataSourceInline, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  CertTypeCertDataSourceInline,
			Value: &certDataSourceInline,
		})
	}

	var certDataSourceInlineString CertDataSourceInlineString = CertDataSourceInlineString{}
	if err := utils.UnmarshalJSON(data, &certDataSourceInlineString, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  CertTypeCertDataSourceInlineString,
			Value: &certDataSourceInlineString,
		})
	}

	var certDataSourceSecret CertDataSourceSecret = CertDataSourceSecret{}
	if err := utils.UnmarshalJSON(data, &certDataSourceSecret, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  CertTypeCertDataSourceSecret,
			Value: &certDataSourceSecret,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for Cert", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestCandidate(candidates)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for Cert", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(CertType)
	switch best.Type {
	case CertTypeCertDataSourceFile:
		u.CertDataSourceFile = best.Value.(*CertDataSourceFile)
		return nil
	case CertTypeCertDataSourceInline:
		u.CertDataSourceInline = best.Value.(*CertDataSourceInline)
		return nil
	case CertTypeCertDataSourceInlineString:
		u.CertDataSourceInlineString = best.Value.(*CertDataSourceInlineString)
		return nil
	case CertTypeCertDataSourceSecret:
		u.CertDataSourceSecret = best.Value.(*CertDataSourceSecret)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Cert", string(data))
}

func (u Cert) MarshalJSON() ([]byte, error) {
	if u.CertDataSourceFile != nil {
		return utils.MarshalJSON(u.CertDataSourceFile, "", true)
	}

	if u.CertDataSourceInline != nil {
		return utils.MarshalJSON(u.CertDataSourceInline, "", true)
	}

	if u.CertDataSourceInlineString != nil {
		return utils.MarshalJSON(u.CertDataSourceInlineString, "", true)
	}

	if u.CertDataSourceSecret != nil {
		return utils.MarshalJSON(u.CertDataSourceSecret, "", true)
	}

	return nil, errors.New("could not marshal union type Cert: all fields are null")
}

type KeyDataSourceSecret struct {
	// Data source is a secret with given Secret key.
	Secret *string `json:"secret,omitempty"`
}

func (k KeyDataSourceSecret) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(k, "", false)
}

func (k *KeyDataSourceSecret) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &k, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (k *KeyDataSourceSecret) GetSecret() *string {
	if k == nil {
		return nil
	}
	return k.Secret
}

type KeyDataSourceInlineString struct {
	// Data source is inline string
	InlineString *string `json:"inlineString,omitempty"`
}

func (k KeyDataSourceInlineString) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(k, "", false)
}

func (k *KeyDataSourceInlineString) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &k, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (k *KeyDataSourceInlineString) GetInlineString() *string {
	if k == nil {
		return nil
	}
	return k.InlineString
}

type KeyDataSourceInline struct {
	// Data source is inline bytes.
	Inline *string `json:"inline,omitempty"`
}

func (k KeyDataSourceInline) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(k, "", false)
}

func (k *KeyDataSourceInline) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &k, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (k *KeyDataSourceInline) GetInline() *string {
	if k == nil {
		return nil
	}
	return k.Inline
}

type KeyDataSourceFile struct {
	// Data source is a path to a file.
	// Deprecated, use other sources of a data.
	File *string `json:"file,omitempty"`
}

func (k KeyDataSourceFile) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(k, "", false)
}

func (k *KeyDataSourceFile) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &k, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (k *KeyDataSourceFile) GetFile() *string {
	if k == nil {
		return nil
	}
	return k.File
}

type KeyType string

const (
	KeyTypeKeyDataSourceFile         KeyType = "key_DataSource_File"
	KeyTypeKeyDataSourceInline       KeyType = "key_DataSource_Inline"
	KeyTypeKeyDataSourceInlineString KeyType = "key_DataSource_InlineString"
	KeyTypeKeyDataSourceSecret       KeyType = "key_DataSource_Secret"
)

type Key struct {
	KeyDataSourceFile         *KeyDataSourceFile         `queryParam:"inline,name=key"`
	KeyDataSourceInline       *KeyDataSourceInline       `queryParam:"inline,name=key"`
	KeyDataSourceInlineString *KeyDataSourceInlineString `queryParam:"inline,name=key"`
	KeyDataSourceSecret       *KeyDataSourceSecret       `queryParam:"inline,name=key"`

	Type KeyType
}

func CreateKeyKeyDataSourceFile(keyDataSourceFile KeyDataSourceFile) Key {
	typ := KeyTypeKeyDataSourceFile

	return Key{
		KeyDataSourceFile: &keyDataSourceFile,
		Type:              typ,
	}
}

func CreateKeyKeyDataSourceInline(keyDataSourceInline KeyDataSourceInline) Key {
	typ := KeyTypeKeyDataSourceInline

	return Key{
		KeyDataSourceInline: &keyDataSourceInline,
		Type:                typ,
	}
}

func CreateKeyKeyDataSourceInlineString(keyDataSourceInlineString KeyDataSourceInlineString) Key {
	typ := KeyTypeKeyDataSourceInlineString

	return Key{
		KeyDataSourceInlineString: &keyDataSourceInlineString,
		Type:                      typ,
	}
}

func CreateKeyKeyDataSourceSecret(keyDataSourceSecret KeyDataSourceSecret) Key {
	typ := KeyTypeKeyDataSourceSecret

	return Key{
		KeyDataSourceSecret: &keyDataSourceSecret,
		Type:                typ,
	}
}

func (u *Key) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var keyDataSourceFile KeyDataSourceFile = KeyDataSourceFile{}
	if err := utils.UnmarshalJSON(data, &keyDataSourceFile, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  KeyTypeKeyDataSourceFile,
			Value: &keyDataSourceFile,
		})
	}

	var keyDataSourceInline KeyDataSourceInline = KeyDataSourceInline{}
	if err := utils.UnmarshalJSON(data, &keyDataSourceInline, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  KeyTypeKeyDataSourceInline,
			Value: &keyDataSourceInline,
		})
	}

	var keyDataSourceInlineString KeyDataSourceInlineString = KeyDataSourceInlineString{}
	if err := utils.UnmarshalJSON(data, &keyDataSourceInlineString, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  KeyTypeKeyDataSourceInlineString,
			Value: &keyDataSourceInlineString,
		})
	}

	var keyDataSourceSecret KeyDataSourceSecret = KeyDataSourceSecret{}
	if err := utils.UnmarshalJSON(data, &keyDataSourceSecret, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  KeyTypeKeyDataSourceSecret,
			Value: &keyDataSourceSecret,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for Key", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestCandidate(candidates)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for Key", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(KeyType)
	switch best.Type {
	case KeyTypeKeyDataSourceFile:
		u.KeyDataSourceFile = best.Value.(*KeyDataSourceFile)
		return nil
	case KeyTypeKeyDataSourceInline:
		u.KeyDataSourceInline = best.Value.(*KeyDataSourceInline)
		return nil
	case KeyTypeKeyDataSourceInlineString:
		u.KeyDataSourceInlineString = best.Value.(*KeyDataSourceInlineString)
		return nil
	case KeyTypeKeyDataSourceSecret:
		u.KeyDataSourceSecret = best.Value.(*KeyDataSourceSecret)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Key", string(data))
}

func (u Key) MarshalJSON() ([]byte, error) {
	if u.KeyDataSourceFile != nil {
		return utils.MarshalJSON(u.KeyDataSourceFile, "", true)
	}

	if u.KeyDataSourceInline != nil {
		return utils.MarshalJSON(u.KeyDataSourceInline, "", true)
	}

	if u.KeyDataSourceInlineString != nil {
		return utils.MarshalJSON(u.KeyDataSourceInlineString, "", true)
	}

	if u.KeyDataSourceSecret != nil {
		return utils.MarshalJSON(u.KeyDataSourceSecret, "", true)
	}

	return nil, errors.New("could not marshal union type Key: all fields are null")
}

type ProvidedCertificateAuthorityConfig struct {
	Cert *Cert `json:"cert,omitempty"`
	Key  *Key  `json:"key,omitempty"`
}

func (p ProvidedCertificateAuthorityConfig) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *ProvidedCertificateAuthorityConfig) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (p *ProvidedCertificateAuthorityConfig) GetCert() *Cert {
	if p == nil {
		return nil
	}
	return p.Cert
}

func (p *ProvidedCertificateAuthorityConfig) GetKey() *Key {
	if p == nil {
		return nil
	}
	return p.Key
}

type MeshItemMtlsConfType string

const (
	MeshItemMtlsConfTypeProvidedCertificateAuthorityConfig    MeshItemMtlsConfType = "ProvidedCertificateAuthorityConfig"
	MeshItemMtlsConfTypeBuiltinCertificateAuthorityConfig     MeshItemMtlsConfType = "BuiltinCertificateAuthorityConfig"
	MeshItemMtlsConfTypeVaultCertificateAuthorityConfig       MeshItemMtlsConfType = "VaultCertificateAuthorityConfig"
	MeshItemMtlsConfTypeACMCertificateAuthorityConfig         MeshItemMtlsConfType = "ACMCertificateAuthorityConfig"
	MeshItemMtlsConfTypeCertManagerCertificateAuthorityConfig MeshItemMtlsConfType = "CertManagerCertificateAuthorityConfig"
)

type MeshItemMtlsConf struct {
	ProvidedCertificateAuthorityConfig    *ProvidedCertificateAuthorityConfig    `queryParam:"inline,name=conf"`
	BuiltinCertificateAuthorityConfig     *BuiltinCertificateAuthorityConfig     `queryParam:"inline,name=conf"`
	VaultCertificateAuthorityConfig       *VaultCertificateAuthorityConfig       `queryParam:"inline,name=conf"`
	ACMCertificateAuthorityConfig         *ACMCertificateAuthorityConfig         `queryParam:"inline,name=conf"`
	CertManagerCertificateAuthorityConfig *CertManagerCertificateAuthorityConfig `queryParam:"inline,name=conf"`

	Type MeshItemMtlsConfType
}

func CreateMeshItemMtlsConfProvidedCertificateAuthorityConfig(providedCertificateAuthorityConfig ProvidedCertificateAuthorityConfig) MeshItemMtlsConf {
	typ := MeshItemMtlsConfTypeProvidedCertificateAuthorityConfig

	return MeshItemMtlsConf{
		ProvidedCertificateAuthorityConfig: &providedCertificateAuthorityConfig,
		Type:                               typ,
	}
}

func CreateMeshItemMtlsConfBuiltinCertificateAuthorityConfig(builtinCertificateAuthorityConfig BuiltinCertificateAuthorityConfig) MeshItemMtlsConf {
	typ := MeshItemMtlsConfTypeBuiltinCertificateAuthorityConfig

	return MeshItemMtlsConf{
		BuiltinCertificateAuthorityConfig: &builtinCertificateAuthorityConfig,
		Type:                              typ,
	}
}

func CreateMeshItemMtlsConfVaultCertificateAuthorityConfig(vaultCertificateAuthorityConfig VaultCertificateAuthorityConfig) MeshItemMtlsConf {
	typ := MeshItemMtlsConfTypeVaultCertificateAuthorityConfig

	return MeshItemMtlsConf{
		VaultCertificateAuthorityConfig: &vaultCertificateAuthorityConfig,
		Type:                            typ,
	}
}

func CreateMeshItemMtlsConfACMCertificateAuthorityConfig(acmCertificateAuthorityConfig ACMCertificateAuthorityConfig) MeshItemMtlsConf {
	typ := MeshItemMtlsConfTypeACMCertificateAuthorityConfig

	return MeshItemMtlsConf{
		ACMCertificateAuthorityConfig: &acmCertificateAuthorityConfig,
		Type:                          typ,
	}
}

func CreateMeshItemMtlsConfCertManagerCertificateAuthorityConfig(certManagerCertificateAuthorityConfig CertManagerCertificateAuthorityConfig) MeshItemMtlsConf {
	typ := MeshItemMtlsConfTypeCertManagerCertificateAuthorityConfig

	return MeshItemMtlsConf{
		CertManagerCertificateAuthorityConfig: &certManagerCertificateAuthorityConfig,
		Type:                                  typ,
	}
}

func (u *MeshItemMtlsConf) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var providedCertificateAuthorityConfig ProvidedCertificateAuthorityConfig = ProvidedCertificateAuthorityConfig{}
	if err := utils.UnmarshalJSON(data, &providedCertificateAuthorityConfig, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  MeshItemMtlsConfTypeProvidedCertificateAuthorityConfig,
			Value: &providedCertificateAuthorityConfig,
		})
	}

	var builtinCertificateAuthorityConfig BuiltinCertificateAuthorityConfig = BuiltinCertificateAuthorityConfig{}
	if err := utils.UnmarshalJSON(data, &builtinCertificateAuthorityConfig, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  MeshItemMtlsConfTypeBuiltinCertificateAuthorityConfig,
			Value: &builtinCertificateAuthorityConfig,
		})
	}

	var vaultCertificateAuthorityConfig VaultCertificateAuthorityConfig = VaultCertificateAuthorityConfig{}
	if err := utils.UnmarshalJSON(data, &vaultCertificateAuthorityConfig, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  MeshItemMtlsConfTypeVaultCertificateAuthorityConfig,
			Value: &vaultCertificateAuthorityConfig,
		})
	}

	var acmCertificateAuthorityConfig ACMCertificateAuthorityConfig = ACMCertificateAuthorityConfig{}
	if err := utils.UnmarshalJSON(data, &acmCertificateAuthorityConfig, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  MeshItemMtlsConfTypeACMCertificateAuthorityConfig,
			Value: &acmCertificateAuthorityConfig,
		})
	}

	var certManagerCertificateAuthorityConfig CertManagerCertificateAuthorityConfig = CertManagerCertificateAuthorityConfig{}
	if err := utils.UnmarshalJSON(data, &certManagerCertificateAuthorityConfig, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  MeshItemMtlsConfTypeCertManagerCertificateAuthorityConfig,
			Value: &certManagerCertificateAuthorityConfig,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for MeshItemMtlsConf", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestCandidate(candidates)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for MeshItemMtlsConf", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(MeshItemMtlsConfType)
	switch best.Type {
	case MeshItemMtlsConfTypeProvidedCertificateAuthorityConfig:
		u.ProvidedCertificateAuthorityConfig = best.Value.(*ProvidedCertificateAuthorityConfig)
		return nil
	case MeshItemMtlsConfTypeBuiltinCertificateAuthorityConfig:
		u.BuiltinCertificateAuthorityConfig = best.Value.(*BuiltinCertificateAuthorityConfig)
		return nil
	case MeshItemMtlsConfTypeVaultCertificateAuthorityConfig:
		u.VaultCertificateAuthorityConfig = best.Value.(*VaultCertificateAuthorityConfig)
		return nil
	case MeshItemMtlsConfTypeACMCertificateAuthorityConfig:
		u.ACMCertificateAuthorityConfig = best.Value.(*ACMCertificateAuthorityConfig)
		return nil
	case MeshItemMtlsConfTypeCertManagerCertificateAuthorityConfig:
		u.CertManagerCertificateAuthorityConfig = best.Value.(*CertManagerCertificateAuthorityConfig)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for MeshItemMtlsConf", string(data))
}

func (u MeshItemMtlsConf) MarshalJSON() ([]byte, error) {
	if u.ProvidedCertificateAuthorityConfig != nil {
		return utils.MarshalJSON(u.ProvidedCertificateAuthorityConfig, "", true)
	}

	if u.BuiltinCertificateAuthorityConfig != nil {
		return utils.MarshalJSON(u.BuiltinCertificateAuthorityConfig, "", true)
	}

	if u.VaultCertificateAuthorityConfig != nil {
		return utils.MarshalJSON(u.VaultCertificateAuthorityConfig, "", true)
	}

	if u.ACMCertificateAuthorityConfig != nil {
		return utils.MarshalJSON(u.ACMCertificateAuthorityConfig, "", true)
	}

	if u.CertManagerCertificateAuthorityConfig != nil {
		return utils.MarshalJSON(u.CertManagerCertificateAuthorityConfig, "", true)
	}

	return nil, errors.New("could not marshal union type MeshItemMtlsConf: all fields are null")
}

// RequestTimeout - Timeout on request to CA for DP certificate generation and retrieval
type RequestTimeout struct {
	Nanos   *int64 `json:"nanos,omitempty"`
	Seconds *int64 `json:"seconds,omitempty"`
}

func (r *RequestTimeout) GetNanos() *int64 {
	if r == nil {
		return nil
	}
	return r.Nanos
}

func (r *RequestTimeout) GetSeconds() *int64 {
	if r == nil {
		return nil
	}
	return r.Seconds
}

// Rotation settings
type Rotation struct {
	// Time after which generated certificate for Dataplane will expire
	Expiration *string `json:"expiration,omitempty"`
}

func (r *Rotation) GetExpiration() *string {
	if r == nil {
		return nil
	}
	return r.Expiration
}

// DpCert - Dataplane certificate settings
type DpCert struct {
	// Timeout on request to CA for DP certificate generation and retrieval
	RequestTimeout *RequestTimeout `json:"requestTimeout,omitempty"`
	// Rotation settings
	Rotation *Rotation `json:"rotation,omitempty"`
}

func (d *DpCert) GetRequestTimeout() *RequestTimeout {
	if d == nil {
		return nil
	}
	return d.RequestTimeout
}

func (d *DpCert) GetRotation() *Rotation {
	if d == nil {
		return nil
	}
	return d.Rotation
}

type MeshItemModeType string

const (
	MeshItemModeTypeStr     MeshItemModeType = "str"
	MeshItemModeTypeInteger MeshItemModeType = "integer"
)

// MeshItemMode - Mode defines the behaviour of inbound listeners with regard to traffic
// encryption
type MeshItemMode struct {
	Str     *string `queryParam:"inline,name=mode"`
	Integer *int64  `queryParam:"inline,name=mode"`

	Type MeshItemModeType
}

func CreateMeshItemModeStr(str string) MeshItemMode {
	typ := MeshItemModeTypeStr

	return MeshItemMode{
		Str:  &str,
		Type: typ,
	}
}

func CreateMeshItemModeInteger(integer int64) MeshItemMode {
	typ := MeshItemModeTypeInteger

	return MeshItemMode{
		Integer: &integer,
		Type:    typ,
	}
}

func (u *MeshItemMode) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  MeshItemModeTypeStr,
			Value: &str,
		})
	}

	var integer int64 = int64(0)
	if err := utils.UnmarshalJSON(data, &integer, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  MeshItemModeTypeInteger,
			Value: &integer,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for MeshItemMode", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestCandidate(candidates)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for MeshItemMode", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(MeshItemModeType)
	switch best.Type {
	case MeshItemModeTypeStr:
		u.Str = best.Value.(*string)
		return nil
	case MeshItemModeTypeInteger:
		u.Integer = best.Value.(*int64)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for MeshItemMode", string(data))
}

func (u MeshItemMode) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Integer != nil {
		return utils.MarshalJSON(u.Integer, "", true)
	}

	return nil, errors.New("could not marshal union type MeshItemMode: all fields are null")
}

// MeshItemRequestTimeout - Timeout on request for to CA for root certificate chain.
// If not specified, defaults to 10s.
type MeshItemRequestTimeout struct {
	Nanos   *int64 `json:"nanos,omitempty"`
	Seconds *int64 `json:"seconds,omitempty"`
}

func (m *MeshItemRequestTimeout) GetNanos() *int64 {
	if m == nil {
		return nil
	}
	return m.Nanos
}

func (m *MeshItemRequestTimeout) GetSeconds() *int64 {
	if m == nil {
		return nil
	}
	return m.Seconds
}

type RootChain struct {
	// Timeout on request for to CA for root certificate chain.
	// If not specified, defaults to 10s.
	RequestTimeout *MeshItemRequestTimeout `json:"requestTimeout,omitempty"`
}

func (r *RootChain) GetRequestTimeout() *MeshItemRequestTimeout {
	if r == nil {
		return nil
	}
	return r.RequestTimeout
}

// MeshItemMtlsBackends - CertificateAuthorityBackend defines Certificate Authority backend
type MeshItemMtlsBackends struct {
	Conf *MeshItemMtlsConf `json:"conf,omitempty"`
	// Dataplane certificate settings
	DpCert *DpCert `json:"dpCert,omitempty"`
	// Mode defines the behaviour of inbound listeners with regard to traffic
	// encryption
	Mode *MeshItemMode `json:"mode,omitempty"`
	// Name of the backend
	Name      *string    `json:"name,omitempty"`
	RootChain *RootChain `json:"rootChain,omitempty"`
	// Type of the backend. Has to be one of the loaded plugins (Kuma ships with
	// builtin and provided)
	Type *string `json:"type,omitempty"`
}

func (m *MeshItemMtlsBackends) GetConf() *MeshItemMtlsConf {
	if m == nil {
		return nil
	}
	return m.Conf
}

func (m *MeshItemMtlsBackends) GetDpCert() *DpCert {
	if m == nil {
		return nil
	}
	return m.DpCert
}

func (m *MeshItemMtlsBackends) GetMode() *MeshItemMode {
	if m == nil {
		return nil
	}
	return m.Mode
}

func (m *MeshItemMtlsBackends) GetName() *string {
	if m == nil {
		return nil
	}
	return m.Name
}

func (m *MeshItemMtlsBackends) GetRootChain() *RootChain {
	if m == nil {
		return nil
	}
	return m.RootChain
}

func (m *MeshItemMtlsBackends) GetType() *string {
	if m == nil {
		return nil
	}
	return m.Type
}

// Mtls - mTLS settings.
// +optional
type Mtls struct {
	// List of available Certificate Authority backends
	Backends []MeshItemMtlsBackends `json:"backends,omitempty"`
	// Name of the enabled backend
	EnabledBackend *string `json:"enabledBackend,omitempty"`
	// If enabled, skips CA validation.
	SkipValidation *bool `json:"skipValidation,omitempty"`
}

func (m *Mtls) GetBackends() []MeshItemMtlsBackends {
	if m == nil {
		return nil
	}
	return m.Backends
}

func (m *Mtls) GetEnabledBackend() *string {
	if m == nil {
		return nil
	}
	return m.EnabledBackend
}

func (m *Mtls) GetSkipValidation() *bool {
	if m == nil {
		return nil
	}
	return m.SkipValidation
}

// Outbound settings
type Outbound struct {
	// Control the passthrough cluster
	Passthrough *bool `json:"passthrough,omitempty"`
}

func (o *Outbound) GetPassthrough() *bool {
	if o == nil {
		return nil
	}
	return o.Passthrough
}

// Networking settings of the mesh
type Networking struct {
	// Outbound settings
	Outbound *Outbound `json:"outbound,omitempty"`
}

func (n *Networking) GetOutbound() *Outbound {
	if n == nil {
		return nil
	}
	return n.Outbound
}

// Routing settings of the mesh
type Routing struct {
	// If true, blocks traffic to MeshExternalServices.
	// Default: false
	DefaultForbidMeshExternalServiceAccess *bool `json:"defaultForbidMeshExternalServiceAccess,omitempty"`
	// Enable the Locality Aware Load Balancing
	LocalityAwareLoadBalancing *bool `json:"localityAwareLoadBalancing,omitempty"`
	// Enable routing traffic to services in other zone or external services
	// through ZoneEgress. Default: false
	ZoneEgress *bool `json:"zoneEgress,omitempty"`
}

func (r *Routing) GetDefaultForbidMeshExternalServiceAccess() *bool {
	if r == nil {
		return nil
	}
	return r.DefaultForbidMeshExternalServiceAccess
}

func (r *Routing) GetLocalityAwareLoadBalancing() *bool {
	if r == nil {
		return nil
	}
	return r.LocalityAwareLoadBalancing
}

func (r *Routing) GetZoneEgress() *bool {
	if r == nil {
		return nil
	}
	return r.ZoneEgress
}

type ZipkinTracingBackendConfig struct {
	// Version of the API. values: httpJson, httpJsonV1, httpProto. Default:
	// httpJson see
	// https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/trace/v3/trace.proto#envoy-v3-api-enum-config-trace-v3-zipkinconfig-collectorendpointversion
	APIVersion *string `json:"apiVersion,omitempty"`
	// Determines whether client and server spans will share the same span
	// context. Default: true.
	// https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/trace/v3/zipkin.proto#config-trace-v3-zipkinconfig
	SharedSpanContext *bool `json:"sharedSpanContext,omitempty"`
	// Generate 128bit traces. Default: false
	TraceId128bit *bool `json:"traceId128bit,omitempty"`
	// Address of Zipkin collector.
	URL *string `json:"url,omitempty"`
}

func (z ZipkinTracingBackendConfig) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(z, "", false)
}

func (z *ZipkinTracingBackendConfig) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &z, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (z *ZipkinTracingBackendConfig) GetAPIVersion() *string {
	if z == nil {
		return nil
	}
	return z.APIVersion
}

func (z *ZipkinTracingBackendConfig) GetSharedSpanContext() *bool {
	if z == nil {
		return nil
	}
	return z.SharedSpanContext
}

func (z *ZipkinTracingBackendConfig) GetTraceId128bit() *bool {
	if z == nil {
		return nil
	}
	return z.TraceId128bit
}

func (z *ZipkinTracingBackendConfig) GetURL() *string {
	if z == nil {
		return nil
	}
	return z.URL
}

type DatadogTracingBackendConfig struct {
	// Address of datadog collector.
	Address *string `json:"address,omitempty"`
	// Port of datadog collector
	Port *int64 `json:"port,omitempty"`
	// Determines if datadog service name should be split based on traffic
	// direction and destination. For example, with `splitService: true` and a
	// `backend` service that communicates with a couple of databases, you would
	// get service names like `backend_INBOUND`, `backend_OUTBOUND_db1`, and
	// `backend_OUTBOUND_db2` in Datadog. Default: false
	SplitService *bool `json:"splitService,omitempty"`
}

func (d DatadogTracingBackendConfig) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DatadogTracingBackendConfig) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DatadogTracingBackendConfig) GetAddress() *string {
	if d == nil {
		return nil
	}
	return d.Address
}

func (d *DatadogTracingBackendConfig) GetPort() *int64 {
	if d == nil {
		return nil
	}
	return d.Port
}

func (d *DatadogTracingBackendConfig) GetSplitService() *bool {
	if d == nil {
		return nil
	}
	return d.SplitService
}

type MeshItemTracingConfType string

const (
	MeshItemTracingConfTypeDatadogTracingBackendConfig MeshItemTracingConfType = "DatadogTracingBackendConfig"
	MeshItemTracingConfTypeZipkinTracingBackendConfig  MeshItemTracingConfType = "ZipkinTracingBackendConfig"
)

type MeshItemTracingConf struct {
	DatadogTracingBackendConfig *DatadogTracingBackendConfig `queryParam:"inline,name=conf"`
	ZipkinTracingBackendConfig  *ZipkinTracingBackendConfig  `queryParam:"inline,name=conf"`

	Type MeshItemTracingConfType
}

func CreateMeshItemTracingConfDatadogTracingBackendConfig(datadogTracingBackendConfig DatadogTracingBackendConfig) MeshItemTracingConf {
	typ := MeshItemTracingConfTypeDatadogTracingBackendConfig

	return MeshItemTracingConf{
		DatadogTracingBackendConfig: &datadogTracingBackendConfig,
		Type:                        typ,
	}
}

func CreateMeshItemTracingConfZipkinTracingBackendConfig(zipkinTracingBackendConfig ZipkinTracingBackendConfig) MeshItemTracingConf {
	typ := MeshItemTracingConfTypeZipkinTracingBackendConfig

	return MeshItemTracingConf{
		ZipkinTracingBackendConfig: &zipkinTracingBackendConfig,
		Type:                       typ,
	}
}

func (u *MeshItemTracingConf) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var datadogTracingBackendConfig DatadogTracingBackendConfig = DatadogTracingBackendConfig{}
	if err := utils.UnmarshalJSON(data, &datadogTracingBackendConfig, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  MeshItemTracingConfTypeDatadogTracingBackendConfig,
			Value: &datadogTracingBackendConfig,
		})
	}

	var zipkinTracingBackendConfig ZipkinTracingBackendConfig = ZipkinTracingBackendConfig{}
	if err := utils.UnmarshalJSON(data, &zipkinTracingBackendConfig, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  MeshItemTracingConfTypeZipkinTracingBackendConfig,
			Value: &zipkinTracingBackendConfig,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for MeshItemTracingConf", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestCandidate(candidates)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for MeshItemTracingConf", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(MeshItemTracingConfType)
	switch best.Type {
	case MeshItemTracingConfTypeDatadogTracingBackendConfig:
		u.DatadogTracingBackendConfig = best.Value.(*DatadogTracingBackendConfig)
		return nil
	case MeshItemTracingConfTypeZipkinTracingBackendConfig:
		u.ZipkinTracingBackendConfig = best.Value.(*ZipkinTracingBackendConfig)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for MeshItemTracingConf", string(data))
}

func (u MeshItemTracingConf) MarshalJSON() ([]byte, error) {
	if u.DatadogTracingBackendConfig != nil {
		return utils.MarshalJSON(u.DatadogTracingBackendConfig, "", true)
	}

	if u.ZipkinTracingBackendConfig != nil {
		return utils.MarshalJSON(u.ZipkinTracingBackendConfig, "", true)
	}

	return nil, errors.New("could not marshal union type MeshItemTracingConf: all fields are null")
}

// MeshItemTracingBackends - TracingBackend defines tracing backend available to mesh.
type MeshItemTracingBackends struct {
	Conf *MeshItemTracingConf `json:"conf,omitempty"`
	// Name of the backend, can be then used in Mesh.tracing.defaultBackend or in
	// TrafficTrace
	Name *string `json:"name,omitempty"`
	// Percentage of traces that will be sent to the backend (range 0.0 - 100.0).
	// Empty value defaults to 100.0%
	Sampling *float64 `json:"sampling,omitempty"`
	// Type of the backend (Kuma ships with 'zipkin')
	Type *string `json:"type,omitempty"`
}

func (m *MeshItemTracingBackends) GetConf() *MeshItemTracingConf {
	if m == nil {
		return nil
	}
	return m.Conf
}

func (m *MeshItemTracingBackends) GetName() *string {
	if m == nil {
		return nil
	}
	return m.Name
}

func (m *MeshItemTracingBackends) GetSampling() *float64 {
	if m == nil {
		return nil
	}
	return m.Sampling
}

func (m *MeshItemTracingBackends) GetType() *string {
	if m == nil {
		return nil
	}
	return m.Type
}

// Tracing settings.
// +optional
type Tracing struct {
	// List of available tracing backends
	Backends []MeshItemTracingBackends `json:"backends,omitempty"`
	// Name of the default backend
	DefaultBackend *string `json:"defaultBackend,omitempty"`
}

func (t *Tracing) GetBackends() []MeshItemTracingBackends {
	if t == nil {
		return nil
	}
	return t.Backends
}

func (t *Tracing) GetDefaultBackend() *string {
	if t == nil {
		return nil
	}
	return t.DefaultBackend
}

// MeshItem - Successful response
type MeshItem struct {
	// Constraints that applies to the mesh and its entities
	Constraints *Constraints      `json:"constraints,omitempty"`
	Labels      map[string]string `json:"labels,omitempty"`
	// Logging settings.
	// +optional
	Logging      *Logging      `json:"logging,omitempty"`
	MeshServices *MeshServices `json:"meshServices,omitempty"`
	// Configuration for metrics collected and exposed by dataplanes.
	//
	// Settings defined here become defaults for every dataplane in a given Mesh.
	// Additionally, it is also possible to further customize this configuration
	// for each dataplane individually using Dataplane resource.
	// +optional
	Metrics *Metrics `json:"metrics,omitempty"`
	// mTLS settings.
	// +optional
	Mtls *Mtls  `json:"mtls,omitempty"`
	Name string `json:"name"`
	// Networking settings of the mesh
	Networking *Networking `json:"networking,omitempty"`
	// Routing settings of the mesh
	Routing *Routing `json:"routing,omitempty"`
	// List of policies to skip creating by default when the mesh is created.
	// e.g. TrafficPermission, MeshRetry, etc. An '*' can be used to skip all
	// policies.
	SkipCreatingInitialPolicies []string `json:"skipCreatingInitialPolicies,omitempty"`
	// Tracing settings.
	// +optional
	Tracing *Tracing `json:"tracing,omitempty"`
	Type    string   `json:"type"`
}

func (m *MeshItem) GetConstraints() *Constraints {
	if m == nil {
		return nil
	}
	return m.Constraints
}

func (m *MeshItem) GetLabels() map[string]string {
	if m == nil {
		return nil
	}
	return m.Labels
}

func (m *MeshItem) GetLogging() *Logging {
	if m == nil {
		return nil
	}
	return m.Logging
}

func (m *MeshItem) GetMeshServices() *MeshServices {
	if m == nil {
		return nil
	}
	return m.MeshServices
}

func (m *MeshItem) GetMetrics() *Metrics {
	if m == nil {
		return nil
	}
	return m.Metrics
}

func (m *MeshItem) GetMtls() *Mtls {
	if m == nil {
		return nil
	}
	return m.Mtls
}

func (m *MeshItem) GetName() string {
	if m == nil {
		return ""
	}
	return m.Name
}

func (m *MeshItem) GetNetworking() *Networking {
	if m == nil {
		return nil
	}
	return m.Networking
}

func (m *MeshItem) GetRouting() *Routing {
	if m == nil {
		return nil
	}
	return m.Routing
}

func (m *MeshItem) GetSkipCreatingInitialPolicies() []string {
	if m == nil {
		return nil
	}
	return m.SkipCreatingInitialPolicies
}

func (m *MeshItem) GetTracing() *Tracing {
	if m == nil {
		return nil
	}
	return m.Tracing
}

func (m *MeshItem) GetType() string {
	if m == nil {
		return ""
	}
	return m.Type
}
