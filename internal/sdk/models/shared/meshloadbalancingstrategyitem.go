// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/kong/terraform-provider-kong-mesh/internal/sdk/internal/utils"
	"time"
)

// MeshLoadBalancingStrategyItemType - the type of the resource
type MeshLoadBalancingStrategyItemType string

const (
	MeshLoadBalancingStrategyItemTypeMeshLoadBalancingStrategy MeshLoadBalancingStrategyItemType = "MeshLoadBalancingStrategy"
)

func (e MeshLoadBalancingStrategyItemType) ToPointer() *MeshLoadBalancingStrategyItemType {
	return &e
}
func (e *MeshLoadBalancingStrategyItemType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "MeshLoadBalancingStrategy":
		*e = MeshLoadBalancingStrategyItemType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshLoadBalancingStrategyItemType: %v", v)
	}
}

// MeshLoadBalancingStrategyItemKind - Kind of the referenced resource
type MeshLoadBalancingStrategyItemKind string

const (
	MeshLoadBalancingStrategyItemKindMesh                 MeshLoadBalancingStrategyItemKind = "Mesh"
	MeshLoadBalancingStrategyItemKindMeshSubset           MeshLoadBalancingStrategyItemKind = "MeshSubset"
	MeshLoadBalancingStrategyItemKindMeshGateway          MeshLoadBalancingStrategyItemKind = "MeshGateway"
	MeshLoadBalancingStrategyItemKindMeshService          MeshLoadBalancingStrategyItemKind = "MeshService"
	MeshLoadBalancingStrategyItemKindMeshExternalService  MeshLoadBalancingStrategyItemKind = "MeshExternalService"
	MeshLoadBalancingStrategyItemKindMeshMultiZoneService MeshLoadBalancingStrategyItemKind = "MeshMultiZoneService"
	MeshLoadBalancingStrategyItemKindMeshServiceSubset    MeshLoadBalancingStrategyItemKind = "MeshServiceSubset"
	MeshLoadBalancingStrategyItemKindMeshHTTPRoute        MeshLoadBalancingStrategyItemKind = "MeshHTTPRoute"
	MeshLoadBalancingStrategyItemKindDataplane            MeshLoadBalancingStrategyItemKind = "Dataplane"
)

func (e MeshLoadBalancingStrategyItemKind) ToPointer() *MeshLoadBalancingStrategyItemKind {
	return &e
}
func (e *MeshLoadBalancingStrategyItemKind) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Mesh":
		fallthrough
	case "MeshSubset":
		fallthrough
	case "MeshGateway":
		fallthrough
	case "MeshService":
		fallthrough
	case "MeshExternalService":
		fallthrough
	case "MeshMultiZoneService":
		fallthrough
	case "MeshServiceSubset":
		fallthrough
	case "MeshHTTPRoute":
		fallthrough
	case "Dataplane":
		*e = MeshLoadBalancingStrategyItemKind(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshLoadBalancingStrategyItemKind: %v", v)
	}
}

type MeshLoadBalancingStrategyItemProxyTypes string

const (
	MeshLoadBalancingStrategyItemProxyTypesSidecar MeshLoadBalancingStrategyItemProxyTypes = "Sidecar"
	MeshLoadBalancingStrategyItemProxyTypesGateway MeshLoadBalancingStrategyItemProxyTypes = "Gateway"
)

func (e MeshLoadBalancingStrategyItemProxyTypes) ToPointer() *MeshLoadBalancingStrategyItemProxyTypes {
	return &e
}
func (e *MeshLoadBalancingStrategyItemProxyTypes) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Sidecar":
		fallthrough
	case "Gateway":
		*e = MeshLoadBalancingStrategyItemProxyTypes(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshLoadBalancingStrategyItemProxyTypes: %v", v)
	}
}

// MeshLoadBalancingStrategyItemTargetRef - TargetRef is a reference to the resource the policy takes an effect on.
// The resource could be either a real store object or virtual resource
// defined inplace.
type MeshLoadBalancingStrategyItemTargetRef struct {
	// Kind of the referenced resource
	Kind MeshLoadBalancingStrategyItemKind `json:"kind"`
	// Labels are used to select group of MeshServices that match labels. Either Labels or
	// Name and Namespace can be used.
	Labels map[string]string `json:"labels,omitempty"`
	// Mesh is reserved for future use to identify cross mesh resources.
	Mesh *string `json:"mesh,omitempty"`
	// Name of the referenced resource. Can only be used with kinds: `MeshService`,
	// `MeshServiceSubset` and `MeshGatewayRoute`
	Name *string `json:"name,omitempty"`
	// Namespace specifies the namespace of target resource. If empty only resources in policy namespace
	// will be targeted.
	Namespace *string `json:"namespace,omitempty"`
	// ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
	// all data plane types are targeted by the policy.
	ProxyTypes []MeshLoadBalancingStrategyItemProxyTypes `json:"proxyTypes,omitempty"`
	// SectionName is used to target specific section of resource.
	// For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected.
	SectionName *string `json:"sectionName,omitempty"`
	// Tags used to select a subset of proxies by tags. Can only be used with kinds
	// `MeshSubset` and `MeshServiceSubset`
	Tags map[string]string `json:"tags,omitempty"`
}

func (m *MeshLoadBalancingStrategyItemTargetRef) GetKind() MeshLoadBalancingStrategyItemKind {
	if m == nil {
		return MeshLoadBalancingStrategyItemKind("")
	}
	return m.Kind
}

func (m *MeshLoadBalancingStrategyItemTargetRef) GetLabels() map[string]string {
	if m == nil {
		return nil
	}
	return m.Labels
}

func (m *MeshLoadBalancingStrategyItemTargetRef) GetMesh() *string {
	if m == nil {
		return nil
	}
	return m.Mesh
}

func (m *MeshLoadBalancingStrategyItemTargetRef) GetName() *string {
	if m == nil {
		return nil
	}
	return m.Name
}

func (m *MeshLoadBalancingStrategyItemTargetRef) GetNamespace() *string {
	if m == nil {
		return nil
	}
	return m.Namespace
}

func (m *MeshLoadBalancingStrategyItemTargetRef) GetProxyTypes() []MeshLoadBalancingStrategyItemProxyTypes {
	if m == nil {
		return nil
	}
	return m.ProxyTypes
}

func (m *MeshLoadBalancingStrategyItemTargetRef) GetSectionName() *string {
	if m == nil {
		return nil
	}
	return m.SectionName
}

func (m *MeshLoadBalancingStrategyItemTargetRef) GetTags() map[string]string {
	if m == nil {
		return nil
	}
	return m.Tags
}

type Connection struct {
	// Hash on source IP address.
	SourceIP *bool `json:"sourceIP,omitempty"`
}

func (c *Connection) GetSourceIP() *bool {
	if c == nil {
		return nil
	}
	return c.SourceIP
}

type Cookie struct {
	// The name of the cookie that will be used to obtain the hash key.
	Name string `json:"name"`
	// The name of the path for the cookie.
	Path *string `json:"path,omitempty"`
	// If specified, a cookie with the TTL will be generated if the cookie is not present.
	TTL *string `json:"ttl,omitempty"`
}

func (c *Cookie) GetName() string {
	if c == nil {
		return ""
	}
	return c.Name
}

func (c *Cookie) GetPath() *string {
	if c == nil {
		return nil
	}
	return c.Path
}

func (c *Cookie) GetTTL() *string {
	if c == nil {
		return nil
	}
	return c.TTL
}

type FilterState struct {
	// The name of the Object in the per-request filterState, which is
	// an Envoy::Hashable object. If there is no data associated with the key,
	// or the stored object is not Envoy::Hashable, no hash will be produced.
	Key string `json:"key"`
}

func (f *FilterState) GetKey() string {
	if f == nil {
		return ""
	}
	return f.Key
}

type MeshLoadBalancingStrategyItemHeader struct {
	// The name of the request header that will be used to obtain the hash key.
	Name string `json:"name"`
}

func (m *MeshLoadBalancingStrategyItemHeader) GetName() string {
	if m == nil {
		return ""
	}
	return m.Name
}

type QueryParameter struct {
	// The name of the URL query parameter that will be used to obtain the hash key.
	// If the parameter is not present, no hash will be produced. Query parameter names
	// are case-sensitive.
	Name string `json:"name"`
}

func (q *QueryParameter) GetName() string {
	if q == nil {
		return ""
	}
	return q.Name
}

type MeshLoadBalancingStrategyItemSpecType string

const (
	MeshLoadBalancingStrategyItemSpecTypeHeader         MeshLoadBalancingStrategyItemSpecType = "Header"
	MeshLoadBalancingStrategyItemSpecTypeCookie         MeshLoadBalancingStrategyItemSpecType = "Cookie"
	MeshLoadBalancingStrategyItemSpecTypeConnection     MeshLoadBalancingStrategyItemSpecType = "Connection"
	MeshLoadBalancingStrategyItemSpecTypeSourceIP       MeshLoadBalancingStrategyItemSpecType = "SourceIP"
	MeshLoadBalancingStrategyItemSpecTypeQueryParameter MeshLoadBalancingStrategyItemSpecType = "QueryParameter"
	MeshLoadBalancingStrategyItemSpecTypeFilterState    MeshLoadBalancingStrategyItemSpecType = "FilterState"
)

func (e MeshLoadBalancingStrategyItemSpecType) ToPointer() *MeshLoadBalancingStrategyItemSpecType {
	return &e
}
func (e *MeshLoadBalancingStrategyItemSpecType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Header":
		fallthrough
	case "Cookie":
		fallthrough
	case "Connection":
		fallthrough
	case "SourceIP":
		fallthrough
	case "QueryParameter":
		fallthrough
	case "FilterState":
		*e = MeshLoadBalancingStrategyItemSpecType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshLoadBalancingStrategyItemSpecType: %v", v)
	}
}

type HashPolicies struct {
	Connection     *Connection                          `json:"connection,omitempty"`
	Cookie         *Cookie                              `json:"cookie,omitempty"`
	FilterState    *FilterState                         `json:"filterState,omitempty"`
	Header         *MeshLoadBalancingStrategyItemHeader `json:"header,omitempty"`
	QueryParameter *QueryParameter                      `json:"queryParameter,omitempty"`
	// Terminal is a flag that short-circuits the hash computing. This field provides
	// a ‘fallback’ style of configuration: “if a terminal policy doesn’t work, fallback
	// to rest of the policy list”, it saves time when the terminal policy works.
	// If true, and there is already a hash computed, ignore rest of the list of hash polices.
	Terminal *bool                                 `json:"terminal,omitempty"`
	Type     MeshLoadBalancingStrategyItemSpecType `json:"type"`
}

func (h *HashPolicies) GetConnection() *Connection {
	if h == nil {
		return nil
	}
	return h.Connection
}

func (h *HashPolicies) GetCookie() *Cookie {
	if h == nil {
		return nil
	}
	return h.Cookie
}

func (h *HashPolicies) GetFilterState() *FilterState {
	if h == nil {
		return nil
	}
	return h.FilterState
}

func (h *HashPolicies) GetHeader() *MeshLoadBalancingStrategyItemHeader {
	if h == nil {
		return nil
	}
	return h.Header
}

func (h *HashPolicies) GetQueryParameter() *QueryParameter {
	if h == nil {
		return nil
	}
	return h.QueryParameter
}

func (h *HashPolicies) GetTerminal() *bool {
	if h == nil {
		return nil
	}
	return h.Terminal
}

func (h *HashPolicies) GetType() MeshLoadBalancingStrategyItemSpecType {
	if h == nil {
		return MeshLoadBalancingStrategyItemSpecType("")
	}
	return h.Type
}

type ActiveRequestBiasType string

const (
	ActiveRequestBiasTypeInteger ActiveRequestBiasType = "integer"
	ActiveRequestBiasTypeStr     ActiveRequestBiasType = "str"
)

// ActiveRequestBias refers to dynamic weights applied when hosts have varying load
// balancing weights. A higher value here aggressively reduces the weight of endpoints
// that are currently handling active requests. In essence, the higher the ActiveRequestBias
// value, the more forcefully it reduces the load balancing weight of endpoints that are
// actively serving requests.
type ActiveRequestBias struct {
	Integer *int64  `queryParam:"inline,name=activeRequestBias"`
	Str     *string `queryParam:"inline,name=activeRequestBias"`

	Type ActiveRequestBiasType
}

func CreateActiveRequestBiasInteger(integer int64) ActiveRequestBias {
	typ := ActiveRequestBiasTypeInteger

	return ActiveRequestBias{
		Integer: &integer,
		Type:    typ,
	}
}

func CreateActiveRequestBiasStr(str string) ActiveRequestBias {
	typ := ActiveRequestBiasTypeStr

	return ActiveRequestBias{
		Str:  &str,
		Type: typ,
	}
}

func (u *ActiveRequestBias) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var integer int64 = int64(0)
	if err := utils.UnmarshalJSON(data, &integer, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  ActiveRequestBiasTypeInteger,
			Value: &integer,
		})
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  ActiveRequestBiasTypeStr,
			Value: &str,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for ActiveRequestBias", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestCandidate(candidates)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for ActiveRequestBias", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(ActiveRequestBiasType)
	switch best.Type {
	case ActiveRequestBiasTypeInteger:
		u.Integer = best.Value.(*int64)
		return nil
	case ActiveRequestBiasTypeStr:
		u.Str = best.Value.(*string)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ActiveRequestBias", string(data))
}

func (u ActiveRequestBias) MarshalJSON() ([]byte, error) {
	if u.Integer != nil {
		return utils.MarshalJSON(u.Integer, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	return nil, errors.New("could not marshal union type ActiveRequestBias: all fields are null")
}

// LeastRequest selects N random available hosts as specified in 'choiceCount' (2 by default)
// and picks the host which has the fewest active requests
type LeastRequest struct {
	// ActiveRequestBias refers to dynamic weights applied when hosts have varying load
	// balancing weights. A higher value here aggressively reduces the weight of endpoints
	// that are currently handling active requests. In essence, the higher the ActiveRequestBias
	// value, the more forcefully it reduces the load balancing weight of endpoints that are
	// actively serving requests.
	ActiveRequestBias *ActiveRequestBias `json:"activeRequestBias,omitempty"`
	// ChoiceCount is the number of random healthy hosts from which the host with
	// the fewest active requests will be chosen. Defaults to 2 so that Envoy performs
	// two-choice selection if the field is not set.
	ChoiceCount *int `json:"choiceCount,omitempty"`
}

func (l *LeastRequest) GetActiveRequestBias() *ActiveRequestBias {
	if l == nil {
		return nil
	}
	return l.ActiveRequestBias
}

func (l *LeastRequest) GetChoiceCount() *int {
	if l == nil {
		return nil
	}
	return l.ChoiceCount
}

type MeshLoadBalancingStrategyItemConnection struct {
	// Hash on source IP address.
	SourceIP *bool `json:"sourceIP,omitempty"`
}

func (m *MeshLoadBalancingStrategyItemConnection) GetSourceIP() *bool {
	if m == nil {
		return nil
	}
	return m.SourceIP
}

type MeshLoadBalancingStrategyItemCookie struct {
	// The name of the cookie that will be used to obtain the hash key.
	Name string `json:"name"`
	// The name of the path for the cookie.
	Path *string `json:"path,omitempty"`
	// If specified, a cookie with the TTL will be generated if the cookie is not present.
	TTL *string `json:"ttl,omitempty"`
}

func (m *MeshLoadBalancingStrategyItemCookie) GetName() string {
	if m == nil {
		return ""
	}
	return m.Name
}

func (m *MeshLoadBalancingStrategyItemCookie) GetPath() *string {
	if m == nil {
		return nil
	}
	return m.Path
}

func (m *MeshLoadBalancingStrategyItemCookie) GetTTL() *string {
	if m == nil {
		return nil
	}
	return m.TTL
}

type MeshLoadBalancingStrategyItemFilterState struct {
	// The name of the Object in the per-request filterState, which is
	// an Envoy::Hashable object. If there is no data associated with the key,
	// or the stored object is not Envoy::Hashable, no hash will be produced.
	Key string `json:"key"`
}

func (m *MeshLoadBalancingStrategyItemFilterState) GetKey() string {
	if m == nil {
		return ""
	}
	return m.Key
}

type MeshLoadBalancingStrategyItemSpecToHeader struct {
	// The name of the request header that will be used to obtain the hash key.
	Name string `json:"name"`
}

func (m *MeshLoadBalancingStrategyItemSpecToHeader) GetName() string {
	if m == nil {
		return ""
	}
	return m.Name
}

type MeshLoadBalancingStrategyItemQueryParameter struct {
	// The name of the URL query parameter that will be used to obtain the hash key.
	// If the parameter is not present, no hash will be produced. Query parameter names
	// are case-sensitive.
	Name string `json:"name"`
}

func (m *MeshLoadBalancingStrategyItemQueryParameter) GetName() string {
	if m == nil {
		return ""
	}
	return m.Name
}

type MeshLoadBalancingStrategyItemSpecToDefaultLoadBalancerType string

const (
	MeshLoadBalancingStrategyItemSpecToDefaultLoadBalancerTypeHeader         MeshLoadBalancingStrategyItemSpecToDefaultLoadBalancerType = "Header"
	MeshLoadBalancingStrategyItemSpecToDefaultLoadBalancerTypeCookie         MeshLoadBalancingStrategyItemSpecToDefaultLoadBalancerType = "Cookie"
	MeshLoadBalancingStrategyItemSpecToDefaultLoadBalancerTypeConnection     MeshLoadBalancingStrategyItemSpecToDefaultLoadBalancerType = "Connection"
	MeshLoadBalancingStrategyItemSpecToDefaultLoadBalancerTypeSourceIP       MeshLoadBalancingStrategyItemSpecToDefaultLoadBalancerType = "SourceIP"
	MeshLoadBalancingStrategyItemSpecToDefaultLoadBalancerTypeQueryParameter MeshLoadBalancingStrategyItemSpecToDefaultLoadBalancerType = "QueryParameter"
	MeshLoadBalancingStrategyItemSpecToDefaultLoadBalancerTypeFilterState    MeshLoadBalancingStrategyItemSpecToDefaultLoadBalancerType = "FilterState"
)

func (e MeshLoadBalancingStrategyItemSpecToDefaultLoadBalancerType) ToPointer() *MeshLoadBalancingStrategyItemSpecToDefaultLoadBalancerType {
	return &e
}
func (e *MeshLoadBalancingStrategyItemSpecToDefaultLoadBalancerType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Header":
		fallthrough
	case "Cookie":
		fallthrough
	case "Connection":
		fallthrough
	case "SourceIP":
		fallthrough
	case "QueryParameter":
		fallthrough
	case "FilterState":
		*e = MeshLoadBalancingStrategyItemSpecToDefaultLoadBalancerType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshLoadBalancingStrategyItemSpecToDefaultLoadBalancerType: %v", v)
	}
}

type MeshLoadBalancingStrategyItemHashPolicies struct {
	Connection     *MeshLoadBalancingStrategyItemConnection     `json:"connection,omitempty"`
	Cookie         *MeshLoadBalancingStrategyItemCookie         `json:"cookie,omitempty"`
	FilterState    *MeshLoadBalancingStrategyItemFilterState    `json:"filterState,omitempty"`
	Header         *MeshLoadBalancingStrategyItemSpecToHeader   `json:"header,omitempty"`
	QueryParameter *MeshLoadBalancingStrategyItemQueryParameter `json:"queryParameter,omitempty"`
	// Terminal is a flag that short-circuits the hash computing. This field provides
	// a ‘fallback’ style of configuration: “if a terminal policy doesn’t work, fallback
	// to rest of the policy list”, it saves time when the terminal policy works.
	// If true, and there is already a hash computed, ignore rest of the list of hash polices.
	Terminal *bool                                                      `json:"terminal,omitempty"`
	Type     MeshLoadBalancingStrategyItemSpecToDefaultLoadBalancerType `json:"type"`
}

func (m *MeshLoadBalancingStrategyItemHashPolicies) GetConnection() *MeshLoadBalancingStrategyItemConnection {
	if m == nil {
		return nil
	}
	return m.Connection
}

func (m *MeshLoadBalancingStrategyItemHashPolicies) GetCookie() *MeshLoadBalancingStrategyItemCookie {
	if m == nil {
		return nil
	}
	return m.Cookie
}

func (m *MeshLoadBalancingStrategyItemHashPolicies) GetFilterState() *MeshLoadBalancingStrategyItemFilterState {
	if m == nil {
		return nil
	}
	return m.FilterState
}

func (m *MeshLoadBalancingStrategyItemHashPolicies) GetHeader() *MeshLoadBalancingStrategyItemSpecToHeader {
	if m == nil {
		return nil
	}
	return m.Header
}

func (m *MeshLoadBalancingStrategyItemHashPolicies) GetQueryParameter() *MeshLoadBalancingStrategyItemQueryParameter {
	if m == nil {
		return nil
	}
	return m.QueryParameter
}

func (m *MeshLoadBalancingStrategyItemHashPolicies) GetTerminal() *bool {
	if m == nil {
		return nil
	}
	return m.Terminal
}

func (m *MeshLoadBalancingStrategyItemHashPolicies) GetType() MeshLoadBalancingStrategyItemSpecToDefaultLoadBalancerType {
	if m == nil {
		return MeshLoadBalancingStrategyItemSpecToDefaultLoadBalancerType("")
	}
	return m.Type
}

// Maglev implements consistent hashing to upstream hosts. Maglev can be used as
// a drop in replacement for the ring hash load balancer any place in which
// consistent hashing is desired.
type Maglev struct {
	// HashPolicies specify a list of request/connection properties that are used to calculate a hash.
	// These hash policies are executed in the specified order. If a hash policy has the “terminal” attribute
	// set to true, and there is already a hash generated, the hash is returned immediately,
	// ignoring the rest of the hash policy list.
	HashPolicies []MeshLoadBalancingStrategyItemHashPolicies `json:"hashPolicies,omitempty"`
	// The table size for Maglev hashing. Maglev aims for “minimal disruption”
	// rather than an absolute guarantee. Minimal disruption means that when
	// the set of upstream hosts change, a connection will likely be sent
	// to the same upstream as it was before. Increasing the table size reduces
	// the amount of disruption. The table size must be prime number limited to 5000011.
	// If it is not specified, the default is 65537.
	TableSize *int `json:"tableSize,omitempty"`
}

func (m *Maglev) GetHashPolicies() []MeshLoadBalancingStrategyItemHashPolicies {
	if m == nil {
		return nil
	}
	return m.HashPolicies
}

func (m *Maglev) GetTableSize() *int {
	if m == nil {
		return nil
	}
	return m.TableSize
}

// MeshLoadBalancingStrategyItemRandom - Random selects a random available host. The random load balancer generally
// performs better than round-robin if no health checking policy is configured.
// Random selection avoids bias towards the host in the set that comes after a failed host.
type MeshLoadBalancingStrategyItemRandom struct {
}

// HashFunction is a function used to hash hosts onto the ketama ring.
// The value defaults to XX_HASH. Available values – XX_HASH, MURMUR_HASH_2.
type HashFunction string

const (
	HashFunctionXxHash      HashFunction = "XXHash"
	HashFunctionMurmurHash2 HashFunction = "MurmurHash2"
)

func (e HashFunction) ToPointer() *HashFunction {
	return &e
}
func (e *HashFunction) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "XXHash":
		fallthrough
	case "MurmurHash2":
		*e = HashFunction(v)
		return nil
	default:
		return fmt.Errorf("invalid value for HashFunction: %v", v)
	}
}

type MeshLoadBalancingStrategyItemSpecConnection struct {
	// Hash on source IP address.
	SourceIP *bool `json:"sourceIP,omitempty"`
}

func (m *MeshLoadBalancingStrategyItemSpecConnection) GetSourceIP() *bool {
	if m == nil {
		return nil
	}
	return m.SourceIP
}

type MeshLoadBalancingStrategyItemSpecCookie struct {
	// The name of the cookie that will be used to obtain the hash key.
	Name string `json:"name"`
	// The name of the path for the cookie.
	Path *string `json:"path,omitempty"`
	// If specified, a cookie with the TTL will be generated if the cookie is not present.
	TTL *string `json:"ttl,omitempty"`
}

func (m *MeshLoadBalancingStrategyItemSpecCookie) GetName() string {
	if m == nil {
		return ""
	}
	return m.Name
}

func (m *MeshLoadBalancingStrategyItemSpecCookie) GetPath() *string {
	if m == nil {
		return nil
	}
	return m.Path
}

func (m *MeshLoadBalancingStrategyItemSpecCookie) GetTTL() *string {
	if m == nil {
		return nil
	}
	return m.TTL
}

type MeshLoadBalancingStrategyItemSpecFilterState struct {
	// The name of the Object in the per-request filterState, which is
	// an Envoy::Hashable object. If there is no data associated with the key,
	// or the stored object is not Envoy::Hashable, no hash will be produced.
	Key string `json:"key"`
}

func (m *MeshLoadBalancingStrategyItemSpecFilterState) GetKey() string {
	if m == nil {
		return ""
	}
	return m.Key
}

type MeshLoadBalancingStrategyItemSpecHeader struct {
	// The name of the request header that will be used to obtain the hash key.
	Name string `json:"name"`
}

func (m *MeshLoadBalancingStrategyItemSpecHeader) GetName() string {
	if m == nil {
		return ""
	}
	return m.Name
}

type MeshLoadBalancingStrategyItemSpecQueryParameter struct {
	// The name of the URL query parameter that will be used to obtain the hash key.
	// If the parameter is not present, no hash will be produced. Query parameter names
	// are case-sensitive.
	Name string `json:"name"`
}

func (m *MeshLoadBalancingStrategyItemSpecQueryParameter) GetName() string {
	if m == nil {
		return ""
	}
	return m.Name
}

type MeshLoadBalancingStrategyItemSpecToDefaultType string

const (
	MeshLoadBalancingStrategyItemSpecToDefaultTypeHeader         MeshLoadBalancingStrategyItemSpecToDefaultType = "Header"
	MeshLoadBalancingStrategyItemSpecToDefaultTypeCookie         MeshLoadBalancingStrategyItemSpecToDefaultType = "Cookie"
	MeshLoadBalancingStrategyItemSpecToDefaultTypeConnection     MeshLoadBalancingStrategyItemSpecToDefaultType = "Connection"
	MeshLoadBalancingStrategyItemSpecToDefaultTypeSourceIP       MeshLoadBalancingStrategyItemSpecToDefaultType = "SourceIP"
	MeshLoadBalancingStrategyItemSpecToDefaultTypeQueryParameter MeshLoadBalancingStrategyItemSpecToDefaultType = "QueryParameter"
	MeshLoadBalancingStrategyItemSpecToDefaultTypeFilterState    MeshLoadBalancingStrategyItemSpecToDefaultType = "FilterState"
)

func (e MeshLoadBalancingStrategyItemSpecToDefaultType) ToPointer() *MeshLoadBalancingStrategyItemSpecToDefaultType {
	return &e
}
func (e *MeshLoadBalancingStrategyItemSpecToDefaultType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Header":
		fallthrough
	case "Cookie":
		fallthrough
	case "Connection":
		fallthrough
	case "SourceIP":
		fallthrough
	case "QueryParameter":
		fallthrough
	case "FilterState":
		*e = MeshLoadBalancingStrategyItemSpecToDefaultType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshLoadBalancingStrategyItemSpecToDefaultType: %v", v)
	}
}

type MeshLoadBalancingStrategyItemSpecHashPolicies struct {
	Connection     *MeshLoadBalancingStrategyItemSpecConnection     `json:"connection,omitempty"`
	Cookie         *MeshLoadBalancingStrategyItemSpecCookie         `json:"cookie,omitempty"`
	FilterState    *MeshLoadBalancingStrategyItemSpecFilterState    `json:"filterState,omitempty"`
	Header         *MeshLoadBalancingStrategyItemSpecHeader         `json:"header,omitempty"`
	QueryParameter *MeshLoadBalancingStrategyItemSpecQueryParameter `json:"queryParameter,omitempty"`
	// Terminal is a flag that short-circuits the hash computing. This field provides
	// a ‘fallback’ style of configuration: “if a terminal policy doesn’t work, fallback
	// to rest of the policy list”, it saves time when the terminal policy works.
	// If true, and there is already a hash computed, ignore rest of the list of hash polices.
	Terminal *bool                                          `json:"terminal,omitempty"`
	Type     MeshLoadBalancingStrategyItemSpecToDefaultType `json:"type"`
}

func (m *MeshLoadBalancingStrategyItemSpecHashPolicies) GetConnection() *MeshLoadBalancingStrategyItemSpecConnection {
	if m == nil {
		return nil
	}
	return m.Connection
}

func (m *MeshLoadBalancingStrategyItemSpecHashPolicies) GetCookie() *MeshLoadBalancingStrategyItemSpecCookie {
	if m == nil {
		return nil
	}
	return m.Cookie
}

func (m *MeshLoadBalancingStrategyItemSpecHashPolicies) GetFilterState() *MeshLoadBalancingStrategyItemSpecFilterState {
	if m == nil {
		return nil
	}
	return m.FilterState
}

func (m *MeshLoadBalancingStrategyItemSpecHashPolicies) GetHeader() *MeshLoadBalancingStrategyItemSpecHeader {
	if m == nil {
		return nil
	}
	return m.Header
}

func (m *MeshLoadBalancingStrategyItemSpecHashPolicies) GetQueryParameter() *MeshLoadBalancingStrategyItemSpecQueryParameter {
	if m == nil {
		return nil
	}
	return m.QueryParameter
}

func (m *MeshLoadBalancingStrategyItemSpecHashPolicies) GetTerminal() *bool {
	if m == nil {
		return nil
	}
	return m.Terminal
}

func (m *MeshLoadBalancingStrategyItemSpecHashPolicies) GetType() MeshLoadBalancingStrategyItemSpecToDefaultType {
	if m == nil {
		return MeshLoadBalancingStrategyItemSpecToDefaultType("")
	}
	return m.Type
}

// RingHash  implements consistent hashing to upstream hosts. Each host is mapped
// onto a circle (the “ring”) by hashing its address; each request is then routed
// to a host by hashing some property of the request, and finding the nearest
// corresponding host clockwise around the ring.
type RingHash struct {
	// HashFunction is a function used to hash hosts onto the ketama ring.
	// The value defaults to XX_HASH. Available values – XX_HASH, MURMUR_HASH_2.
	HashFunction *HashFunction `json:"hashFunction,omitempty"`
	// HashPolicies specify a list of request/connection properties that are used to calculate a hash.
	// These hash policies are executed in the specified order. If a hash policy has the “terminal” attribute
	// set to true, and there is already a hash generated, the hash is returned immediately,
	// ignoring the rest of the hash policy list.
	HashPolicies []MeshLoadBalancingStrategyItemSpecHashPolicies `json:"hashPolicies,omitempty"`
	// Maximum hash ring size. Defaults to 8M entries, and limited to 8M entries,
	// but can be lowered to further constrain resource use.
	MaxRingSize *int `json:"maxRingSize,omitempty"`
	// Minimum hash ring size. The larger the ring is (that is,
	// the more hashes there are for each provided host) the better the request distribution
	// will reflect the desired weights. Defaults to 1024 entries, and limited to 8M entries.
	MinRingSize *int `json:"minRingSize,omitempty"`
}

func (r *RingHash) GetHashFunction() *HashFunction {
	if r == nil {
		return nil
	}
	return r.HashFunction
}

func (r *RingHash) GetHashPolicies() []MeshLoadBalancingStrategyItemSpecHashPolicies {
	if r == nil {
		return nil
	}
	return r.HashPolicies
}

func (r *RingHash) GetMaxRingSize() *int {
	if r == nil {
		return nil
	}
	return r.MaxRingSize
}

func (r *RingHash) GetMinRingSize() *int {
	if r == nil {
		return nil
	}
	return r.MinRingSize
}

// RoundRobin is a load balancing algorithm that distributes requests
// across available upstream hosts in round-robin order.
type RoundRobin struct {
}

type MeshLoadBalancingStrategyItemSpecToType string

const (
	MeshLoadBalancingStrategyItemSpecToTypeRoundRobin   MeshLoadBalancingStrategyItemSpecToType = "RoundRobin"
	MeshLoadBalancingStrategyItemSpecToTypeLeastRequest MeshLoadBalancingStrategyItemSpecToType = "LeastRequest"
	MeshLoadBalancingStrategyItemSpecToTypeRingHash     MeshLoadBalancingStrategyItemSpecToType = "RingHash"
	MeshLoadBalancingStrategyItemSpecToTypeRandom       MeshLoadBalancingStrategyItemSpecToType = "Random"
	MeshLoadBalancingStrategyItemSpecToTypeMaglev       MeshLoadBalancingStrategyItemSpecToType = "Maglev"
)

func (e MeshLoadBalancingStrategyItemSpecToType) ToPointer() *MeshLoadBalancingStrategyItemSpecToType {
	return &e
}
func (e *MeshLoadBalancingStrategyItemSpecToType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "RoundRobin":
		fallthrough
	case "LeastRequest":
		fallthrough
	case "RingHash":
		fallthrough
	case "Random":
		fallthrough
	case "Maglev":
		*e = MeshLoadBalancingStrategyItemSpecToType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshLoadBalancingStrategyItemSpecToType: %v", v)
	}
}

// LoadBalancer allows to specify load balancing algorithm.
type LoadBalancer struct {
	// LeastRequest selects N random available hosts as specified in 'choiceCount' (2 by default)
	// and picks the host which has the fewest active requests
	LeastRequest *LeastRequest `json:"leastRequest,omitempty"`
	// Maglev implements consistent hashing to upstream hosts. Maglev can be used as
	// a drop in replacement for the ring hash load balancer any place in which
	// consistent hashing is desired.
	Maglev *Maglev `json:"maglev,omitempty"`
	// Random selects a random available host. The random load balancer generally
	// performs better than round-robin if no health checking policy is configured.
	// Random selection avoids bias towards the host in the set that comes after a failed host.
	Random *MeshLoadBalancingStrategyItemRandom `json:"random,omitempty"`
	// RingHash  implements consistent hashing to upstream hosts. Each host is mapped
	// onto a circle (the “ring”) by hashing its address; each request is then routed
	// to a host by hashing some property of the request, and finding the nearest
	// corresponding host clockwise around the ring.
	RingHash *RingHash `json:"ringHash,omitempty"`
	// RoundRobin is a load balancing algorithm that distributes requests
	// across available upstream hosts in round-robin order.
	RoundRobin *RoundRobin                             `json:"roundRobin,omitempty"`
	Type       MeshLoadBalancingStrategyItemSpecToType `json:"type"`
}

func (l *LoadBalancer) GetLeastRequest() *LeastRequest {
	if l == nil {
		return nil
	}
	return l.LeastRequest
}

func (l *LoadBalancer) GetMaglev() *Maglev {
	if l == nil {
		return nil
	}
	return l.Maglev
}

func (l *LoadBalancer) GetRandom() *MeshLoadBalancingStrategyItemRandom {
	if l == nil {
		return nil
	}
	return l.Random
}

func (l *LoadBalancer) GetRingHash() *RingHash {
	if l == nil {
		return nil
	}
	return l.RingHash
}

func (l *LoadBalancer) GetRoundRobin() *RoundRobin {
	if l == nil {
		return nil
	}
	return l.RoundRobin
}

func (l *LoadBalancer) GetType() MeshLoadBalancingStrategyItemSpecToType {
	if l == nil {
		return MeshLoadBalancingStrategyItemSpecToType("")
	}
	return l.Type
}

// MeshLoadBalancingStrategyItemFrom - From defines the list of zones to which the rule applies
type MeshLoadBalancingStrategyItemFrom struct {
	Zones []string `json:"zones"`
}

func (m *MeshLoadBalancingStrategyItemFrom) GetZones() []string {
	if m == nil {
		return []string{}
	}
	return m.Zones
}

// MeshLoadBalancingStrategyItemSpecToDefaultLocalityAwarenessType - Type defines how target zones will be picked from available zones
type MeshLoadBalancingStrategyItemSpecToDefaultLocalityAwarenessType string

const (
	MeshLoadBalancingStrategyItemSpecToDefaultLocalityAwarenessTypeNone      MeshLoadBalancingStrategyItemSpecToDefaultLocalityAwarenessType = "None"
	MeshLoadBalancingStrategyItemSpecToDefaultLocalityAwarenessTypeOnly      MeshLoadBalancingStrategyItemSpecToDefaultLocalityAwarenessType = "Only"
	MeshLoadBalancingStrategyItemSpecToDefaultLocalityAwarenessTypeAny       MeshLoadBalancingStrategyItemSpecToDefaultLocalityAwarenessType = "Any"
	MeshLoadBalancingStrategyItemSpecToDefaultLocalityAwarenessTypeAnyExcept MeshLoadBalancingStrategyItemSpecToDefaultLocalityAwarenessType = "AnyExcept"
)

func (e MeshLoadBalancingStrategyItemSpecToDefaultLocalityAwarenessType) ToPointer() *MeshLoadBalancingStrategyItemSpecToDefaultLocalityAwarenessType {
	return &e
}
func (e *MeshLoadBalancingStrategyItemSpecToDefaultLocalityAwarenessType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "None":
		fallthrough
	case "Only":
		fallthrough
	case "Any":
		fallthrough
	case "AnyExcept":
		*e = MeshLoadBalancingStrategyItemSpecToDefaultLocalityAwarenessType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshLoadBalancingStrategyItemSpecToDefaultLocalityAwarenessType: %v", v)
	}
}

// MeshLoadBalancingStrategyItemSpecTo - To defines to which zones the traffic should be load balanced
type MeshLoadBalancingStrategyItemSpecTo struct {
	// Type defines how target zones will be picked from available zones
	Type  MeshLoadBalancingStrategyItemSpecToDefaultLocalityAwarenessType `json:"type"`
	Zones []string                                                        `json:"zones,omitempty"`
}

func (m *MeshLoadBalancingStrategyItemSpecTo) GetType() MeshLoadBalancingStrategyItemSpecToDefaultLocalityAwarenessType {
	if m == nil {
		return MeshLoadBalancingStrategyItemSpecToDefaultLocalityAwarenessType("")
	}
	return m.Type
}

func (m *MeshLoadBalancingStrategyItemSpecTo) GetZones() []string {
	if m == nil {
		return nil
	}
	return m.Zones
}

type Failover struct {
	// From defines the list of zones to which the rule applies
	From *MeshLoadBalancingStrategyItemFrom `json:"from,omitempty"`
	// To defines to which zones the traffic should be load balanced
	To MeshLoadBalancingStrategyItemSpecTo `json:"to"`
}

func (f *Failover) GetFrom() *MeshLoadBalancingStrategyItemFrom {
	if f == nil {
		return nil
	}
	return f.From
}

func (f *Failover) GetTo() MeshLoadBalancingStrategyItemSpecTo {
	if f == nil {
		return MeshLoadBalancingStrategyItemSpecTo{}
	}
	return f.To
}

type MeshLoadBalancingStrategyItemPercentageType string

const (
	MeshLoadBalancingStrategyItemPercentageTypeInteger MeshLoadBalancingStrategyItemPercentageType = "integer"
	MeshLoadBalancingStrategyItemPercentageTypeStr     MeshLoadBalancingStrategyItemPercentageType = "str"
)

type MeshLoadBalancingStrategyItemPercentage struct {
	Integer *int64  `queryParam:"inline,name=percentage"`
	Str     *string `queryParam:"inline,name=percentage"`

	Type MeshLoadBalancingStrategyItemPercentageType
}

func CreateMeshLoadBalancingStrategyItemPercentageInteger(integer int64) MeshLoadBalancingStrategyItemPercentage {
	typ := MeshLoadBalancingStrategyItemPercentageTypeInteger

	return MeshLoadBalancingStrategyItemPercentage{
		Integer: &integer,
		Type:    typ,
	}
}

func CreateMeshLoadBalancingStrategyItemPercentageStr(str string) MeshLoadBalancingStrategyItemPercentage {
	typ := MeshLoadBalancingStrategyItemPercentageTypeStr

	return MeshLoadBalancingStrategyItemPercentage{
		Str:  &str,
		Type: typ,
	}
}

func (u *MeshLoadBalancingStrategyItemPercentage) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var integer int64 = int64(0)
	if err := utils.UnmarshalJSON(data, &integer, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  MeshLoadBalancingStrategyItemPercentageTypeInteger,
			Value: &integer,
		})
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  MeshLoadBalancingStrategyItemPercentageTypeStr,
			Value: &str,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for MeshLoadBalancingStrategyItemPercentage", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestCandidate(candidates)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for MeshLoadBalancingStrategyItemPercentage", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(MeshLoadBalancingStrategyItemPercentageType)
	switch best.Type {
	case MeshLoadBalancingStrategyItemPercentageTypeInteger:
		u.Integer = best.Value.(*int64)
		return nil
	case MeshLoadBalancingStrategyItemPercentageTypeStr:
		u.Str = best.Value.(*string)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for MeshLoadBalancingStrategyItemPercentage", string(data))
}

func (u MeshLoadBalancingStrategyItemPercentage) MarshalJSON() ([]byte, error) {
	if u.Integer != nil {
		return utils.MarshalJSON(u.Integer, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	return nil, errors.New("could not marshal union type MeshLoadBalancingStrategyItemPercentage: all fields are null")
}

// FailoverThreshold defines the percentage of live destination dataplane proxies below which load balancing to the
// next priority starts.
// Example: If you configure failoverThreshold to 70, and you have deployed 10 destination dataplane proxies.
// Load balancing to next priority will start when number of live destination dataplane proxies drops below 7.
// Default 50
type FailoverThreshold struct {
	Percentage MeshLoadBalancingStrategyItemPercentage `json:"percentage"`
}

func (f *FailoverThreshold) GetPercentage() MeshLoadBalancingStrategyItemPercentage {
	if f == nil {
		return MeshLoadBalancingStrategyItemPercentage{}
	}
	return f.Percentage
}

// CrossZone defines locality aware load balancing priorities when dataplane proxies inside local zone
// are unavailable
type CrossZone struct {
	// Failover defines list of load balancing rules in order of priority
	Failover []Failover `json:"failover,omitempty"`
	// FailoverThreshold defines the percentage of live destination dataplane proxies below which load balancing to the
	// next priority starts.
	// Example: If you configure failoverThreshold to 70, and you have deployed 10 destination dataplane proxies.
	// Load balancing to next priority will start when number of live destination dataplane proxies drops below 7.
	// Default 50
	FailoverThreshold *FailoverThreshold `json:"failoverThreshold,omitempty"`
}

func (c *CrossZone) GetFailover() []Failover {
	if c == nil {
		return nil
	}
	return c.Failover
}

func (c *CrossZone) GetFailoverThreshold() *FailoverThreshold {
	if c == nil {
		return nil
	}
	return c.FailoverThreshold
}

type AffinityTags struct {
	// Key defines tag for which affinity is configured
	Key string `json:"key"`
	// Weight of the tag used for load balancing. The bigger the weight the bigger the priority.
	// Percentage of local traffic load balanced to tag is computed by dividing weight by sum of weights from all tags.
	// For example with two affinity tags first with weight 80 and second with weight 20,
	// then 80% of traffic will be redirected to the first tag, and 20% of traffic will be redirected to second one.
	// Setting weights is not mandatory. When weights are not set control plane will compute default weight based on list order.
	// Default: If you do not specify weight we will adjust them so that 90% traffic goes to first tag, 9% to next, and 1% to third and so on.
	Weight *int `json:"weight,omitempty"`
}

func (a *AffinityTags) GetKey() string {
	if a == nil {
		return ""
	}
	return a.Key
}

func (a *AffinityTags) GetWeight() *int {
	if a == nil {
		return nil
	}
	return a.Weight
}

// LocalZone defines locality aware load balancing priorities between dataplane proxies inside a zone
type LocalZone struct {
	// AffinityTags list of tags for local zone load balancing.
	AffinityTags []AffinityTags `json:"affinityTags,omitempty"`
}

func (l *LocalZone) GetAffinityTags() []AffinityTags {
	if l == nil {
		return nil
	}
	return l.AffinityTags
}

// LocalityAwareness contains configuration for locality aware load balancing.
type LocalityAwareness struct {
	// CrossZone defines locality aware load balancing priorities when dataplane proxies inside local zone
	// are unavailable
	CrossZone *CrossZone `json:"crossZone,omitempty"`
	// Disabled allows to disable locality-aware load balancing.
	// When disabled requests are distributed across all endpoints regardless of locality.
	Disabled *bool `json:"disabled,omitempty"`
	// LocalZone defines locality aware load balancing priorities between dataplane proxies inside a zone
	LocalZone *LocalZone `json:"localZone,omitempty"`
}

func (l *LocalityAwareness) GetCrossZone() *CrossZone {
	if l == nil {
		return nil
	}
	return l.CrossZone
}

func (l *LocalityAwareness) GetDisabled() *bool {
	if l == nil {
		return nil
	}
	return l.Disabled
}

func (l *LocalityAwareness) GetLocalZone() *LocalZone {
	if l == nil {
		return nil
	}
	return l.LocalZone
}

// MeshLoadBalancingStrategyItemDefault - Default is a configuration specific to the group of destinations referenced in
// 'targetRef'
type MeshLoadBalancingStrategyItemDefault struct {
	// HashPolicies specify a list of request/connection properties that are used to calculate a hash.
	// These hash policies are executed in the specified order. If a hash policy has the “terminal” attribute
	// set to true, and there is already a hash generated, the hash is returned immediately,
	// ignoring the rest of the hash policy list.
	HashPolicies []HashPolicies `json:"hashPolicies,omitempty"`
	// LoadBalancer allows to specify load balancing algorithm.
	LoadBalancer *LoadBalancer `json:"loadBalancer,omitempty"`
	// LocalityAwareness contains configuration for locality aware load balancing.
	LocalityAwareness *LocalityAwareness `json:"localityAwareness,omitempty"`
}

func (m *MeshLoadBalancingStrategyItemDefault) GetHashPolicies() []HashPolicies {
	if m == nil {
		return nil
	}
	return m.HashPolicies
}

func (m *MeshLoadBalancingStrategyItemDefault) GetLoadBalancer() *LoadBalancer {
	if m == nil {
		return nil
	}
	return m.LoadBalancer
}

func (m *MeshLoadBalancingStrategyItemDefault) GetLocalityAwareness() *LocalityAwareness {
	if m == nil {
		return nil
	}
	return m.LocalityAwareness
}

// MeshLoadBalancingStrategyItemSpecKind - Kind of the referenced resource
type MeshLoadBalancingStrategyItemSpecKind string

const (
	MeshLoadBalancingStrategyItemSpecKindMesh                 MeshLoadBalancingStrategyItemSpecKind = "Mesh"
	MeshLoadBalancingStrategyItemSpecKindMeshSubset           MeshLoadBalancingStrategyItemSpecKind = "MeshSubset"
	MeshLoadBalancingStrategyItemSpecKindMeshGateway          MeshLoadBalancingStrategyItemSpecKind = "MeshGateway"
	MeshLoadBalancingStrategyItemSpecKindMeshService          MeshLoadBalancingStrategyItemSpecKind = "MeshService"
	MeshLoadBalancingStrategyItemSpecKindMeshExternalService  MeshLoadBalancingStrategyItemSpecKind = "MeshExternalService"
	MeshLoadBalancingStrategyItemSpecKindMeshMultiZoneService MeshLoadBalancingStrategyItemSpecKind = "MeshMultiZoneService"
	MeshLoadBalancingStrategyItemSpecKindMeshServiceSubset    MeshLoadBalancingStrategyItemSpecKind = "MeshServiceSubset"
	MeshLoadBalancingStrategyItemSpecKindMeshHTTPRoute        MeshLoadBalancingStrategyItemSpecKind = "MeshHTTPRoute"
	MeshLoadBalancingStrategyItemSpecKindDataplane            MeshLoadBalancingStrategyItemSpecKind = "Dataplane"
)

func (e MeshLoadBalancingStrategyItemSpecKind) ToPointer() *MeshLoadBalancingStrategyItemSpecKind {
	return &e
}
func (e *MeshLoadBalancingStrategyItemSpecKind) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Mesh":
		fallthrough
	case "MeshSubset":
		fallthrough
	case "MeshGateway":
		fallthrough
	case "MeshService":
		fallthrough
	case "MeshExternalService":
		fallthrough
	case "MeshMultiZoneService":
		fallthrough
	case "MeshServiceSubset":
		fallthrough
	case "MeshHTTPRoute":
		fallthrough
	case "Dataplane":
		*e = MeshLoadBalancingStrategyItemSpecKind(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshLoadBalancingStrategyItemSpecKind: %v", v)
	}
}

type MeshLoadBalancingStrategyItemSpecProxyTypes string

const (
	MeshLoadBalancingStrategyItemSpecProxyTypesSidecar MeshLoadBalancingStrategyItemSpecProxyTypes = "Sidecar"
	MeshLoadBalancingStrategyItemSpecProxyTypesGateway MeshLoadBalancingStrategyItemSpecProxyTypes = "Gateway"
)

func (e MeshLoadBalancingStrategyItemSpecProxyTypes) ToPointer() *MeshLoadBalancingStrategyItemSpecProxyTypes {
	return &e
}
func (e *MeshLoadBalancingStrategyItemSpecProxyTypes) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Sidecar":
		fallthrough
	case "Gateway":
		*e = MeshLoadBalancingStrategyItemSpecProxyTypes(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MeshLoadBalancingStrategyItemSpecProxyTypes: %v", v)
	}
}

// MeshLoadBalancingStrategyItemSpecTargetRef - TargetRef is a reference to the resource that represents a group of
// destinations.
type MeshLoadBalancingStrategyItemSpecTargetRef struct {
	// Kind of the referenced resource
	Kind MeshLoadBalancingStrategyItemSpecKind `json:"kind"`
	// Labels are used to select group of MeshServices that match labels. Either Labels or
	// Name and Namespace can be used.
	Labels map[string]string `json:"labels,omitempty"`
	// Mesh is reserved for future use to identify cross mesh resources.
	Mesh *string `json:"mesh,omitempty"`
	// Name of the referenced resource. Can only be used with kinds: `MeshService`,
	// `MeshServiceSubset` and `MeshGatewayRoute`
	Name *string `json:"name,omitempty"`
	// Namespace specifies the namespace of target resource. If empty only resources in policy namespace
	// will be targeted.
	Namespace *string `json:"namespace,omitempty"`
	// ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
	// all data plane types are targeted by the policy.
	ProxyTypes []MeshLoadBalancingStrategyItemSpecProxyTypes `json:"proxyTypes,omitempty"`
	// SectionName is used to target specific section of resource.
	// For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected.
	SectionName *string `json:"sectionName,omitempty"`
	// Tags used to select a subset of proxies by tags. Can only be used with kinds
	// `MeshSubset` and `MeshServiceSubset`
	Tags map[string]string `json:"tags,omitempty"`
}

func (m *MeshLoadBalancingStrategyItemSpecTargetRef) GetKind() MeshLoadBalancingStrategyItemSpecKind {
	if m == nil {
		return MeshLoadBalancingStrategyItemSpecKind("")
	}
	return m.Kind
}

func (m *MeshLoadBalancingStrategyItemSpecTargetRef) GetLabels() map[string]string {
	if m == nil {
		return nil
	}
	return m.Labels
}

func (m *MeshLoadBalancingStrategyItemSpecTargetRef) GetMesh() *string {
	if m == nil {
		return nil
	}
	return m.Mesh
}

func (m *MeshLoadBalancingStrategyItemSpecTargetRef) GetName() *string {
	if m == nil {
		return nil
	}
	return m.Name
}

func (m *MeshLoadBalancingStrategyItemSpecTargetRef) GetNamespace() *string {
	if m == nil {
		return nil
	}
	return m.Namespace
}

func (m *MeshLoadBalancingStrategyItemSpecTargetRef) GetProxyTypes() []MeshLoadBalancingStrategyItemSpecProxyTypes {
	if m == nil {
		return nil
	}
	return m.ProxyTypes
}

func (m *MeshLoadBalancingStrategyItemSpecTargetRef) GetSectionName() *string {
	if m == nil {
		return nil
	}
	return m.SectionName
}

func (m *MeshLoadBalancingStrategyItemSpecTargetRef) GetTags() map[string]string {
	if m == nil {
		return nil
	}
	return m.Tags
}

type MeshLoadBalancingStrategyItemTo struct {
	// Default is a configuration specific to the group of destinations referenced in
	// 'targetRef'
	Default *MeshLoadBalancingStrategyItemDefault `json:"default,omitempty"`
	// TargetRef is a reference to the resource that represents a group of
	// destinations.
	TargetRef MeshLoadBalancingStrategyItemSpecTargetRef `json:"targetRef"`
}

func (m *MeshLoadBalancingStrategyItemTo) GetDefault() *MeshLoadBalancingStrategyItemDefault {
	if m == nil {
		return nil
	}
	return m.Default
}

func (m *MeshLoadBalancingStrategyItemTo) GetTargetRef() MeshLoadBalancingStrategyItemSpecTargetRef {
	if m == nil {
		return MeshLoadBalancingStrategyItemSpecTargetRef{}
	}
	return m.TargetRef
}

// MeshLoadBalancingStrategyItemSpec - Spec is the specification of the Kuma MeshLoadBalancingStrategy resource.
type MeshLoadBalancingStrategyItemSpec struct {
	// TargetRef is a reference to the resource the policy takes an effect on.
	// The resource could be either a real store object or virtual resource
	// defined inplace.
	TargetRef *MeshLoadBalancingStrategyItemTargetRef `json:"targetRef,omitempty"`
	// To list makes a match between the consumed services and corresponding configurations
	To []MeshLoadBalancingStrategyItemTo `json:"to,omitempty"`
}

func (m *MeshLoadBalancingStrategyItemSpec) GetTargetRef() *MeshLoadBalancingStrategyItemTargetRef {
	if m == nil {
		return nil
	}
	return m.TargetRef
}

func (m *MeshLoadBalancingStrategyItemSpec) GetTo() []MeshLoadBalancingStrategyItemTo {
	if m == nil {
		return nil
	}
	return m.To
}

// MeshLoadBalancingStrategyItem - Successful response
type MeshLoadBalancingStrategyItem struct {
	// the type of the resource
	Type MeshLoadBalancingStrategyItemType `json:"type"`
	// Mesh is the name of the Kuma mesh this resource belongs to. It may be omitted for cluster-scoped resources.
	Mesh *string `default:"default" json:"mesh"`
	// Name of the Kuma resource
	Name string `json:"name"`
	// The labels to help identity resources
	Labels map[string]string `json:"labels,omitempty"`
	// Spec is the specification of the Kuma MeshLoadBalancingStrategy resource.
	Spec MeshLoadBalancingStrategyItemSpec `json:"spec"`
	// Time at which the resource was created
	CreationTime *time.Time `json:"creationTime,omitempty"`
	// Time at which the resource was updated
	ModificationTime *time.Time `json:"modificationTime,omitempty"`
}

func (m MeshLoadBalancingStrategyItem) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(m, "", false)
}

func (m *MeshLoadBalancingStrategyItem) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &m, "", false, []string{"type", "name", "spec"}); err != nil {
		return err
	}
	return nil
}

func (m *MeshLoadBalancingStrategyItem) GetType() MeshLoadBalancingStrategyItemType {
	if m == nil {
		return MeshLoadBalancingStrategyItemType("")
	}
	return m.Type
}

func (m *MeshLoadBalancingStrategyItem) GetMesh() *string {
	if m == nil {
		return nil
	}
	return m.Mesh
}

func (m *MeshLoadBalancingStrategyItem) GetName() string {
	if m == nil {
		return ""
	}
	return m.Name
}

func (m *MeshLoadBalancingStrategyItem) GetLabels() map[string]string {
	if m == nil {
		return nil
	}
	return m.Labels
}

func (m *MeshLoadBalancingStrategyItem) GetSpec() MeshLoadBalancingStrategyItemSpec {
	if m == nil {
		return MeshLoadBalancingStrategyItemSpec{}
	}
	return m.Spec
}

func (m *MeshLoadBalancingStrategyItem) GetCreationTime() *time.Time {
	if m == nil {
		return nil
	}
	return m.CreationTime
}

func (m *MeshLoadBalancingStrategyItem) GetModificationTime() *time.Time {
	if m == nil {
		return nil
	}
	return m.ModificationTime
}

type MeshLoadBalancingStrategyItemInput struct {
	// the type of the resource
	Type MeshLoadBalancingStrategyItemType `json:"type"`
	// Mesh is the name of the Kuma mesh this resource belongs to. It may be omitted for cluster-scoped resources.
	Mesh *string `default:"default" json:"mesh"`
	// Name of the Kuma resource
	Name string `json:"name"`
	// The labels to help identity resources
	Labels map[string]string `json:"labels,omitempty"`
	// Spec is the specification of the Kuma MeshLoadBalancingStrategy resource.
	Spec MeshLoadBalancingStrategyItemSpec `json:"spec"`
}

func (m MeshLoadBalancingStrategyItemInput) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(m, "", false)
}

func (m *MeshLoadBalancingStrategyItemInput) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &m, "", false, []string{"type", "name", "spec"}); err != nil {
		return err
	}
	return nil
}

func (m *MeshLoadBalancingStrategyItemInput) GetType() MeshLoadBalancingStrategyItemType {
	if m == nil {
		return MeshLoadBalancingStrategyItemType("")
	}
	return m.Type
}

func (m *MeshLoadBalancingStrategyItemInput) GetMesh() *string {
	if m == nil {
		return nil
	}
	return m.Mesh
}

func (m *MeshLoadBalancingStrategyItemInput) GetName() string {
	if m == nil {
		return ""
	}
	return m.Name
}

func (m *MeshLoadBalancingStrategyItemInput) GetLabels() map[string]string {
	if m == nil {
		return nil
	}
	return m.Labels
}

func (m *MeshLoadBalancingStrategyItemInput) GetSpec() MeshLoadBalancingStrategyItemSpec {
	if m == nil {
		return MeshLoadBalancingStrategyItemSpec{}
	}
	return m.Spec
}
