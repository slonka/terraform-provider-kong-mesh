// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package provider

import (
	"context"
	"github.com/Kong/shared-speakeasy/customtypes/kumalabels"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/kong/terraform-provider-kong-mesh/internal/provider/typeconvert"
	tfTypes "github.com/kong/terraform-provider-kong-mesh/internal/provider/types"
	"github.com/kong/terraform-provider-kong-mesh/internal/sdk/models/operations"
	"github.com/kong/terraform-provider-kong-mesh/internal/sdk/models/shared"
)

func (r *MeshMetricResourceModel) RefreshFromSharedMeshMetricCreateOrUpdateSuccessResponse(ctx context.Context, resp *shared.MeshMetricCreateOrUpdateSuccessResponse) diag.Diagnostics {
	var diags diag.Diagnostics

	if resp != nil {
		r.Warnings = make([]types.String, 0, len(resp.Warnings))
		for _, v := range resp.Warnings {
			r.Warnings = append(r.Warnings, types.StringValue(v))
		}
	}

	return diags
}

func (r *MeshMetricResourceModel) RefreshFromSharedMeshMetricItem(ctx context.Context, resp *shared.MeshMetricItem) diag.Diagnostics {
	var diags diag.Diagnostics

	if resp != nil {
		r.CreationTime = types.StringPointerValue(typeconvert.TimePointerToStringPointer(resp.CreationTime))
		labelsValue, labelsDiags := types.MapValueFrom(ctx, types.StringType, resp.Labels)
		diags.Append(labelsDiags...)
		labelsValuable, labelsDiags := kumalabels.KumaLabelsMapType{MapType: types.MapType{ElemType: types.StringType}}.ValueFromMap(ctx, labelsValue)
		diags.Append(labelsDiags...)
		r.Labels, _ = labelsValuable.(kumalabels.KumaLabelsMapValue)
		r.Mesh = types.StringPointerValue(resp.Mesh)
		r.ModificationTime = types.StringPointerValue(typeconvert.TimePointerToStringPointer(resp.ModificationTime))
		r.Name = types.StringValue(resp.Name)
		if resp.Spec.Default == nil {
			r.Spec.Default = nil
		} else {
			r.Spec.Default = &tfTypes.Default{}
			r.Spec.Default.Applications = []tfTypes.Applications{}

			for _, applicationsItem := range resp.Spec.Default.Applications {
				var applications tfTypes.Applications

				applications.Address = types.StringPointerValue(applicationsItem.Address)
				applications.Name = types.StringPointerValue(applicationsItem.Name)
				applications.Path = types.StringPointerValue(applicationsItem.Path)
				applications.Port = types.Int32Value(int32(applicationsItem.Port))

				r.Spec.Default.Applications = append(r.Spec.Default.Applications, applications)
			}
			r.Spec.Default.Backends = []tfTypes.MeshMetricItemBackends{}

			for _, backendsItem := range resp.Spec.Default.Backends {
				var backends tfTypes.MeshMetricItemBackends

				if backendsItem.OpenTelemetry == nil {
					backends.OpenTelemetry = nil
				} else {
					backends.OpenTelemetry = &tfTypes.OpenTelemetry{}
					backends.OpenTelemetry.Endpoint = types.StringValue(backendsItem.OpenTelemetry.Endpoint)
					backends.OpenTelemetry.RefreshInterval = types.StringPointerValue(backendsItem.OpenTelemetry.RefreshInterval)
				}
				if backendsItem.Prometheus == nil {
					backends.Prometheus = nil
				} else {
					backends.Prometheus = &tfTypes.Prometheus{}
					backends.Prometheus.ClientID = types.StringPointerValue(backendsItem.Prometheus.ClientID)
					backends.Prometheus.Path = types.StringPointerValue(backendsItem.Prometheus.Path)
					backends.Prometheus.Port = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(backendsItem.Prometheus.Port))
					if backendsItem.Prometheus.TLS == nil {
						backends.Prometheus.TLS = nil
					} else {
						backends.Prometheus.TLS = &tfTypes.MeshMetricItemTLS{}
						if backendsItem.Prometheus.TLS.Mode != nil {
							backends.Prometheus.TLS.Mode = types.StringValue(string(*backendsItem.Prometheus.TLS.Mode))
						} else {
							backends.Prometheus.TLS.Mode = types.StringNull()
						}
					}
				}
				backends.Type = types.StringValue(string(backendsItem.Type))

				r.Spec.Default.Backends = append(r.Spec.Default.Backends, backends)
			}
			if resp.Spec.Default.Sidecar == nil {
				r.Spec.Default.Sidecar = nil
			} else {
				r.Spec.Default.Sidecar = &tfTypes.Sidecar{}
				r.Spec.Default.Sidecar.IncludeUnused = types.BoolPointerValue(resp.Spec.Default.Sidecar.IncludeUnused)
				if resp.Spec.Default.Sidecar.Profiles == nil {
					r.Spec.Default.Sidecar.Profiles = nil
				} else {
					r.Spec.Default.Sidecar.Profiles = &tfTypes.Profiles{}
					r.Spec.Default.Sidecar.Profiles.AppendProfiles = []tfTypes.EnvVar{}

					for _, appendProfilesItem := range resp.Spec.Default.Sidecar.Profiles.AppendProfiles {
						var appendProfiles tfTypes.EnvVar

						appendProfiles.Name = types.StringValue(string(appendProfilesItem.Name))

						r.Spec.Default.Sidecar.Profiles.AppendProfiles = append(r.Spec.Default.Sidecar.Profiles.AppendProfiles, appendProfiles)
					}
					r.Spec.Default.Sidecar.Profiles.Exclude = []tfTypes.Exclude{}

					for _, excludeItem := range resp.Spec.Default.Sidecar.Profiles.Exclude {
						var exclude tfTypes.Exclude

						exclude.Match = types.StringValue(excludeItem.Match)
						exclude.Type = types.StringValue(string(excludeItem.Type))

						r.Spec.Default.Sidecar.Profiles.Exclude = append(r.Spec.Default.Sidecar.Profiles.Exclude, exclude)
					}
					r.Spec.Default.Sidecar.Profiles.Include = []tfTypes.Exclude{}

					for _, includeItem := range resp.Spec.Default.Sidecar.Profiles.Include {
						var include tfTypes.Exclude

						include.Match = types.StringValue(includeItem.Match)
						include.Type = types.StringValue(string(includeItem.Type))

						r.Spec.Default.Sidecar.Profiles.Include = append(r.Spec.Default.Sidecar.Profiles.Include, include)
					}
				}
			}
		}
		if resp.Spec.TargetRef == nil {
			r.Spec.TargetRef = nil
		} else {
			r.Spec.TargetRef = &tfTypes.MeshAccessLogItemTargetRef{}
			r.Spec.TargetRef.Kind = types.StringValue(string(resp.Spec.TargetRef.Kind))
			if len(resp.Spec.TargetRef.Labels) > 0 {
				r.Spec.TargetRef.Labels = make(map[string]types.String, len(resp.Spec.TargetRef.Labels))
				for key, value := range resp.Spec.TargetRef.Labels {
					r.Spec.TargetRef.Labels[key] = types.StringValue(value)
				}
			}
			r.Spec.TargetRef.Mesh = types.StringPointerValue(resp.Spec.TargetRef.Mesh)
			r.Spec.TargetRef.Name = types.StringPointerValue(resp.Spec.TargetRef.Name)
			r.Spec.TargetRef.Namespace = types.StringPointerValue(resp.Spec.TargetRef.Namespace)
			r.Spec.TargetRef.ProxyTypes = make([]types.String, 0, len(resp.Spec.TargetRef.ProxyTypes))
			for _, v := range resp.Spec.TargetRef.ProxyTypes {
				r.Spec.TargetRef.ProxyTypes = append(r.Spec.TargetRef.ProxyTypes, types.StringValue(string(v)))
			}
			r.Spec.TargetRef.SectionName = types.StringPointerValue(resp.Spec.TargetRef.SectionName)
			if len(resp.Spec.TargetRef.Tags) > 0 {
				r.Spec.TargetRef.Tags = make(map[string]types.String, len(resp.Spec.TargetRef.Tags))
				for key1, value1 := range resp.Spec.TargetRef.Tags {
					r.Spec.TargetRef.Tags[key1] = types.StringValue(value1)
				}
			}
		}
		r.Type = types.StringValue(string(resp.Type))
	}

	return diags
}

func (r *MeshMetricResourceModel) ToOperationsDeleteMeshMetricRequest(ctx context.Context) (*operations.DeleteMeshMetricRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var mesh string
	mesh = r.Mesh.ValueString()

	var name string
	name = r.Name.ValueString()

	out := operations.DeleteMeshMetricRequest{
		Mesh: mesh,
		Name: name,
	}

	return &out, diags
}

func (r *MeshMetricResourceModel) ToOperationsGetMeshMetricRequest(ctx context.Context) (*operations.GetMeshMetricRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var mesh string
	mesh = r.Mesh.ValueString()

	var name string
	name = r.Name.ValueString()

	out := operations.GetMeshMetricRequest{
		Mesh: mesh,
		Name: name,
	}

	return &out, diags
}

func (r *MeshMetricResourceModel) ToOperationsPutMeshMetricRequest(ctx context.Context) (*operations.PutMeshMetricRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var mesh string
	mesh = r.Mesh.ValueString()

	var name string
	name = r.Name.ValueString()

	meshMetricItem, meshMetricItemDiags := r.ToSharedMeshMetricItemInput(ctx)
	diags.Append(meshMetricItemDiags...)

	if diags.HasError() {
		return nil, diags
	}

	out := operations.PutMeshMetricRequest{
		Mesh:           mesh,
		Name:           name,
		MeshMetricItem: *meshMetricItem,
	}

	return &out, diags
}

func (r *MeshMetricResourceModel) ToSharedMeshMetricItemInput(ctx context.Context) (*shared.MeshMetricItemInput, diag.Diagnostics) {
	var diags diag.Diagnostics

	typeVar := shared.MeshMetricItemType(r.Type.ValueString())
	mesh := new(string)
	if !r.Mesh.IsUnknown() && !r.Mesh.IsNull() {
		*mesh = r.Mesh.ValueString()
	} else {
		mesh = nil
	}
	var name string
	name = r.Name.ValueString()

	var labels map[string]string
	if !r.Labels.IsUnknown() && !r.Labels.IsNull() {
		diags.Append(r.Labels.ElementsAs(ctx, &labels, true)...)
	}
	var defaultVar *shared.Default
	if r.Spec.Default != nil {
		applications := make([]shared.Applications, 0, len(r.Spec.Default.Applications))
		for _, applicationsItem := range r.Spec.Default.Applications {
			address := new(string)
			if !applicationsItem.Address.IsUnknown() && !applicationsItem.Address.IsNull() {
				*address = applicationsItem.Address.ValueString()
			} else {
				address = nil
			}
			name1 := new(string)
			if !applicationsItem.Name.IsUnknown() && !applicationsItem.Name.IsNull() {
				*name1 = applicationsItem.Name.ValueString()
			} else {
				name1 = nil
			}
			path := new(string)
			if !applicationsItem.Path.IsUnknown() && !applicationsItem.Path.IsNull() {
				*path = applicationsItem.Path.ValueString()
			} else {
				path = nil
			}
			var port int
			port = int(applicationsItem.Port.ValueInt32())

			applications = append(applications, shared.Applications{
				Address: address,
				Name:    name1,
				Path:    path,
				Port:    port,
			})
		}
		backends := make([]shared.MeshMetricItemBackends, 0, len(r.Spec.Default.Backends))
		for _, backendsItem := range r.Spec.Default.Backends {
			var openTelemetry *shared.OpenTelemetry
			if backendsItem.OpenTelemetry != nil {
				var endpoint string
				endpoint = backendsItem.OpenTelemetry.Endpoint.ValueString()

				refreshInterval := new(string)
				if !backendsItem.OpenTelemetry.RefreshInterval.IsUnknown() && !backendsItem.OpenTelemetry.RefreshInterval.IsNull() {
					*refreshInterval = backendsItem.OpenTelemetry.RefreshInterval.ValueString()
				} else {
					refreshInterval = nil
				}
				openTelemetry = &shared.OpenTelemetry{
					Endpoint:        endpoint,
					RefreshInterval: refreshInterval,
				}
			}
			var prometheus *shared.Prometheus
			if backendsItem.Prometheus != nil {
				clientID := new(string)
				if !backendsItem.Prometheus.ClientID.IsUnknown() && !backendsItem.Prometheus.ClientID.IsNull() {
					*clientID = backendsItem.Prometheus.ClientID.ValueString()
				} else {
					clientID = nil
				}
				path1 := new(string)
				if !backendsItem.Prometheus.Path.IsUnknown() && !backendsItem.Prometheus.Path.IsNull() {
					*path1 = backendsItem.Prometheus.Path.ValueString()
				} else {
					path1 = nil
				}
				port1 := new(int)
				if !backendsItem.Prometheus.Port.IsUnknown() && !backendsItem.Prometheus.Port.IsNull() {
					*port1 = int(backendsItem.Prometheus.Port.ValueInt32())
				} else {
					port1 = nil
				}
				var tls *shared.MeshMetricItemTLS
				if backendsItem.Prometheus.TLS != nil {
					mode := new(shared.MeshMetricItemMode)
					if !backendsItem.Prometheus.TLS.Mode.IsUnknown() && !backendsItem.Prometheus.TLS.Mode.IsNull() {
						*mode = shared.MeshMetricItemMode(backendsItem.Prometheus.TLS.Mode.ValueString())
					} else {
						mode = nil
					}
					tls = &shared.MeshMetricItemTLS{
						Mode: mode,
					}
				}
				prometheus = &shared.Prometheus{
					ClientID: clientID,
					Path:     path1,
					Port:     port1,
					TLS:      tls,
				}
			}
			type1 := shared.MeshMetricItemSpecType(backendsItem.Type.ValueString())
			backends = append(backends, shared.MeshMetricItemBackends{
				OpenTelemetry: openTelemetry,
				Prometheus:    prometheus,
				Type:          type1,
			})
		}
		var sidecar *shared.Sidecar
		if r.Spec.Default.Sidecar != nil {
			includeUnused := new(bool)
			if !r.Spec.Default.Sidecar.IncludeUnused.IsUnknown() && !r.Spec.Default.Sidecar.IncludeUnused.IsNull() {
				*includeUnused = r.Spec.Default.Sidecar.IncludeUnused.ValueBool()
			} else {
				includeUnused = nil
			}
			var profiles *shared.Profiles
			if r.Spec.Default.Sidecar.Profiles != nil {
				appendProfiles := make([]shared.AppendProfiles, 0, len(r.Spec.Default.Sidecar.Profiles.AppendProfiles))
				for _, appendProfilesItem := range r.Spec.Default.Sidecar.Profiles.AppendProfiles {
					name2 := shared.Name(appendProfilesItem.Name.ValueString())
					appendProfiles = append(appendProfiles, shared.AppendProfiles{
						Name: name2,
					})
				}
				exclude := make([]shared.Exclude, 0, len(r.Spec.Default.Sidecar.Profiles.Exclude))
				for _, excludeItem := range r.Spec.Default.Sidecar.Profiles.Exclude {
					var match string
					match = excludeItem.Match.ValueString()

					type2 := shared.MeshMetricItemSpecDefaultType(excludeItem.Type.ValueString())
					exclude = append(exclude, shared.Exclude{
						Match: match,
						Type:  type2,
					})
				}
				include := make([]shared.Include, 0, len(r.Spec.Default.Sidecar.Profiles.Include))
				for _, includeItem := range r.Spec.Default.Sidecar.Profiles.Include {
					var match1 string
					match1 = includeItem.Match.ValueString()

					type3 := shared.MeshMetricItemSpecDefaultSidecarType(includeItem.Type.ValueString())
					include = append(include, shared.Include{
						Match: match1,
						Type:  type3,
					})
				}
				profiles = &shared.Profiles{
					AppendProfiles: appendProfiles,
					Exclude:        exclude,
					Include:        include,
				}
			}
			sidecar = &shared.Sidecar{
				IncludeUnused: includeUnused,
				Profiles:      profiles,
			}
		}
		defaultVar = &shared.Default{
			Applications: applications,
			Backends:     backends,
			Sidecar:      sidecar,
		}
	}
	var targetRef *shared.MeshMetricItemTargetRef
	if r.Spec.TargetRef != nil {
		kind := shared.MeshMetricItemKind(r.Spec.TargetRef.Kind.ValueString())
		labels1 := make(map[string]string)
		for labelsKey, labelsValue := range r.Spec.TargetRef.Labels {
			var labelsInst string
			labelsInst = labelsValue.ValueString()

			labels1[labelsKey] = labelsInst
		}
		mesh1 := new(string)
		if !r.Spec.TargetRef.Mesh.IsUnknown() && !r.Spec.TargetRef.Mesh.IsNull() {
			*mesh1 = r.Spec.TargetRef.Mesh.ValueString()
		} else {
			mesh1 = nil
		}
		name3 := new(string)
		if !r.Spec.TargetRef.Name.IsUnknown() && !r.Spec.TargetRef.Name.IsNull() {
			*name3 = r.Spec.TargetRef.Name.ValueString()
		} else {
			name3 = nil
		}
		namespace := new(string)
		if !r.Spec.TargetRef.Namespace.IsUnknown() && !r.Spec.TargetRef.Namespace.IsNull() {
			*namespace = r.Spec.TargetRef.Namespace.ValueString()
		} else {
			namespace = nil
		}
		proxyTypes := make([]shared.MeshMetricItemProxyTypes, 0, len(r.Spec.TargetRef.ProxyTypes))
		for _, proxyTypesItem := range r.Spec.TargetRef.ProxyTypes {
			proxyTypes = append(proxyTypes, shared.MeshMetricItemProxyTypes(proxyTypesItem.ValueString()))
		}
		sectionName := new(string)
		if !r.Spec.TargetRef.SectionName.IsUnknown() && !r.Spec.TargetRef.SectionName.IsNull() {
			*sectionName = r.Spec.TargetRef.SectionName.ValueString()
		} else {
			sectionName = nil
		}
		tags := make(map[string]string)
		for tagsKey, tagsValue := range r.Spec.TargetRef.Tags {
			var tagsInst string
			tagsInst = tagsValue.ValueString()

			tags[tagsKey] = tagsInst
		}
		targetRef = &shared.MeshMetricItemTargetRef{
			Kind:        kind,
			Labels:      labels1,
			Mesh:        mesh1,
			Name:        name3,
			Namespace:   namespace,
			ProxyTypes:  proxyTypes,
			SectionName: sectionName,
			Tags:        tags,
		}
	}
	spec := shared.MeshMetricItemSpec{
		Default:   defaultVar,
		TargetRef: targetRef,
	}
	out := shared.MeshMetricItemInput{
		Type:   typeVar,
		Mesh:   mesh,
		Name:   name,
		Labels: labels,
		Spec:   spec,
	}

	return &out, diags
}
