// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package provider

import (
	"context"
	"github.com/Kong/shared-speakeasy/customtypes/kumalabels"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/kong/terraform-provider-kong-mesh/internal/provider/typeconvert"
	tfTypes "github.com/kong/terraform-provider-kong-mesh/internal/provider/types"
	"github.com/kong/terraform-provider-kong-mesh/internal/sdk/models/operations"
	"github.com/kong/terraform-provider-kong-mesh/internal/sdk/models/shared"
)

func (r *MeshRateLimitResourceModel) RefreshFromSharedMeshRateLimitCreateOrUpdateSuccessResponse(ctx context.Context, resp *shared.MeshRateLimitCreateOrUpdateSuccessResponse) diag.Diagnostics {
	var diags diag.Diagnostics

	if resp != nil {
		r.Warnings = make([]types.String, 0, len(resp.Warnings))
		for _, v := range resp.Warnings {
			r.Warnings = append(r.Warnings, types.StringValue(v))
		}
	}

	return diags
}

func (r *MeshRateLimitResourceModel) RefreshFromSharedMeshRateLimitItem(ctx context.Context, resp *shared.MeshRateLimitItem) diag.Diagnostics {
	var diags diag.Diagnostics

	if resp != nil {
		r.CreationTime = types.StringPointerValue(typeconvert.TimePointerToStringPointer(resp.CreationTime))
		labelsValue, labelsDiags := types.MapValueFrom(ctx, types.StringType, resp.Labels)
		diags.Append(labelsDiags...)
		labelsValuable, labelsDiags := kumalabels.KumaLabelsMapType{MapType: types.MapType{ElemType: types.StringType}}.ValueFromMap(ctx, labelsValue)
		diags.Append(labelsDiags...)
		r.Labels, _ = labelsValuable.(kumalabels.KumaLabelsMapValue)
		r.Mesh = types.StringPointerValue(resp.Mesh)
		r.ModificationTime = types.StringPointerValue(typeconvert.TimePointerToStringPointer(resp.ModificationTime))
		r.Name = types.StringValue(resp.Name)
		r.Spec.From = []tfTypes.MeshRateLimitItemFrom{}

		for _, fromItem := range resp.Spec.From {
			var from tfTypes.MeshRateLimitItemFrom

			if fromItem.Default == nil {
				from.Default = nil
			} else {
				from.Default = &tfTypes.MeshRateLimitItemDefault{}
				if fromItem.Default.Local == nil {
					from.Default.Local = nil
				} else {
					from.Default.Local = &tfTypes.Local{}
					if fromItem.Default.Local.HTTP == nil {
						from.Default.Local.HTTP = nil
					} else {
						from.Default.Local.HTTP = &tfTypes.MeshRateLimitItemHTTP{}
						from.Default.Local.HTTP.Disabled = types.BoolPointerValue(fromItem.Default.Local.HTTP.Disabled)
						if fromItem.Default.Local.HTTP.OnRateLimit == nil {
							from.Default.Local.HTTP.OnRateLimit = nil
						} else {
							from.Default.Local.HTTP.OnRateLimit = &tfTypes.OnRateLimit{}
							if fromItem.Default.Local.HTTP.OnRateLimit.Headers == nil {
								from.Default.Local.HTTP.OnRateLimit.Headers = nil
							} else {
								from.Default.Local.HTTP.OnRateLimit.Headers = &tfTypes.MeshGlobalRateLimitItemHeaders{}
								from.Default.Local.HTTP.OnRateLimit.Headers.Add = []tfTypes.MeshGlobalRateLimitItemAdd{}

								for _, addItem := range fromItem.Default.Local.HTTP.OnRateLimit.Headers.Add {
									var add tfTypes.MeshGlobalRateLimitItemAdd

									add.Name = types.StringValue(addItem.Name)
									add.Value = types.StringValue(addItem.Value)

									from.Default.Local.HTTP.OnRateLimit.Headers.Add = append(from.Default.Local.HTTP.OnRateLimit.Headers.Add, add)
								}
								from.Default.Local.HTTP.OnRateLimit.Headers.Set = []tfTypes.MeshGlobalRateLimitItemAdd{}

								for _, setItem := range fromItem.Default.Local.HTTP.OnRateLimit.Headers.Set {
									var set tfTypes.MeshGlobalRateLimitItemAdd

									set.Name = types.StringValue(setItem.Name)
									set.Value = types.StringValue(setItem.Value)

									from.Default.Local.HTTP.OnRateLimit.Headers.Set = append(from.Default.Local.HTTP.OnRateLimit.Headers.Set, set)
								}
							}
							from.Default.Local.HTTP.OnRateLimit.Status = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(fromItem.Default.Local.HTTP.OnRateLimit.Status))
						}
						if fromItem.Default.Local.HTTP.RequestRate == nil {
							from.Default.Local.HTTP.RequestRate = nil
						} else {
							from.Default.Local.HTTP.RequestRate = &tfTypes.MeshGlobalRateLimitItemSpecFromRequestRate{}
							from.Default.Local.HTTP.RequestRate.Interval = types.StringValue(fromItem.Default.Local.HTTP.RequestRate.Interval)
							from.Default.Local.HTTP.RequestRate.Num = types.Int32Value(int32(fromItem.Default.Local.HTTP.RequestRate.Num))
						}
					}
					if fromItem.Default.Local.TCP == nil {
						from.Default.Local.TCP = nil
					} else {
						from.Default.Local.TCP = &tfTypes.MeshRateLimitItemTCP{}
						if fromItem.Default.Local.TCP.ConnectionRate == nil {
							from.Default.Local.TCP.ConnectionRate = nil
						} else {
							from.Default.Local.TCP.ConnectionRate = &tfTypes.MeshGlobalRateLimitItemSpecFromRequestRate{}
							from.Default.Local.TCP.ConnectionRate.Interval = types.StringValue(fromItem.Default.Local.TCP.ConnectionRate.Interval)
							from.Default.Local.TCP.ConnectionRate.Num = types.Int32Value(int32(fromItem.Default.Local.TCP.ConnectionRate.Num))
						}
						from.Default.Local.TCP.Disabled = types.BoolPointerValue(fromItem.Default.Local.TCP.Disabled)
					}
				}
			}
			from.TargetRef.Kind = types.StringValue(string(fromItem.TargetRef.Kind))
			if len(fromItem.TargetRef.Labels) > 0 {
				from.TargetRef.Labels = make(map[string]types.String, len(fromItem.TargetRef.Labels))
				for key, value := range fromItem.TargetRef.Labels {
					from.TargetRef.Labels[key] = types.StringValue(value)
				}
			}
			from.TargetRef.Mesh = types.StringPointerValue(fromItem.TargetRef.Mesh)
			from.TargetRef.Name = types.StringPointerValue(fromItem.TargetRef.Name)
			from.TargetRef.Namespace = types.StringPointerValue(fromItem.TargetRef.Namespace)
			from.TargetRef.ProxyTypes = make([]types.String, 0, len(fromItem.TargetRef.ProxyTypes))
			for _, v := range fromItem.TargetRef.ProxyTypes {
				from.TargetRef.ProxyTypes = append(from.TargetRef.ProxyTypes, types.StringValue(string(v)))
			}
			from.TargetRef.SectionName = types.StringPointerValue(fromItem.TargetRef.SectionName)
			if len(fromItem.TargetRef.Tags) > 0 {
				from.TargetRef.Tags = make(map[string]types.String, len(fromItem.TargetRef.Tags))
				for key1, value1 := range fromItem.TargetRef.Tags {
					from.TargetRef.Tags[key1] = types.StringValue(value1)
				}
			}

			r.Spec.From = append(r.Spec.From, from)
		}
		r.Spec.Rules = []tfTypes.MeshRateLimitItemRules{}

		for _, rulesItem := range resp.Spec.Rules {
			var rules tfTypes.MeshRateLimitItemRules

			if rulesItem.Default == nil {
				rules.Default = nil
			} else {
				rules.Default = &tfTypes.MeshRateLimitItemDefault{}
				if rulesItem.Default.Local == nil {
					rules.Default.Local = nil
				} else {
					rules.Default.Local = &tfTypes.Local{}
					if rulesItem.Default.Local.HTTP == nil {
						rules.Default.Local.HTTP = nil
					} else {
						rules.Default.Local.HTTP = &tfTypes.MeshRateLimitItemHTTP{}
						rules.Default.Local.HTTP.Disabled = types.BoolPointerValue(rulesItem.Default.Local.HTTP.Disabled)
						if rulesItem.Default.Local.HTTP.OnRateLimit == nil {
							rules.Default.Local.HTTP.OnRateLimit = nil
						} else {
							rules.Default.Local.HTTP.OnRateLimit = &tfTypes.OnRateLimit{}
							if rulesItem.Default.Local.HTTP.OnRateLimit.Headers == nil {
								rules.Default.Local.HTTP.OnRateLimit.Headers = nil
							} else {
								rules.Default.Local.HTTP.OnRateLimit.Headers = &tfTypes.MeshGlobalRateLimitItemHeaders{}
								rules.Default.Local.HTTP.OnRateLimit.Headers.Add = []tfTypes.MeshGlobalRateLimitItemAdd{}

								for _, addItem1 := range rulesItem.Default.Local.HTTP.OnRateLimit.Headers.Add {
									var add1 tfTypes.MeshGlobalRateLimitItemAdd

									add1.Name = types.StringValue(addItem1.Name)
									add1.Value = types.StringValue(addItem1.Value)

									rules.Default.Local.HTTP.OnRateLimit.Headers.Add = append(rules.Default.Local.HTTP.OnRateLimit.Headers.Add, add1)
								}
								rules.Default.Local.HTTP.OnRateLimit.Headers.Set = []tfTypes.MeshGlobalRateLimitItemAdd{}

								for _, setItem1 := range rulesItem.Default.Local.HTTP.OnRateLimit.Headers.Set {
									var set1 tfTypes.MeshGlobalRateLimitItemAdd

									set1.Name = types.StringValue(setItem1.Name)
									set1.Value = types.StringValue(setItem1.Value)

									rules.Default.Local.HTTP.OnRateLimit.Headers.Set = append(rules.Default.Local.HTTP.OnRateLimit.Headers.Set, set1)
								}
							}
							rules.Default.Local.HTTP.OnRateLimit.Status = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(rulesItem.Default.Local.HTTP.OnRateLimit.Status))
						}
						if rulesItem.Default.Local.HTTP.RequestRate == nil {
							rules.Default.Local.HTTP.RequestRate = nil
						} else {
							rules.Default.Local.HTTP.RequestRate = &tfTypes.MeshGlobalRateLimitItemSpecFromRequestRate{}
							rules.Default.Local.HTTP.RequestRate.Interval = types.StringValue(rulesItem.Default.Local.HTTP.RequestRate.Interval)
							rules.Default.Local.HTTP.RequestRate.Num = types.Int32Value(int32(rulesItem.Default.Local.HTTP.RequestRate.Num))
						}
					}
					if rulesItem.Default.Local.TCP == nil {
						rules.Default.Local.TCP = nil
					} else {
						rules.Default.Local.TCP = &tfTypes.MeshRateLimitItemTCP{}
						if rulesItem.Default.Local.TCP.ConnectionRate == nil {
							rules.Default.Local.TCP.ConnectionRate = nil
						} else {
							rules.Default.Local.TCP.ConnectionRate = &tfTypes.MeshGlobalRateLimitItemSpecFromRequestRate{}
							rules.Default.Local.TCP.ConnectionRate.Interval = types.StringValue(rulesItem.Default.Local.TCP.ConnectionRate.Interval)
							rules.Default.Local.TCP.ConnectionRate.Num = types.Int32Value(int32(rulesItem.Default.Local.TCP.ConnectionRate.Num))
						}
						rules.Default.Local.TCP.Disabled = types.BoolPointerValue(rulesItem.Default.Local.TCP.Disabled)
					}
				}
			}

			r.Spec.Rules = append(r.Spec.Rules, rules)
		}
		if resp.Spec.TargetRef == nil {
			r.Spec.TargetRef = nil
		} else {
			r.Spec.TargetRef = &tfTypes.MeshAccessLogItemTargetRef{}
			r.Spec.TargetRef.Kind = types.StringValue(string(resp.Spec.TargetRef.Kind))
			if len(resp.Spec.TargetRef.Labels) > 0 {
				r.Spec.TargetRef.Labels = make(map[string]types.String, len(resp.Spec.TargetRef.Labels))
				for key2, value2 := range resp.Spec.TargetRef.Labels {
					r.Spec.TargetRef.Labels[key2] = types.StringValue(value2)
				}
			}
			r.Spec.TargetRef.Mesh = types.StringPointerValue(resp.Spec.TargetRef.Mesh)
			r.Spec.TargetRef.Name = types.StringPointerValue(resp.Spec.TargetRef.Name)
			r.Spec.TargetRef.Namespace = types.StringPointerValue(resp.Spec.TargetRef.Namespace)
			r.Spec.TargetRef.ProxyTypes = make([]types.String, 0, len(resp.Spec.TargetRef.ProxyTypes))
			for _, v := range resp.Spec.TargetRef.ProxyTypes {
				r.Spec.TargetRef.ProxyTypes = append(r.Spec.TargetRef.ProxyTypes, types.StringValue(string(v)))
			}
			r.Spec.TargetRef.SectionName = types.StringPointerValue(resp.Spec.TargetRef.SectionName)
			if len(resp.Spec.TargetRef.Tags) > 0 {
				r.Spec.TargetRef.Tags = make(map[string]types.String, len(resp.Spec.TargetRef.Tags))
				for key3, value3 := range resp.Spec.TargetRef.Tags {
					r.Spec.TargetRef.Tags[key3] = types.StringValue(value3)
				}
			}
		}
		r.Spec.To = []tfTypes.MeshRateLimitItemFrom{}

		for _, toItem := range resp.Spec.To {
			var to tfTypes.MeshRateLimitItemFrom

			if toItem.Default == nil {
				to.Default = nil
			} else {
				to.Default = &tfTypes.MeshRateLimitItemDefault{}
				if toItem.Default.Local == nil {
					to.Default.Local = nil
				} else {
					to.Default.Local = &tfTypes.Local{}
					if toItem.Default.Local.HTTP == nil {
						to.Default.Local.HTTP = nil
					} else {
						to.Default.Local.HTTP = &tfTypes.MeshRateLimitItemHTTP{}
						to.Default.Local.HTTP.Disabled = types.BoolPointerValue(toItem.Default.Local.HTTP.Disabled)
						if toItem.Default.Local.HTTP.OnRateLimit == nil {
							to.Default.Local.HTTP.OnRateLimit = nil
						} else {
							to.Default.Local.HTTP.OnRateLimit = &tfTypes.OnRateLimit{}
							if toItem.Default.Local.HTTP.OnRateLimit.Headers == nil {
								to.Default.Local.HTTP.OnRateLimit.Headers = nil
							} else {
								to.Default.Local.HTTP.OnRateLimit.Headers = &tfTypes.MeshGlobalRateLimitItemHeaders{}
								to.Default.Local.HTTP.OnRateLimit.Headers.Add = []tfTypes.MeshGlobalRateLimitItemAdd{}

								for _, addItem2 := range toItem.Default.Local.HTTP.OnRateLimit.Headers.Add {
									var add2 tfTypes.MeshGlobalRateLimitItemAdd

									add2.Name = types.StringValue(addItem2.Name)
									add2.Value = types.StringValue(addItem2.Value)

									to.Default.Local.HTTP.OnRateLimit.Headers.Add = append(to.Default.Local.HTTP.OnRateLimit.Headers.Add, add2)
								}
								to.Default.Local.HTTP.OnRateLimit.Headers.Set = []tfTypes.MeshGlobalRateLimitItemAdd{}

								for _, setItem2 := range toItem.Default.Local.HTTP.OnRateLimit.Headers.Set {
									var set2 tfTypes.MeshGlobalRateLimitItemAdd

									set2.Name = types.StringValue(setItem2.Name)
									set2.Value = types.StringValue(setItem2.Value)

									to.Default.Local.HTTP.OnRateLimit.Headers.Set = append(to.Default.Local.HTTP.OnRateLimit.Headers.Set, set2)
								}
							}
							to.Default.Local.HTTP.OnRateLimit.Status = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(toItem.Default.Local.HTTP.OnRateLimit.Status))
						}
						if toItem.Default.Local.HTTP.RequestRate == nil {
							to.Default.Local.HTTP.RequestRate = nil
						} else {
							to.Default.Local.HTTP.RequestRate = &tfTypes.MeshGlobalRateLimitItemSpecFromRequestRate{}
							to.Default.Local.HTTP.RequestRate.Interval = types.StringValue(toItem.Default.Local.HTTP.RequestRate.Interval)
							to.Default.Local.HTTP.RequestRate.Num = types.Int32Value(int32(toItem.Default.Local.HTTP.RequestRate.Num))
						}
					}
					if toItem.Default.Local.TCP == nil {
						to.Default.Local.TCP = nil
					} else {
						to.Default.Local.TCP = &tfTypes.MeshRateLimitItemTCP{}
						if toItem.Default.Local.TCP.ConnectionRate == nil {
							to.Default.Local.TCP.ConnectionRate = nil
						} else {
							to.Default.Local.TCP.ConnectionRate = &tfTypes.MeshGlobalRateLimitItemSpecFromRequestRate{}
							to.Default.Local.TCP.ConnectionRate.Interval = types.StringValue(toItem.Default.Local.TCP.ConnectionRate.Interval)
							to.Default.Local.TCP.ConnectionRate.Num = types.Int32Value(int32(toItem.Default.Local.TCP.ConnectionRate.Num))
						}
						to.Default.Local.TCP.Disabled = types.BoolPointerValue(toItem.Default.Local.TCP.Disabled)
					}
				}
			}
			to.TargetRef.Kind = types.StringValue(string(toItem.TargetRef.Kind))
			if len(toItem.TargetRef.Labels) > 0 {
				to.TargetRef.Labels = make(map[string]types.String, len(toItem.TargetRef.Labels))
				for key4, value4 := range toItem.TargetRef.Labels {
					to.TargetRef.Labels[key4] = types.StringValue(value4)
				}
			}
			to.TargetRef.Mesh = types.StringPointerValue(toItem.TargetRef.Mesh)
			to.TargetRef.Name = types.StringPointerValue(toItem.TargetRef.Name)
			to.TargetRef.Namespace = types.StringPointerValue(toItem.TargetRef.Namespace)
			to.TargetRef.ProxyTypes = make([]types.String, 0, len(toItem.TargetRef.ProxyTypes))
			for _, v := range toItem.TargetRef.ProxyTypes {
				to.TargetRef.ProxyTypes = append(to.TargetRef.ProxyTypes, types.StringValue(string(v)))
			}
			to.TargetRef.SectionName = types.StringPointerValue(toItem.TargetRef.SectionName)
			if len(toItem.TargetRef.Tags) > 0 {
				to.TargetRef.Tags = make(map[string]types.String, len(toItem.TargetRef.Tags))
				for key5, value5 := range toItem.TargetRef.Tags {
					to.TargetRef.Tags[key5] = types.StringValue(value5)
				}
			}

			r.Spec.To = append(r.Spec.To, to)
		}
		r.Type = types.StringValue(string(resp.Type))
	}

	return diags
}

func (r *MeshRateLimitResourceModel) ToOperationsDeleteMeshRateLimitRequest(ctx context.Context) (*operations.DeleteMeshRateLimitRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var mesh string
	mesh = r.Mesh.ValueString()

	var name string
	name = r.Name.ValueString()

	out := operations.DeleteMeshRateLimitRequest{
		Mesh: mesh,
		Name: name,
	}

	return &out, diags
}

func (r *MeshRateLimitResourceModel) ToOperationsGetMeshRateLimitRequest(ctx context.Context) (*operations.GetMeshRateLimitRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var mesh string
	mesh = r.Mesh.ValueString()

	var name string
	name = r.Name.ValueString()

	out := operations.GetMeshRateLimitRequest{
		Mesh: mesh,
		Name: name,
	}

	return &out, diags
}

func (r *MeshRateLimitResourceModel) ToOperationsPutMeshRateLimitRequest(ctx context.Context) (*operations.PutMeshRateLimitRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var mesh string
	mesh = r.Mesh.ValueString()

	var name string
	name = r.Name.ValueString()

	meshRateLimitItem, meshRateLimitItemDiags := r.ToSharedMeshRateLimitItemInput(ctx)
	diags.Append(meshRateLimitItemDiags...)

	if diags.HasError() {
		return nil, diags
	}

	out := operations.PutMeshRateLimitRequest{
		Mesh:              mesh,
		Name:              name,
		MeshRateLimitItem: *meshRateLimitItem,
	}

	return &out, diags
}

func (r *MeshRateLimitResourceModel) ToSharedMeshRateLimitItemInput(ctx context.Context) (*shared.MeshRateLimitItemInput, diag.Diagnostics) {
	var diags diag.Diagnostics

	typeVar := shared.MeshRateLimitItemType(r.Type.ValueString())
	mesh := new(string)
	if !r.Mesh.IsUnknown() && !r.Mesh.IsNull() {
		*mesh = r.Mesh.ValueString()
	} else {
		mesh = nil
	}
	var name string
	name = r.Name.ValueString()

	var labels map[string]string
	if !r.Labels.IsUnknown() && !r.Labels.IsNull() {
		diags.Append(r.Labels.ElementsAs(ctx, &labels, true)...)
	}
	from := make([]shared.MeshRateLimitItemFrom, 0, len(r.Spec.From))
	for _, fromItem := range r.Spec.From {
		var defaultVar *shared.MeshRateLimitItemDefault
		if fromItem.Default != nil {
			var local *shared.Local
			if fromItem.Default.Local != nil {
				var http *shared.MeshRateLimitItemHTTP
				if fromItem.Default.Local.HTTP != nil {
					disabled := new(bool)
					if !fromItem.Default.Local.HTTP.Disabled.IsUnknown() && !fromItem.Default.Local.HTTP.Disabled.IsNull() {
						*disabled = fromItem.Default.Local.HTTP.Disabled.ValueBool()
					} else {
						disabled = nil
					}
					var onRateLimit *shared.MeshRateLimitItemSpecFromOnRateLimit
					if fromItem.Default.Local.HTTP.OnRateLimit != nil {
						var headers *shared.MeshRateLimitItemHeaders
						if fromItem.Default.Local.HTTP.OnRateLimit.Headers != nil {
							add := make([]shared.MeshRateLimitItemAdd, 0, len(fromItem.Default.Local.HTTP.OnRateLimit.Headers.Add))
							for _, addItem := range fromItem.Default.Local.HTTP.OnRateLimit.Headers.Add {
								var name1 string
								name1 = addItem.Name.ValueString()

								var value string
								value = addItem.Value.ValueString()

								add = append(add, shared.MeshRateLimitItemAdd{
									Name:  name1,
									Value: value,
								})
							}
							set := make([]shared.MeshRateLimitItemSet, 0, len(fromItem.Default.Local.HTTP.OnRateLimit.Headers.Set))
							for _, setItem := range fromItem.Default.Local.HTTP.OnRateLimit.Headers.Set {
								var name2 string
								name2 = setItem.Name.ValueString()

								var value1 string
								value1 = setItem.Value.ValueString()

								set = append(set, shared.MeshRateLimitItemSet{
									Name:  name2,
									Value: value1,
								})
							}
							headers = &shared.MeshRateLimitItemHeaders{
								Add: add,
								Set: set,
							}
						}
						status := new(int)
						if !fromItem.Default.Local.HTTP.OnRateLimit.Status.IsUnknown() && !fromItem.Default.Local.HTTP.OnRateLimit.Status.IsNull() {
							*status = int(fromItem.Default.Local.HTTP.OnRateLimit.Status.ValueInt32())
						} else {
							status = nil
						}
						onRateLimit = &shared.MeshRateLimitItemSpecFromOnRateLimit{
							Headers: headers,
							Status:  status,
						}
					}
					var requestRate *shared.MeshRateLimitItemSpecFromRequestRate
					if fromItem.Default.Local.HTTP.RequestRate != nil {
						var interval string
						interval = fromItem.Default.Local.HTTP.RequestRate.Interval.ValueString()

						var num int
						num = int(fromItem.Default.Local.HTTP.RequestRate.Num.ValueInt32())

						requestRate = &shared.MeshRateLimitItemSpecFromRequestRate{
							Interval: interval,
							Num:      num,
						}
					}
					http = &shared.MeshRateLimitItemHTTP{
						Disabled:    disabled,
						OnRateLimit: onRateLimit,
						RequestRate: requestRate,
					}
				}
				var tcp *shared.MeshRateLimitItemTCP
				if fromItem.Default.Local.TCP != nil {
					var connectionRate *shared.ConnectionRate
					if fromItem.Default.Local.TCP.ConnectionRate != nil {
						var interval1 string
						interval1 = fromItem.Default.Local.TCP.ConnectionRate.Interval.ValueString()

						var num1 int
						num1 = int(fromItem.Default.Local.TCP.ConnectionRate.Num.ValueInt32())

						connectionRate = &shared.ConnectionRate{
							Interval: interval1,
							Num:      num1,
						}
					}
					disabled1 := new(bool)
					if !fromItem.Default.Local.TCP.Disabled.IsUnknown() && !fromItem.Default.Local.TCP.Disabled.IsNull() {
						*disabled1 = fromItem.Default.Local.TCP.Disabled.ValueBool()
					} else {
						disabled1 = nil
					}
					tcp = &shared.MeshRateLimitItemTCP{
						ConnectionRate: connectionRate,
						Disabled:       disabled1,
					}
				}
				local = &shared.Local{
					HTTP: http,
					TCP:  tcp,
				}
			}
			defaultVar = &shared.MeshRateLimitItemDefault{
				Local: local,
			}
		}
		kind := shared.MeshRateLimitItemSpecKind(fromItem.TargetRef.Kind.ValueString())
		labels1 := make(map[string]string)
		for labelsKey, labelsValue := range fromItem.TargetRef.Labels {
			var labelsInst string
			labelsInst = labelsValue.ValueString()

			labels1[labelsKey] = labelsInst
		}
		mesh1 := new(string)
		if !fromItem.TargetRef.Mesh.IsUnknown() && !fromItem.TargetRef.Mesh.IsNull() {
			*mesh1 = fromItem.TargetRef.Mesh.ValueString()
		} else {
			mesh1 = nil
		}
		name3 := new(string)
		if !fromItem.TargetRef.Name.IsUnknown() && !fromItem.TargetRef.Name.IsNull() {
			*name3 = fromItem.TargetRef.Name.ValueString()
		} else {
			name3 = nil
		}
		namespace := new(string)
		if !fromItem.TargetRef.Namespace.IsUnknown() && !fromItem.TargetRef.Namespace.IsNull() {
			*namespace = fromItem.TargetRef.Namespace.ValueString()
		} else {
			namespace = nil
		}
		proxyTypes := make([]shared.MeshRateLimitItemSpecProxyTypes, 0, len(fromItem.TargetRef.ProxyTypes))
		for _, proxyTypesItem := range fromItem.TargetRef.ProxyTypes {
			proxyTypes = append(proxyTypes, shared.MeshRateLimitItemSpecProxyTypes(proxyTypesItem.ValueString()))
		}
		sectionName := new(string)
		if !fromItem.TargetRef.SectionName.IsUnknown() && !fromItem.TargetRef.SectionName.IsNull() {
			*sectionName = fromItem.TargetRef.SectionName.ValueString()
		} else {
			sectionName = nil
		}
		tags := make(map[string]string)
		for tagsKey, tagsValue := range fromItem.TargetRef.Tags {
			var tagsInst string
			tagsInst = tagsValue.ValueString()

			tags[tagsKey] = tagsInst
		}
		targetRef := shared.MeshRateLimitItemSpecTargetRef{
			Kind:        kind,
			Labels:      labels1,
			Mesh:        mesh1,
			Name:        name3,
			Namespace:   namespace,
			ProxyTypes:  proxyTypes,
			SectionName: sectionName,
			Tags:        tags,
		}
		from = append(from, shared.MeshRateLimitItemFrom{
			Default:   defaultVar,
			TargetRef: targetRef,
		})
	}
	rules := make([]shared.MeshRateLimitItemRules, 0, len(r.Spec.Rules))
	for _, rulesItem := range r.Spec.Rules {
		var default1 *shared.MeshRateLimitItemSpecDefault
		if rulesItem.Default != nil {
			var local1 *shared.MeshRateLimitItemLocal
			if rulesItem.Default.Local != nil {
				var http1 *shared.MeshRateLimitItemSpecHTTP
				if rulesItem.Default.Local.HTTP != nil {
					disabled2 := new(bool)
					if !rulesItem.Default.Local.HTTP.Disabled.IsUnknown() && !rulesItem.Default.Local.HTTP.Disabled.IsNull() {
						*disabled2 = rulesItem.Default.Local.HTTP.Disabled.ValueBool()
					} else {
						disabled2 = nil
					}
					var onRateLimit1 *shared.MeshRateLimitItemOnRateLimit
					if rulesItem.Default.Local.HTTP.OnRateLimit != nil {
						var headers1 *shared.MeshRateLimitItemSpecHeaders
						if rulesItem.Default.Local.HTTP.OnRateLimit.Headers != nil {
							add1 := make([]shared.MeshRateLimitItemSpecAdd, 0, len(rulesItem.Default.Local.HTTP.OnRateLimit.Headers.Add))
							for _, addItem1 := range rulesItem.Default.Local.HTTP.OnRateLimit.Headers.Add {
								var name4 string
								name4 = addItem1.Name.ValueString()

								var value2 string
								value2 = addItem1.Value.ValueString()

								add1 = append(add1, shared.MeshRateLimitItemSpecAdd{
									Name:  name4,
									Value: value2,
								})
							}
							set1 := make([]shared.MeshRateLimitItemSpecSet, 0, len(rulesItem.Default.Local.HTTP.OnRateLimit.Headers.Set))
							for _, setItem1 := range rulesItem.Default.Local.HTTP.OnRateLimit.Headers.Set {
								var name5 string
								name5 = setItem1.Name.ValueString()

								var value3 string
								value3 = setItem1.Value.ValueString()

								set1 = append(set1, shared.MeshRateLimitItemSpecSet{
									Name:  name5,
									Value: value3,
								})
							}
							headers1 = &shared.MeshRateLimitItemSpecHeaders{
								Add: add1,
								Set: set1,
							}
						}
						status1 := new(int)
						if !rulesItem.Default.Local.HTTP.OnRateLimit.Status.IsUnknown() && !rulesItem.Default.Local.HTTP.OnRateLimit.Status.IsNull() {
							*status1 = int(rulesItem.Default.Local.HTTP.OnRateLimit.Status.ValueInt32())
						} else {
							status1 = nil
						}
						onRateLimit1 = &shared.MeshRateLimitItemOnRateLimit{
							Headers: headers1,
							Status:  status1,
						}
					}
					var requestRate1 *shared.MeshRateLimitItemRequestRate
					if rulesItem.Default.Local.HTTP.RequestRate != nil {
						var interval2 string
						interval2 = rulesItem.Default.Local.HTTP.RequestRate.Interval.ValueString()

						var num2 int
						num2 = int(rulesItem.Default.Local.HTTP.RequestRate.Num.ValueInt32())

						requestRate1 = &shared.MeshRateLimitItemRequestRate{
							Interval: interval2,
							Num:      num2,
						}
					}
					http1 = &shared.MeshRateLimitItemSpecHTTP{
						Disabled:    disabled2,
						OnRateLimit: onRateLimit1,
						RequestRate: requestRate1,
					}
				}
				var tcp1 *shared.MeshRateLimitItemSpecTCP
				if rulesItem.Default.Local.TCP != nil {
					var connectionRate1 *shared.MeshRateLimitItemConnectionRate
					if rulesItem.Default.Local.TCP.ConnectionRate != nil {
						var interval3 string
						interval3 = rulesItem.Default.Local.TCP.ConnectionRate.Interval.ValueString()

						var num3 int
						num3 = int(rulesItem.Default.Local.TCP.ConnectionRate.Num.ValueInt32())

						connectionRate1 = &shared.MeshRateLimitItemConnectionRate{
							Interval: interval3,
							Num:      num3,
						}
					}
					disabled3 := new(bool)
					if !rulesItem.Default.Local.TCP.Disabled.IsUnknown() && !rulesItem.Default.Local.TCP.Disabled.IsNull() {
						*disabled3 = rulesItem.Default.Local.TCP.Disabled.ValueBool()
					} else {
						disabled3 = nil
					}
					tcp1 = &shared.MeshRateLimitItemSpecTCP{
						ConnectionRate: connectionRate1,
						Disabled:       disabled3,
					}
				}
				local1 = &shared.MeshRateLimitItemLocal{
					HTTP: http1,
					TCP:  tcp1,
				}
			}
			default1 = &shared.MeshRateLimitItemSpecDefault{
				Local: local1,
			}
		}
		rules = append(rules, shared.MeshRateLimitItemRules{
			Default: default1,
		})
	}
	var targetRef1 *shared.MeshRateLimitItemTargetRef
	if r.Spec.TargetRef != nil {
		kind1 := shared.MeshRateLimitItemKind(r.Spec.TargetRef.Kind.ValueString())
		labels2 := make(map[string]string)
		for labelsKey1, labelsValue1 := range r.Spec.TargetRef.Labels {
			var labelsInst1 string
			labelsInst1 = labelsValue1.ValueString()

			labels2[labelsKey1] = labelsInst1
		}
		mesh2 := new(string)
		if !r.Spec.TargetRef.Mesh.IsUnknown() && !r.Spec.TargetRef.Mesh.IsNull() {
			*mesh2 = r.Spec.TargetRef.Mesh.ValueString()
		} else {
			mesh2 = nil
		}
		name6 := new(string)
		if !r.Spec.TargetRef.Name.IsUnknown() && !r.Spec.TargetRef.Name.IsNull() {
			*name6 = r.Spec.TargetRef.Name.ValueString()
		} else {
			name6 = nil
		}
		namespace1 := new(string)
		if !r.Spec.TargetRef.Namespace.IsUnknown() && !r.Spec.TargetRef.Namespace.IsNull() {
			*namespace1 = r.Spec.TargetRef.Namespace.ValueString()
		} else {
			namespace1 = nil
		}
		proxyTypes1 := make([]shared.MeshRateLimitItemProxyTypes, 0, len(r.Spec.TargetRef.ProxyTypes))
		for _, proxyTypesItem1 := range r.Spec.TargetRef.ProxyTypes {
			proxyTypes1 = append(proxyTypes1, shared.MeshRateLimitItemProxyTypes(proxyTypesItem1.ValueString()))
		}
		sectionName1 := new(string)
		if !r.Spec.TargetRef.SectionName.IsUnknown() && !r.Spec.TargetRef.SectionName.IsNull() {
			*sectionName1 = r.Spec.TargetRef.SectionName.ValueString()
		} else {
			sectionName1 = nil
		}
		tags1 := make(map[string]string)
		for tagsKey1, tagsValue1 := range r.Spec.TargetRef.Tags {
			var tagsInst1 string
			tagsInst1 = tagsValue1.ValueString()

			tags1[tagsKey1] = tagsInst1
		}
		targetRef1 = &shared.MeshRateLimitItemTargetRef{
			Kind:        kind1,
			Labels:      labels2,
			Mesh:        mesh2,
			Name:        name6,
			Namespace:   namespace1,
			ProxyTypes:  proxyTypes1,
			SectionName: sectionName1,
			Tags:        tags1,
		}
	}
	to := make([]shared.MeshRateLimitItemTo, 0, len(r.Spec.To))
	for _, toItem := range r.Spec.To {
		var default2 *shared.MeshRateLimitItemSpecToDefault
		if toItem.Default != nil {
			var local2 *shared.MeshRateLimitItemSpecLocal
			if toItem.Default.Local != nil {
				var http2 *shared.MeshRateLimitItemSpecToHTTP
				if toItem.Default.Local.HTTP != nil {
					disabled4 := new(bool)
					if !toItem.Default.Local.HTTP.Disabled.IsUnknown() && !toItem.Default.Local.HTTP.Disabled.IsNull() {
						*disabled4 = toItem.Default.Local.HTTP.Disabled.ValueBool()
					} else {
						disabled4 = nil
					}
					var onRateLimit2 *shared.MeshRateLimitItemSpecOnRateLimit
					if toItem.Default.Local.HTTP.OnRateLimit != nil {
						var headers2 *shared.MeshRateLimitItemSpecToHeaders
						if toItem.Default.Local.HTTP.OnRateLimit.Headers != nil {
							add2 := make([]shared.MeshRateLimitItemSpecToAdd, 0, len(toItem.Default.Local.HTTP.OnRateLimit.Headers.Add))
							for _, addItem2 := range toItem.Default.Local.HTTP.OnRateLimit.Headers.Add {
								var name7 string
								name7 = addItem2.Name.ValueString()

								var value4 string
								value4 = addItem2.Value.ValueString()

								add2 = append(add2, shared.MeshRateLimitItemSpecToAdd{
									Name:  name7,
									Value: value4,
								})
							}
							set2 := make([]shared.MeshRateLimitItemSpecToSet, 0, len(toItem.Default.Local.HTTP.OnRateLimit.Headers.Set))
							for _, setItem2 := range toItem.Default.Local.HTTP.OnRateLimit.Headers.Set {
								var name8 string
								name8 = setItem2.Name.ValueString()

								var value5 string
								value5 = setItem2.Value.ValueString()

								set2 = append(set2, shared.MeshRateLimitItemSpecToSet{
									Name:  name8,
									Value: value5,
								})
							}
							headers2 = &shared.MeshRateLimitItemSpecToHeaders{
								Add: add2,
								Set: set2,
							}
						}
						status2 := new(int)
						if !toItem.Default.Local.HTTP.OnRateLimit.Status.IsUnknown() && !toItem.Default.Local.HTTP.OnRateLimit.Status.IsNull() {
							*status2 = int(toItem.Default.Local.HTTP.OnRateLimit.Status.ValueInt32())
						} else {
							status2 = nil
						}
						onRateLimit2 = &shared.MeshRateLimitItemSpecOnRateLimit{
							Headers: headers2,
							Status:  status2,
						}
					}
					var requestRate2 *shared.MeshRateLimitItemSpecRequestRate
					if toItem.Default.Local.HTTP.RequestRate != nil {
						var interval4 string
						interval4 = toItem.Default.Local.HTTP.RequestRate.Interval.ValueString()

						var num4 int
						num4 = int(toItem.Default.Local.HTTP.RequestRate.Num.ValueInt32())

						requestRate2 = &shared.MeshRateLimitItemSpecRequestRate{
							Interval: interval4,
							Num:      num4,
						}
					}
					http2 = &shared.MeshRateLimitItemSpecToHTTP{
						Disabled:    disabled4,
						OnRateLimit: onRateLimit2,
						RequestRate: requestRate2,
					}
				}
				var tcp2 *shared.MeshRateLimitItemSpecToTCP
				if toItem.Default.Local.TCP != nil {
					var connectionRate2 *shared.MeshRateLimitItemSpecConnectionRate
					if toItem.Default.Local.TCP.ConnectionRate != nil {
						var interval5 string
						interval5 = toItem.Default.Local.TCP.ConnectionRate.Interval.ValueString()

						var num5 int
						num5 = int(toItem.Default.Local.TCP.ConnectionRate.Num.ValueInt32())

						connectionRate2 = &shared.MeshRateLimitItemSpecConnectionRate{
							Interval: interval5,
							Num:      num5,
						}
					}
					disabled5 := new(bool)
					if !toItem.Default.Local.TCP.Disabled.IsUnknown() && !toItem.Default.Local.TCP.Disabled.IsNull() {
						*disabled5 = toItem.Default.Local.TCP.Disabled.ValueBool()
					} else {
						disabled5 = nil
					}
					tcp2 = &shared.MeshRateLimitItemSpecToTCP{
						ConnectionRate: connectionRate2,
						Disabled:       disabled5,
					}
				}
				local2 = &shared.MeshRateLimitItemSpecLocal{
					HTTP: http2,
					TCP:  tcp2,
				}
			}
			default2 = &shared.MeshRateLimitItemSpecToDefault{
				Local: local2,
			}
		}
		kind2 := shared.MeshRateLimitItemSpecToKind(toItem.TargetRef.Kind.ValueString())
		labels3 := make(map[string]string)
		for labelsKey2, labelsValue2 := range toItem.TargetRef.Labels {
			var labelsInst2 string
			labelsInst2 = labelsValue2.ValueString()

			labels3[labelsKey2] = labelsInst2
		}
		mesh3 := new(string)
		if !toItem.TargetRef.Mesh.IsUnknown() && !toItem.TargetRef.Mesh.IsNull() {
			*mesh3 = toItem.TargetRef.Mesh.ValueString()
		} else {
			mesh3 = nil
		}
		name9 := new(string)
		if !toItem.TargetRef.Name.IsUnknown() && !toItem.TargetRef.Name.IsNull() {
			*name9 = toItem.TargetRef.Name.ValueString()
		} else {
			name9 = nil
		}
		namespace2 := new(string)
		if !toItem.TargetRef.Namespace.IsUnknown() && !toItem.TargetRef.Namespace.IsNull() {
			*namespace2 = toItem.TargetRef.Namespace.ValueString()
		} else {
			namespace2 = nil
		}
		proxyTypes2 := make([]shared.MeshRateLimitItemSpecToProxyTypes, 0, len(toItem.TargetRef.ProxyTypes))
		for _, proxyTypesItem2 := range toItem.TargetRef.ProxyTypes {
			proxyTypes2 = append(proxyTypes2, shared.MeshRateLimitItemSpecToProxyTypes(proxyTypesItem2.ValueString()))
		}
		sectionName2 := new(string)
		if !toItem.TargetRef.SectionName.IsUnknown() && !toItem.TargetRef.SectionName.IsNull() {
			*sectionName2 = toItem.TargetRef.SectionName.ValueString()
		} else {
			sectionName2 = nil
		}
		tags2 := make(map[string]string)
		for tagsKey2, tagsValue2 := range toItem.TargetRef.Tags {
			var tagsInst2 string
			tagsInst2 = tagsValue2.ValueString()

			tags2[tagsKey2] = tagsInst2
		}
		targetRef2 := shared.MeshRateLimitItemSpecToTargetRef{
			Kind:        kind2,
			Labels:      labels3,
			Mesh:        mesh3,
			Name:        name9,
			Namespace:   namespace2,
			ProxyTypes:  proxyTypes2,
			SectionName: sectionName2,
			Tags:        tags2,
		}
		to = append(to, shared.MeshRateLimitItemTo{
			Default:   default2,
			TargetRef: targetRef2,
		})
	}
	spec := shared.MeshRateLimitItemSpec{
		From:      from,
		Rules:     rules,
		TargetRef: targetRef1,
		To:        to,
	}
	out := shared.MeshRateLimitItemInput{
		Type:   typeVar,
		Mesh:   mesh,
		Name:   name,
		Labels: labels,
		Spec:   spec,
	}

	return &out, diags
}
