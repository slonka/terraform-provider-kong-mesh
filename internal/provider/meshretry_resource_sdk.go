// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package provider

import (
	"context"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/kong/terraform-provider-kong-mesh/internal/provider/typeconvert"
	tfTypes "github.com/kong/terraform-provider-kong-mesh/internal/provider/types"
	"github.com/kong/terraform-provider-kong-mesh/internal/sdk/models/operations"
	"github.com/kong/terraform-provider-kong-mesh/internal/sdk/models/shared"
)

func (r *MeshRetryResourceModel) ToSharedMeshRetryItemInput(ctx context.Context) (*shared.MeshRetryItemInput, diag.Diagnostics) {
	var diags diag.Diagnostics

	typeVar := shared.MeshRetryItemType(r.Type.ValueString())
	mesh := new(string)
	if !r.Mesh.IsUnknown() && !r.Mesh.IsNull() {
		*mesh = r.Mesh.ValueString()
	} else {
		mesh = nil
	}
	var name string
	name = r.Name.ValueString()

	labels := make(map[string]string)
	for labelsKey, labelsValue := range r.Labels {
		var labelsInst string
		labelsInst = labelsValue.ValueString()

		labels[labelsKey] = labelsInst
	}
	var targetRef *shared.MeshRetryItemTargetRef
	if r.Spec.TargetRef != nil {
		kind := shared.MeshRetryItemKind(r.Spec.TargetRef.Kind.ValueString())
		labels1 := make(map[string]string)
		for labelsKey1, labelsValue1 := range r.Spec.TargetRef.Labels {
			var labelsInst1 string
			labelsInst1 = labelsValue1.ValueString()

			labels1[labelsKey1] = labelsInst1
		}
		mesh1 := new(string)
		if !r.Spec.TargetRef.Mesh.IsUnknown() && !r.Spec.TargetRef.Mesh.IsNull() {
			*mesh1 = r.Spec.TargetRef.Mesh.ValueString()
		} else {
			mesh1 = nil
		}
		name1 := new(string)
		if !r.Spec.TargetRef.Name.IsUnknown() && !r.Spec.TargetRef.Name.IsNull() {
			*name1 = r.Spec.TargetRef.Name.ValueString()
		} else {
			name1 = nil
		}
		namespace := new(string)
		if !r.Spec.TargetRef.Namespace.IsUnknown() && !r.Spec.TargetRef.Namespace.IsNull() {
			*namespace = r.Spec.TargetRef.Namespace.ValueString()
		} else {
			namespace = nil
		}
		proxyTypes := make([]shared.MeshRetryItemProxyTypes, 0, len(r.Spec.TargetRef.ProxyTypes))
		for _, proxyTypesItem := range r.Spec.TargetRef.ProxyTypes {
			proxyTypes = append(proxyTypes, shared.MeshRetryItemProxyTypes(proxyTypesItem.ValueString()))
		}
		sectionName := new(string)
		if !r.Spec.TargetRef.SectionName.IsUnknown() && !r.Spec.TargetRef.SectionName.IsNull() {
			*sectionName = r.Spec.TargetRef.SectionName.ValueString()
		} else {
			sectionName = nil
		}
		tags := make(map[string]string)
		for tagsKey, tagsValue := range r.Spec.TargetRef.Tags {
			var tagsInst string
			tagsInst = tagsValue.ValueString()

			tags[tagsKey] = tagsInst
		}
		targetRef = &shared.MeshRetryItemTargetRef{
			Kind:        kind,
			Labels:      labels1,
			Mesh:        mesh1,
			Name:        name1,
			Namespace:   namespace,
			ProxyTypes:  proxyTypes,
			SectionName: sectionName,
			Tags:        tags,
		}
	}
	to := make([]shared.MeshRetryItemTo, 0, len(r.Spec.To))
	for _, toItem := range r.Spec.To {
		var defaultVar *shared.MeshRetryItemDefault
		if toItem.Default != nil {
			var grpc *shared.MeshRetryItemGrpc
			if toItem.Default.Grpc != nil {
				var backOff *shared.BackOff
				if toItem.Default.Grpc.BackOff != nil {
					baseInterval := new(string)
					if !toItem.Default.Grpc.BackOff.BaseInterval.IsUnknown() && !toItem.Default.Grpc.BackOff.BaseInterval.IsNull() {
						*baseInterval = toItem.Default.Grpc.BackOff.BaseInterval.ValueString()
					} else {
						baseInterval = nil
					}
					maxInterval := new(string)
					if !toItem.Default.Grpc.BackOff.MaxInterval.IsUnknown() && !toItem.Default.Grpc.BackOff.MaxInterval.IsNull() {
						*maxInterval = toItem.Default.Grpc.BackOff.MaxInterval.ValueString()
					} else {
						maxInterval = nil
					}
					backOff = &shared.BackOff{
						BaseInterval: baseInterval,
						MaxInterval:  maxInterval,
					}
				}
				numRetries := new(int)
				if !toItem.Default.Grpc.NumRetries.IsUnknown() && !toItem.Default.Grpc.NumRetries.IsNull() {
					*numRetries = int(toItem.Default.Grpc.NumRetries.ValueInt32())
				} else {
					numRetries = nil
				}
				perTryTimeout := new(string)
				if !toItem.Default.Grpc.PerTryTimeout.IsUnknown() && !toItem.Default.Grpc.PerTryTimeout.IsNull() {
					*perTryTimeout = toItem.Default.Grpc.PerTryTimeout.ValueString()
				} else {
					perTryTimeout = nil
				}
				var rateLimitedBackOff *shared.RateLimitedBackOff
				if toItem.Default.Grpc.RateLimitedBackOff != nil {
					maxInterval1 := new(string)
					if !toItem.Default.Grpc.RateLimitedBackOff.MaxInterval.IsUnknown() && !toItem.Default.Grpc.RateLimitedBackOff.MaxInterval.IsNull() {
						*maxInterval1 = toItem.Default.Grpc.RateLimitedBackOff.MaxInterval.ValueString()
					} else {
						maxInterval1 = nil
					}
					resetHeaders := make([]shared.ResetHeaders, 0, len(toItem.Default.Grpc.RateLimitedBackOff.ResetHeaders))
					for _, resetHeadersItem := range toItem.Default.Grpc.RateLimitedBackOff.ResetHeaders {
						format := shared.MeshRetryItemFormat(resetHeadersItem.Format.ValueString())
						var name2 string
						name2 = resetHeadersItem.Name.ValueString()

						resetHeaders = append(resetHeaders, shared.ResetHeaders{
							Format: format,
							Name:   name2,
						})
					}
					rateLimitedBackOff = &shared.RateLimitedBackOff{
						MaxInterval:  maxInterval1,
						ResetHeaders: resetHeaders,
					}
				}
				retryOn := make([]shared.RetryOn, 0, len(toItem.Default.Grpc.RetryOn))
				for _, retryOnItem := range toItem.Default.Grpc.RetryOn {
					retryOn = append(retryOn, shared.RetryOn(retryOnItem.ValueString()))
				}
				grpc = &shared.MeshRetryItemGrpc{
					BackOff:            backOff,
					NumRetries:         numRetries,
					PerTryTimeout:      perTryTimeout,
					RateLimitedBackOff: rateLimitedBackOff,
					RetryOn:            retryOn,
				}
			}
			var http *shared.MeshRetryItemHTTP
			if toItem.Default.HTTP != nil {
				var backOff1 *shared.MeshRetryItemBackOff
				if toItem.Default.HTTP.BackOff != nil {
					baseInterval1 := new(string)
					if !toItem.Default.HTTP.BackOff.BaseInterval.IsUnknown() && !toItem.Default.HTTP.BackOff.BaseInterval.IsNull() {
						*baseInterval1 = toItem.Default.HTTP.BackOff.BaseInterval.ValueString()
					} else {
						baseInterval1 = nil
					}
					maxInterval2 := new(string)
					if !toItem.Default.HTTP.BackOff.MaxInterval.IsUnknown() && !toItem.Default.HTTP.BackOff.MaxInterval.IsNull() {
						*maxInterval2 = toItem.Default.HTTP.BackOff.MaxInterval.ValueString()
					} else {
						maxInterval2 = nil
					}
					backOff1 = &shared.MeshRetryItemBackOff{
						BaseInterval: baseInterval1,
						MaxInterval:  maxInterval2,
					}
				}
				hostSelection := make([]shared.HostSelection, 0, len(toItem.Default.HTTP.HostSelection))
				for _, hostSelectionItem := range toItem.Default.HTTP.HostSelection {
					predicate := shared.Predicate(hostSelectionItem.Predicate.ValueString())
					tags1 := make(map[string]string)
					for tagsKey1, tagsValue1 := range hostSelectionItem.Tags {
						var tagsInst1 string
						tagsInst1 = tagsValue1.ValueString()

						tags1[tagsKey1] = tagsInst1
					}
					updateFrequency := new(int)
					if !hostSelectionItem.UpdateFrequency.IsUnknown() && !hostSelectionItem.UpdateFrequency.IsNull() {
						*updateFrequency = int(hostSelectionItem.UpdateFrequency.ValueInt32())
					} else {
						updateFrequency = nil
					}
					hostSelection = append(hostSelection, shared.HostSelection{
						Predicate:       predicate,
						Tags:            tags1,
						UpdateFrequency: updateFrequency,
					})
				}
				hostSelectionMaxAttempts := new(int64)
				if !toItem.Default.HTTP.HostSelectionMaxAttempts.IsUnknown() && !toItem.Default.HTTP.HostSelectionMaxAttempts.IsNull() {
					*hostSelectionMaxAttempts = toItem.Default.HTTP.HostSelectionMaxAttempts.ValueInt64()
				} else {
					hostSelectionMaxAttempts = nil
				}
				numRetries1 := new(int)
				if !toItem.Default.HTTP.NumRetries.IsUnknown() && !toItem.Default.HTTP.NumRetries.IsNull() {
					*numRetries1 = int(toItem.Default.HTTP.NumRetries.ValueInt32())
				} else {
					numRetries1 = nil
				}
				perTryTimeout1 := new(string)
				if !toItem.Default.HTTP.PerTryTimeout.IsUnknown() && !toItem.Default.HTTP.PerTryTimeout.IsNull() {
					*perTryTimeout1 = toItem.Default.HTTP.PerTryTimeout.ValueString()
				} else {
					perTryTimeout1 = nil
				}
				var rateLimitedBackOff1 *shared.MeshRetryItemRateLimitedBackOff
				if toItem.Default.HTTP.RateLimitedBackOff != nil {
					maxInterval3 := new(string)
					if !toItem.Default.HTTP.RateLimitedBackOff.MaxInterval.IsUnknown() && !toItem.Default.HTTP.RateLimitedBackOff.MaxInterval.IsNull() {
						*maxInterval3 = toItem.Default.HTTP.RateLimitedBackOff.MaxInterval.ValueString()
					} else {
						maxInterval3 = nil
					}
					resetHeaders1 := make([]shared.MeshRetryItemResetHeaders, 0, len(toItem.Default.HTTP.RateLimitedBackOff.ResetHeaders))
					for _, resetHeadersItem1 := range toItem.Default.HTTP.RateLimitedBackOff.ResetHeaders {
						format1 := shared.MeshRetryItemSpecFormat(resetHeadersItem1.Format.ValueString())
						var name3 string
						name3 = resetHeadersItem1.Name.ValueString()

						resetHeaders1 = append(resetHeaders1, shared.MeshRetryItemResetHeaders{
							Format: format1,
							Name:   name3,
						})
					}
					rateLimitedBackOff1 = &shared.MeshRetryItemRateLimitedBackOff{
						MaxInterval:  maxInterval3,
						ResetHeaders: resetHeaders1,
					}
				}
				retriableRequestHeaders := make([]shared.RetriableRequestHeaders, 0, len(toItem.Default.HTTP.RetriableRequestHeaders))
				for _, retriableRequestHeadersItem := range toItem.Default.HTTP.RetriableRequestHeaders {
					var name4 string
					name4 = retriableRequestHeadersItem.Name.ValueString()

					type1 := new(shared.MeshRetryItemSpecType)
					if !retriableRequestHeadersItem.Type.IsUnknown() && !retriableRequestHeadersItem.Type.IsNull() {
						*type1 = shared.MeshRetryItemSpecType(retriableRequestHeadersItem.Type.ValueString())
					} else {
						type1 = nil
					}
					value := new(string)
					if !retriableRequestHeadersItem.Value.IsUnknown() && !retriableRequestHeadersItem.Value.IsNull() {
						*value = retriableRequestHeadersItem.Value.ValueString()
					} else {
						value = nil
					}
					retriableRequestHeaders = append(retriableRequestHeaders, shared.RetriableRequestHeaders{
						Name:  name4,
						Type:  type1,
						Value: value,
					})
				}
				retriableResponseHeaders := make([]shared.RetriableResponseHeaders, 0, len(toItem.Default.HTTP.RetriableResponseHeaders))
				for _, retriableResponseHeadersItem := range toItem.Default.HTTP.RetriableResponseHeaders {
					var name5 string
					name5 = retriableResponseHeadersItem.Name.ValueString()

					type2 := new(shared.MeshRetryItemSpecToType)
					if !retriableResponseHeadersItem.Type.IsUnknown() && !retriableResponseHeadersItem.Type.IsNull() {
						*type2 = shared.MeshRetryItemSpecToType(retriableResponseHeadersItem.Type.ValueString())
					} else {
						type2 = nil
					}
					value1 := new(string)
					if !retriableResponseHeadersItem.Value.IsUnknown() && !retriableResponseHeadersItem.Value.IsNull() {
						*value1 = retriableResponseHeadersItem.Value.ValueString()
					} else {
						value1 = nil
					}
					retriableResponseHeaders = append(retriableResponseHeaders, shared.RetriableResponseHeaders{
						Name:  name5,
						Type:  type2,
						Value: value1,
					})
				}
				retryOn1 := make([]string, 0, len(toItem.Default.HTTP.RetryOn))
				for _, retryOnItem1 := range toItem.Default.HTTP.RetryOn {
					retryOn1 = append(retryOn1, retryOnItem1.ValueString())
				}
				http = &shared.MeshRetryItemHTTP{
					BackOff:                  backOff1,
					HostSelection:            hostSelection,
					HostSelectionMaxAttempts: hostSelectionMaxAttempts,
					NumRetries:               numRetries1,
					PerTryTimeout:            perTryTimeout1,
					RateLimitedBackOff:       rateLimitedBackOff1,
					RetriableRequestHeaders:  retriableRequestHeaders,
					RetriableResponseHeaders: retriableResponseHeaders,
					RetryOn:                  retryOn1,
				}
			}
			var tcp *shared.MeshRetryItemTCP
			if toItem.Default.TCP != nil {
				maxConnectAttempt := new(int)
				if !toItem.Default.TCP.MaxConnectAttempt.IsUnknown() && !toItem.Default.TCP.MaxConnectAttempt.IsNull() {
					*maxConnectAttempt = int(toItem.Default.TCP.MaxConnectAttempt.ValueInt32())
				} else {
					maxConnectAttempt = nil
				}
				tcp = &shared.MeshRetryItemTCP{
					MaxConnectAttempt: maxConnectAttempt,
				}
			}
			defaultVar = &shared.MeshRetryItemDefault{
				Grpc: grpc,
				HTTP: http,
				TCP:  tcp,
			}
		}
		kind1 := shared.MeshRetryItemSpecKind(toItem.TargetRef.Kind.ValueString())
		labels2 := make(map[string]string)
		for labelsKey2, labelsValue2 := range toItem.TargetRef.Labels {
			var labelsInst2 string
			labelsInst2 = labelsValue2.ValueString()

			labels2[labelsKey2] = labelsInst2
		}
		mesh2 := new(string)
		if !toItem.TargetRef.Mesh.IsUnknown() && !toItem.TargetRef.Mesh.IsNull() {
			*mesh2 = toItem.TargetRef.Mesh.ValueString()
		} else {
			mesh2 = nil
		}
		name6 := new(string)
		if !toItem.TargetRef.Name.IsUnknown() && !toItem.TargetRef.Name.IsNull() {
			*name6 = toItem.TargetRef.Name.ValueString()
		} else {
			name6 = nil
		}
		namespace1 := new(string)
		if !toItem.TargetRef.Namespace.IsUnknown() && !toItem.TargetRef.Namespace.IsNull() {
			*namespace1 = toItem.TargetRef.Namespace.ValueString()
		} else {
			namespace1 = nil
		}
		proxyTypes1 := make([]shared.MeshRetryItemSpecProxyTypes, 0, len(toItem.TargetRef.ProxyTypes))
		for _, proxyTypesItem1 := range toItem.TargetRef.ProxyTypes {
			proxyTypes1 = append(proxyTypes1, shared.MeshRetryItemSpecProxyTypes(proxyTypesItem1.ValueString()))
		}
		sectionName1 := new(string)
		if !toItem.TargetRef.SectionName.IsUnknown() && !toItem.TargetRef.SectionName.IsNull() {
			*sectionName1 = toItem.TargetRef.SectionName.ValueString()
		} else {
			sectionName1 = nil
		}
		tags2 := make(map[string]string)
		for tagsKey2, tagsValue2 := range toItem.TargetRef.Tags {
			var tagsInst2 string
			tagsInst2 = tagsValue2.ValueString()

			tags2[tagsKey2] = tagsInst2
		}
		targetRef1 := shared.MeshRetryItemSpecTargetRef{
			Kind:        kind1,
			Labels:      labels2,
			Mesh:        mesh2,
			Name:        name6,
			Namespace:   namespace1,
			ProxyTypes:  proxyTypes1,
			SectionName: sectionName1,
			Tags:        tags2,
		}
		to = append(to, shared.MeshRetryItemTo{
			Default:   defaultVar,
			TargetRef: targetRef1,
		})
	}
	spec := shared.MeshRetryItemSpec{
		TargetRef: targetRef,
		To:        to,
	}
	out := shared.MeshRetryItemInput{
		Type:   typeVar,
		Mesh:   mesh,
		Name:   name,
		Labels: labels,
		Spec:   spec,
	}

	return &out, diags
}

func (r *MeshRetryResourceModel) ToOperationsCreateMeshRetryRequest(ctx context.Context) (*operations.CreateMeshRetryRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var mesh string
	mesh = r.Mesh.ValueString()

	var name string
	name = r.Name.ValueString()

	meshRetryItem, meshRetryItemDiags := r.ToSharedMeshRetryItemInput(ctx)
	diags.Append(meshRetryItemDiags...)

	if diags.HasError() {
		return nil, diags
	}

	out := operations.CreateMeshRetryRequest{
		Mesh:          mesh,
		Name:          name,
		MeshRetryItem: *meshRetryItem,
	}

	return &out, diags
}

func (r *MeshRetryResourceModel) ToOperationsUpdateMeshRetryRequest(ctx context.Context) (*operations.UpdateMeshRetryRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var mesh string
	mesh = r.Mesh.ValueString()

	var name string
	name = r.Name.ValueString()

	meshRetryItem, meshRetryItemDiags := r.ToSharedMeshRetryItemInput(ctx)
	diags.Append(meshRetryItemDiags...)

	if diags.HasError() {
		return nil, diags
	}

	out := operations.UpdateMeshRetryRequest{
		Mesh:          mesh,
		Name:          name,
		MeshRetryItem: *meshRetryItem,
	}

	return &out, diags
}

func (r *MeshRetryResourceModel) ToOperationsGetMeshRetryRequest(ctx context.Context) (*operations.GetMeshRetryRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var mesh string
	mesh = r.Mesh.ValueString()

	var name string
	name = r.Name.ValueString()

	out := operations.GetMeshRetryRequest{
		Mesh: mesh,
		Name: name,
	}

	return &out, diags
}

func (r *MeshRetryResourceModel) ToOperationsDeleteMeshRetryRequest(ctx context.Context) (*operations.DeleteMeshRetryRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var mesh string
	mesh = r.Mesh.ValueString()

	var name string
	name = r.Name.ValueString()

	out := operations.DeleteMeshRetryRequest{
		Mesh: mesh,
		Name: name,
	}

	return &out, diags
}

func (r *MeshRetryResourceModel) RefreshFromSharedMeshRetryCreateOrUpdateSuccessResponse(ctx context.Context, resp *shared.MeshRetryCreateOrUpdateSuccessResponse) diag.Diagnostics {
	var diags diag.Diagnostics

	if resp != nil {
		r.Warnings = make([]types.String, 0, len(resp.Warnings))
		for _, v := range resp.Warnings {
			r.Warnings = append(r.Warnings, types.StringValue(v))
		}
	}

	return diags
}

func (r *MeshRetryResourceModel) RefreshFromSharedMeshRetryItem(ctx context.Context, resp *shared.MeshRetryItem) diag.Diagnostics {
	var diags diag.Diagnostics

	if resp != nil {
		r.CreationTime = types.StringPointerValue(typeconvert.TimePointerToStringPointer(resp.CreationTime))
		if len(resp.Labels) > 0 {
			r.Labels = make(map[string]types.String, len(resp.Labels))
			for key, value := range resp.Labels {
				r.Labels[key] = types.StringValue(value)
			}
		}
		r.Mesh = types.StringPointerValue(resp.Mesh)
		r.ModificationTime = types.StringPointerValue(typeconvert.TimePointerToStringPointer(resp.ModificationTime))
		r.Name = types.StringValue(resp.Name)
		if resp.Spec.TargetRef == nil {
			r.Spec.TargetRef = nil
		} else {
			r.Spec.TargetRef = &tfTypes.MeshAccessLogItemTargetRef{}
			r.Spec.TargetRef.Kind = types.StringValue(string(resp.Spec.TargetRef.Kind))
			if len(resp.Spec.TargetRef.Labels) > 0 {
				r.Spec.TargetRef.Labels = make(map[string]types.String, len(resp.Spec.TargetRef.Labels))
				for key1, value1 := range resp.Spec.TargetRef.Labels {
					r.Spec.TargetRef.Labels[key1] = types.StringValue(value1)
				}
			}
			r.Spec.TargetRef.Mesh = types.StringPointerValue(resp.Spec.TargetRef.Mesh)
			r.Spec.TargetRef.Name = types.StringPointerValue(resp.Spec.TargetRef.Name)
			r.Spec.TargetRef.Namespace = types.StringPointerValue(resp.Spec.TargetRef.Namespace)
			r.Spec.TargetRef.ProxyTypes = make([]types.String, 0, len(resp.Spec.TargetRef.ProxyTypes))
			for _, v := range resp.Spec.TargetRef.ProxyTypes {
				r.Spec.TargetRef.ProxyTypes = append(r.Spec.TargetRef.ProxyTypes, types.StringValue(string(v)))
			}
			r.Spec.TargetRef.SectionName = types.StringPointerValue(resp.Spec.TargetRef.SectionName)
			if len(resp.Spec.TargetRef.Tags) > 0 {
				r.Spec.TargetRef.Tags = make(map[string]types.String, len(resp.Spec.TargetRef.Tags))
				for key2, value2 := range resp.Spec.TargetRef.Tags {
					r.Spec.TargetRef.Tags[key2] = types.StringValue(value2)
				}
			}
		}
		r.Spec.To = []tfTypes.MeshRetryItemTo{}
		if len(r.Spec.To) > len(resp.Spec.To) {
			r.Spec.To = r.Spec.To[:len(resp.Spec.To)]
		}
		for toCount, toItem := range resp.Spec.To {
			var to tfTypes.MeshRetryItemTo
			if toItem.Default == nil {
				to.Default = nil
			} else {
				to.Default = &tfTypes.MeshRetryItemDefault{}
				if toItem.Default.Grpc == nil {
					to.Default.Grpc = nil
				} else {
					to.Default.Grpc = &tfTypes.MeshRetryItemGrpc{}
					if toItem.Default.Grpc.BackOff == nil {
						to.Default.Grpc.BackOff = nil
					} else {
						to.Default.Grpc.BackOff = &tfTypes.BackOff{}
						to.Default.Grpc.BackOff.BaseInterval = types.StringPointerValue(toItem.Default.Grpc.BackOff.BaseInterval)
						to.Default.Grpc.BackOff.MaxInterval = types.StringPointerValue(toItem.Default.Grpc.BackOff.MaxInterval)
					}
					to.Default.Grpc.NumRetries = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(toItem.Default.Grpc.NumRetries))
					to.Default.Grpc.PerTryTimeout = types.StringPointerValue(toItem.Default.Grpc.PerTryTimeout)
					if toItem.Default.Grpc.RateLimitedBackOff == nil {
						to.Default.Grpc.RateLimitedBackOff = nil
					} else {
						to.Default.Grpc.RateLimitedBackOff = &tfTypes.RateLimitedBackOff{}
						to.Default.Grpc.RateLimitedBackOff.MaxInterval = types.StringPointerValue(toItem.Default.Grpc.RateLimitedBackOff.MaxInterval)
						to.Default.Grpc.RateLimitedBackOff.ResetHeaders = []tfTypes.ResetHeaders{}
						for resetHeadersCount, resetHeadersItem := range toItem.Default.Grpc.RateLimitedBackOff.ResetHeaders {
							var resetHeaders tfTypes.ResetHeaders
							resetHeaders.Format = types.StringValue(string(resetHeadersItem.Format))
							resetHeaders.Name = types.StringValue(resetHeadersItem.Name)
							if resetHeadersCount+1 > len(to.Default.Grpc.RateLimitedBackOff.ResetHeaders) {
								to.Default.Grpc.RateLimitedBackOff.ResetHeaders = append(to.Default.Grpc.RateLimitedBackOff.ResetHeaders, resetHeaders)
							} else {
								to.Default.Grpc.RateLimitedBackOff.ResetHeaders[resetHeadersCount].Format = resetHeaders.Format
								to.Default.Grpc.RateLimitedBackOff.ResetHeaders[resetHeadersCount].Name = resetHeaders.Name
							}
						}
					}
					to.Default.Grpc.RetryOn = make([]types.String, 0, len(toItem.Default.Grpc.RetryOn))
					for _, v := range toItem.Default.Grpc.RetryOn {
						to.Default.Grpc.RetryOn = append(to.Default.Grpc.RetryOn, types.StringValue(string(v)))
					}
				}
				if toItem.Default.HTTP == nil {
					to.Default.HTTP = nil
				} else {
					to.Default.HTTP = &tfTypes.MeshRetryItemHTTP{}
					if toItem.Default.HTTP.BackOff == nil {
						to.Default.HTTP.BackOff = nil
					} else {
						to.Default.HTTP.BackOff = &tfTypes.BackOff{}
						to.Default.HTTP.BackOff.BaseInterval = types.StringPointerValue(toItem.Default.HTTP.BackOff.BaseInterval)
						to.Default.HTTP.BackOff.MaxInterval = types.StringPointerValue(toItem.Default.HTTP.BackOff.MaxInterval)
					}
					to.Default.HTTP.HostSelection = []tfTypes.HostSelection{}
					for hostSelectionCount, hostSelectionItem := range toItem.Default.HTTP.HostSelection {
						var hostSelection tfTypes.HostSelection
						hostSelection.Predicate = types.StringValue(string(hostSelectionItem.Predicate))
						if len(hostSelectionItem.Tags) > 0 {
							hostSelection.Tags = make(map[string]types.String, len(hostSelectionItem.Tags))
							for key3, value3 := range hostSelectionItem.Tags {
								hostSelection.Tags[key3] = types.StringValue(value3)
							}
						}
						hostSelection.UpdateFrequency = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(hostSelectionItem.UpdateFrequency))
						if hostSelectionCount+1 > len(to.Default.HTTP.HostSelection) {
							to.Default.HTTP.HostSelection = append(to.Default.HTTP.HostSelection, hostSelection)
						} else {
							to.Default.HTTP.HostSelection[hostSelectionCount].Predicate = hostSelection.Predicate
							to.Default.HTTP.HostSelection[hostSelectionCount].Tags = hostSelection.Tags
							to.Default.HTTP.HostSelection[hostSelectionCount].UpdateFrequency = hostSelection.UpdateFrequency
						}
					}
					to.Default.HTTP.HostSelectionMaxAttempts = types.Int64PointerValue(toItem.Default.HTTP.HostSelectionMaxAttempts)
					to.Default.HTTP.NumRetries = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(toItem.Default.HTTP.NumRetries))
					to.Default.HTTP.PerTryTimeout = types.StringPointerValue(toItem.Default.HTTP.PerTryTimeout)
					if toItem.Default.HTTP.RateLimitedBackOff == nil {
						to.Default.HTTP.RateLimitedBackOff = nil
					} else {
						to.Default.HTTP.RateLimitedBackOff = &tfTypes.RateLimitedBackOff{}
						to.Default.HTTP.RateLimitedBackOff.MaxInterval = types.StringPointerValue(toItem.Default.HTTP.RateLimitedBackOff.MaxInterval)
						to.Default.HTTP.RateLimitedBackOff.ResetHeaders = []tfTypes.ResetHeaders{}
						for resetHeadersCount1, resetHeadersItem1 := range toItem.Default.HTTP.RateLimitedBackOff.ResetHeaders {
							var resetHeaders1 tfTypes.ResetHeaders
							resetHeaders1.Format = types.StringValue(string(resetHeadersItem1.Format))
							resetHeaders1.Name = types.StringValue(resetHeadersItem1.Name)
							if resetHeadersCount1+1 > len(to.Default.HTTP.RateLimitedBackOff.ResetHeaders) {
								to.Default.HTTP.RateLimitedBackOff.ResetHeaders = append(to.Default.HTTP.RateLimitedBackOff.ResetHeaders, resetHeaders1)
							} else {
								to.Default.HTTP.RateLimitedBackOff.ResetHeaders[resetHeadersCount1].Format = resetHeaders1.Format
								to.Default.HTTP.RateLimitedBackOff.ResetHeaders[resetHeadersCount1].Name = resetHeaders1.Name
							}
						}
					}
					to.Default.HTTP.RetriableRequestHeaders = []tfTypes.Headers{}
					for retriableRequestHeadersCount, retriableRequestHeadersItem := range toItem.Default.HTTP.RetriableRequestHeaders {
						var retriableRequestHeaders tfTypes.Headers
						retriableRequestHeaders.Name = types.StringValue(retriableRequestHeadersItem.Name)
						if retriableRequestHeadersItem.Type != nil {
							retriableRequestHeaders.Type = types.StringValue(string(*retriableRequestHeadersItem.Type))
						} else {
							retriableRequestHeaders.Type = types.StringNull()
						}
						retriableRequestHeaders.Value = types.StringPointerValue(retriableRequestHeadersItem.Value)
						if retriableRequestHeadersCount+1 > len(to.Default.HTTP.RetriableRequestHeaders) {
							to.Default.HTTP.RetriableRequestHeaders = append(to.Default.HTTP.RetriableRequestHeaders, retriableRequestHeaders)
						} else {
							to.Default.HTTP.RetriableRequestHeaders[retriableRequestHeadersCount].Name = retriableRequestHeaders.Name
							to.Default.HTTP.RetriableRequestHeaders[retriableRequestHeadersCount].Type = retriableRequestHeaders.Type
							to.Default.HTTP.RetriableRequestHeaders[retriableRequestHeadersCount].Value = retriableRequestHeaders.Value
						}
					}
					to.Default.HTTP.RetriableResponseHeaders = []tfTypes.Headers{}
					for retriableResponseHeadersCount, retriableResponseHeadersItem := range toItem.Default.HTTP.RetriableResponseHeaders {
						var retriableResponseHeaders tfTypes.Headers
						retriableResponseHeaders.Name = types.StringValue(retriableResponseHeadersItem.Name)
						if retriableResponseHeadersItem.Type != nil {
							retriableResponseHeaders.Type = types.StringValue(string(*retriableResponseHeadersItem.Type))
						} else {
							retriableResponseHeaders.Type = types.StringNull()
						}
						retriableResponseHeaders.Value = types.StringPointerValue(retriableResponseHeadersItem.Value)
						if retriableResponseHeadersCount+1 > len(to.Default.HTTP.RetriableResponseHeaders) {
							to.Default.HTTP.RetriableResponseHeaders = append(to.Default.HTTP.RetriableResponseHeaders, retriableResponseHeaders)
						} else {
							to.Default.HTTP.RetriableResponseHeaders[retriableResponseHeadersCount].Name = retriableResponseHeaders.Name
							to.Default.HTTP.RetriableResponseHeaders[retriableResponseHeadersCount].Type = retriableResponseHeaders.Type
							to.Default.HTTP.RetriableResponseHeaders[retriableResponseHeadersCount].Value = retriableResponseHeaders.Value
						}
					}
					to.Default.HTTP.RetryOn = make([]types.String, 0, len(toItem.Default.HTTP.RetryOn))
					for _, v := range toItem.Default.HTTP.RetryOn {
						to.Default.HTTP.RetryOn = append(to.Default.HTTP.RetryOn, types.StringValue(v))
					}
				}
				if toItem.Default.TCP == nil {
					to.Default.TCP = nil
				} else {
					to.Default.TCP = &tfTypes.MeshRetryItemTCP{}
					to.Default.TCP.MaxConnectAttempt = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(toItem.Default.TCP.MaxConnectAttempt))
				}
			}
			to.TargetRef.Kind = types.StringValue(string(toItem.TargetRef.Kind))
			if len(toItem.TargetRef.Labels) > 0 {
				to.TargetRef.Labels = make(map[string]types.String, len(toItem.TargetRef.Labels))
				for key4, value4 := range toItem.TargetRef.Labels {
					to.TargetRef.Labels[key4] = types.StringValue(value4)
				}
			}
			to.TargetRef.Mesh = types.StringPointerValue(toItem.TargetRef.Mesh)
			to.TargetRef.Name = types.StringPointerValue(toItem.TargetRef.Name)
			to.TargetRef.Namespace = types.StringPointerValue(toItem.TargetRef.Namespace)
			to.TargetRef.ProxyTypes = make([]types.String, 0, len(toItem.TargetRef.ProxyTypes))
			for _, v := range toItem.TargetRef.ProxyTypes {
				to.TargetRef.ProxyTypes = append(to.TargetRef.ProxyTypes, types.StringValue(string(v)))
			}
			to.TargetRef.SectionName = types.StringPointerValue(toItem.TargetRef.SectionName)
			if len(toItem.TargetRef.Tags) > 0 {
				to.TargetRef.Tags = make(map[string]types.String, len(toItem.TargetRef.Tags))
				for key5, value5 := range toItem.TargetRef.Tags {
					to.TargetRef.Tags[key5] = types.StringValue(value5)
				}
			}
			if toCount+1 > len(r.Spec.To) {
				r.Spec.To = append(r.Spec.To, to)
			} else {
				r.Spec.To[toCount].Default = to.Default
				r.Spec.To[toCount].TargetRef = to.TargetRef
			}
		}
		r.Type = types.StringValue(string(resp.Type))
	}

	return diags
}
