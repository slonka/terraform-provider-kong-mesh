// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package provider

import (
	"context"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/kong/terraform-provider-kong-mesh/internal/provider/typeconvert"
	tfTypes "github.com/kong/terraform-provider-kong-mesh/internal/provider/types"
	"github.com/kong/terraform-provider-kong-mesh/internal/sdk/models/operations"
	"github.com/kong/terraform-provider-kong-mesh/internal/sdk/models/shared"
)

func (r *MeshHTTPRouteResourceModel) ToSharedMeshHTTPRouteItemInput(ctx context.Context) (*shared.MeshHTTPRouteItemInput, diag.Diagnostics) {
	var diags diag.Diagnostics

	typeVar := shared.MeshHTTPRouteItemType(r.Type.ValueString())
	mesh := new(string)
	if !r.Mesh.IsUnknown() && !r.Mesh.IsNull() {
		*mesh = r.Mesh.ValueString()
	} else {
		mesh = nil
	}
	var name string
	name = r.Name.ValueString()

	labels := make(map[string]string)
	for labelsKey, labelsValue := range r.Labels {
		var labelsInst string
		labelsInst = labelsValue.ValueString()

		labels[labelsKey] = labelsInst
	}
	var targetRef *shared.MeshHTTPRouteItemTargetRef
	if r.Spec.TargetRef != nil {
		kind := shared.MeshHTTPRouteItemKind(r.Spec.TargetRef.Kind.ValueString())
		labels1 := make(map[string]string)
		for labelsKey1, labelsValue1 := range r.Spec.TargetRef.Labels {
			var labelsInst1 string
			labelsInst1 = labelsValue1.ValueString()

			labels1[labelsKey1] = labelsInst1
		}
		mesh1 := new(string)
		if !r.Spec.TargetRef.Mesh.IsUnknown() && !r.Spec.TargetRef.Mesh.IsNull() {
			*mesh1 = r.Spec.TargetRef.Mesh.ValueString()
		} else {
			mesh1 = nil
		}
		name1 := new(string)
		if !r.Spec.TargetRef.Name.IsUnknown() && !r.Spec.TargetRef.Name.IsNull() {
			*name1 = r.Spec.TargetRef.Name.ValueString()
		} else {
			name1 = nil
		}
		namespace := new(string)
		if !r.Spec.TargetRef.Namespace.IsUnknown() && !r.Spec.TargetRef.Namespace.IsNull() {
			*namespace = r.Spec.TargetRef.Namespace.ValueString()
		} else {
			namespace = nil
		}
		proxyTypes := make([]shared.MeshHTTPRouteItemProxyTypes, 0, len(r.Spec.TargetRef.ProxyTypes))
		for _, proxyTypesItem := range r.Spec.TargetRef.ProxyTypes {
			proxyTypes = append(proxyTypes, shared.MeshHTTPRouteItemProxyTypes(proxyTypesItem.ValueString()))
		}
		sectionName := new(string)
		if !r.Spec.TargetRef.SectionName.IsUnknown() && !r.Spec.TargetRef.SectionName.IsNull() {
			*sectionName = r.Spec.TargetRef.SectionName.ValueString()
		} else {
			sectionName = nil
		}
		tags := make(map[string]string)
		for tagsKey, tagsValue := range r.Spec.TargetRef.Tags {
			var tagsInst string
			tagsInst = tagsValue.ValueString()

			tags[tagsKey] = tagsInst
		}
		targetRef = &shared.MeshHTTPRouteItemTargetRef{
			Kind:        kind,
			Labels:      labels1,
			Mesh:        mesh1,
			Name:        name1,
			Namespace:   namespace,
			ProxyTypes:  proxyTypes,
			SectionName: sectionName,
			Tags:        tags,
		}
	}
	to := make([]shared.MeshHTTPRouteItemTo, 0, len(r.Spec.To))
	for _, toItem := range r.Spec.To {
		hostnames := make([]string, 0, len(toItem.Hostnames))
		for _, hostnamesItem := range toItem.Hostnames {
			hostnames = append(hostnames, hostnamesItem.ValueString())
		}
		rules := make([]shared.MeshHTTPRouteItemRules, 0, len(toItem.Rules))
		for _, rulesItem := range toItem.Rules {
			backendRefs := make([]shared.BackendRefs, 0, len(rulesItem.Default.BackendRefs))
			for _, backendRefsItem := range rulesItem.Default.BackendRefs {
				kind1 := shared.MeshHTTPRouteItemSpecToKind(backendRefsItem.Kind.ValueString())
				labels2 := make(map[string]string)
				for labelsKey2, labelsValue2 := range backendRefsItem.Labels {
					var labelsInst2 string
					labelsInst2 = labelsValue2.ValueString()

					labels2[labelsKey2] = labelsInst2
				}
				mesh2 := new(string)
				if !backendRefsItem.Mesh.IsUnknown() && !backendRefsItem.Mesh.IsNull() {
					*mesh2 = backendRefsItem.Mesh.ValueString()
				} else {
					mesh2 = nil
				}
				name2 := new(string)
				if !backendRefsItem.Name.IsUnknown() && !backendRefsItem.Name.IsNull() {
					*name2 = backendRefsItem.Name.ValueString()
				} else {
					name2 = nil
				}
				namespace1 := new(string)
				if !backendRefsItem.Namespace.IsUnknown() && !backendRefsItem.Namespace.IsNull() {
					*namespace1 = backendRefsItem.Namespace.ValueString()
				} else {
					namespace1 = nil
				}
				port := new(int)
				if !backendRefsItem.Port.IsUnknown() && !backendRefsItem.Port.IsNull() {
					*port = int(backendRefsItem.Port.ValueInt32())
				} else {
					port = nil
				}
				proxyTypes1 := make([]shared.MeshHTTPRouteItemSpecToProxyTypes, 0, len(backendRefsItem.ProxyTypes))
				for _, proxyTypesItem1 := range backendRefsItem.ProxyTypes {
					proxyTypes1 = append(proxyTypes1, shared.MeshHTTPRouteItemSpecToProxyTypes(proxyTypesItem1.ValueString()))
				}
				sectionName1 := new(string)
				if !backendRefsItem.SectionName.IsUnknown() && !backendRefsItem.SectionName.IsNull() {
					*sectionName1 = backendRefsItem.SectionName.ValueString()
				} else {
					sectionName1 = nil
				}
				tags1 := make(map[string]string)
				for tagsKey1, tagsValue1 := range backendRefsItem.Tags {
					var tagsInst1 string
					tagsInst1 = tagsValue1.ValueString()

					tags1[tagsKey1] = tagsInst1
				}
				weight := new(int64)
				if !backendRefsItem.Weight.IsUnknown() && !backendRefsItem.Weight.IsNull() {
					*weight = backendRefsItem.Weight.ValueInt64()
				} else {
					weight = nil
				}
				backendRefs = append(backendRefs, shared.BackendRefs{
					Kind:        kind1,
					Labels:      labels2,
					Mesh:        mesh2,
					Name:        name2,
					Namespace:   namespace1,
					Port:        port,
					ProxyTypes:  proxyTypes1,
					SectionName: sectionName1,
					Tags:        tags1,
					Weight:      weight,
				})
			}
			filters := make([]shared.Filters, 0, len(rulesItem.Default.Filters))
			for _, filtersItem := range rulesItem.Default.Filters {
				var requestHeaderModifier *shared.RequestHeaderModifier
				if filtersItem.RequestHeaderModifier != nil {
					add := make([]shared.MeshHTTPRouteItemAdd, 0, len(filtersItem.RequestHeaderModifier.Add))
					for _, addItem := range filtersItem.RequestHeaderModifier.Add {
						var name3 string
						name3 = addItem.Name.ValueString()

						var value string
						value = addItem.Value.ValueString()

						add = append(add, shared.MeshHTTPRouteItemAdd{
							Name:  name3,
							Value: value,
						})
					}
					remove := make([]string, 0, len(filtersItem.RequestHeaderModifier.Remove))
					for _, removeItem := range filtersItem.RequestHeaderModifier.Remove {
						remove = append(remove, removeItem.ValueString())
					}
					set := make([]shared.MeshHTTPRouteItemSet, 0, len(filtersItem.RequestHeaderModifier.Set))
					for _, setItem := range filtersItem.RequestHeaderModifier.Set {
						var name4 string
						name4 = setItem.Name.ValueString()

						var value1 string
						value1 = setItem.Value.ValueString()

						set = append(set, shared.MeshHTTPRouteItemSet{
							Name:  name4,
							Value: value1,
						})
					}
					requestHeaderModifier = &shared.RequestHeaderModifier{
						Add:    add,
						Remove: remove,
						Set:    set,
					}
				}
				var requestMirror *shared.RequestMirror
				if filtersItem.RequestMirror != nil {
					kind2 := shared.MeshHTTPRouteItemSpecToRulesKind(filtersItem.RequestMirror.BackendRef.Kind.ValueString())
					labels3 := make(map[string]string)
					for labelsKey3, labelsValue3 := range filtersItem.RequestMirror.BackendRef.Labels {
						var labelsInst3 string
						labelsInst3 = labelsValue3.ValueString()

						labels3[labelsKey3] = labelsInst3
					}
					mesh3 := new(string)
					if !filtersItem.RequestMirror.BackendRef.Mesh.IsUnknown() && !filtersItem.RequestMirror.BackendRef.Mesh.IsNull() {
						*mesh3 = filtersItem.RequestMirror.BackendRef.Mesh.ValueString()
					} else {
						mesh3 = nil
					}
					name5 := new(string)
					if !filtersItem.RequestMirror.BackendRef.Name.IsUnknown() && !filtersItem.RequestMirror.BackendRef.Name.IsNull() {
						*name5 = filtersItem.RequestMirror.BackendRef.Name.ValueString()
					} else {
						name5 = nil
					}
					namespace2 := new(string)
					if !filtersItem.RequestMirror.BackendRef.Namespace.IsUnknown() && !filtersItem.RequestMirror.BackendRef.Namespace.IsNull() {
						*namespace2 = filtersItem.RequestMirror.BackendRef.Namespace.ValueString()
					} else {
						namespace2 = nil
					}
					port1 := new(int)
					if !filtersItem.RequestMirror.BackendRef.Port.IsUnknown() && !filtersItem.RequestMirror.BackendRef.Port.IsNull() {
						*port1 = int(filtersItem.RequestMirror.BackendRef.Port.ValueInt32())
					} else {
						port1 = nil
					}
					proxyTypes2 := make([]shared.MeshHTTPRouteItemSpecToRulesProxyTypes, 0, len(filtersItem.RequestMirror.BackendRef.ProxyTypes))
					for _, proxyTypesItem2 := range filtersItem.RequestMirror.BackendRef.ProxyTypes {
						proxyTypes2 = append(proxyTypes2, shared.MeshHTTPRouteItemSpecToRulesProxyTypes(proxyTypesItem2.ValueString()))
					}
					sectionName2 := new(string)
					if !filtersItem.RequestMirror.BackendRef.SectionName.IsUnknown() && !filtersItem.RequestMirror.BackendRef.SectionName.IsNull() {
						*sectionName2 = filtersItem.RequestMirror.BackendRef.SectionName.ValueString()
					} else {
						sectionName2 = nil
					}
					tags2 := make(map[string]string)
					for tagsKey2, tagsValue2 := range filtersItem.RequestMirror.BackendRef.Tags {
						var tagsInst2 string
						tagsInst2 = tagsValue2.ValueString()

						tags2[tagsKey2] = tagsInst2
					}
					weight1 := new(int64)
					if !filtersItem.RequestMirror.BackendRef.Weight.IsUnknown() && !filtersItem.RequestMirror.BackendRef.Weight.IsNull() {
						*weight1 = filtersItem.RequestMirror.BackendRef.Weight.ValueInt64()
					} else {
						weight1 = nil
					}
					backendRef := shared.BackendRef{
						Kind:        kind2,
						Labels:      labels3,
						Mesh:        mesh3,
						Name:        name5,
						Namespace:   namespace2,
						Port:        port1,
						ProxyTypes:  proxyTypes2,
						SectionName: sectionName2,
						Tags:        tags2,
						Weight:      weight1,
					}
					var percentage *shared.MeshHTTPRouteItemPercentage
					if filtersItem.RequestMirror.Percentage != nil {
						integer := new(int64)
						if !filtersItem.RequestMirror.Percentage.Integer.IsUnknown() && !filtersItem.RequestMirror.Percentage.Integer.IsNull() {
							*integer = filtersItem.RequestMirror.Percentage.Integer.ValueInt64()
						} else {
							integer = nil
						}
						if integer != nil {
							percentage = &shared.MeshHTTPRouteItemPercentage{
								Integer: integer,
							}
						}
						str := new(string)
						if !filtersItem.RequestMirror.Percentage.Str.IsUnknown() && !filtersItem.RequestMirror.Percentage.Str.IsNull() {
							*str = filtersItem.RequestMirror.Percentage.Str.ValueString()
						} else {
							str = nil
						}
						if str != nil {
							percentage = &shared.MeshHTTPRouteItemPercentage{
								Str: str,
							}
						}
					}
					requestMirror = &shared.RequestMirror{
						BackendRef: backendRef,
						Percentage: percentage,
					}
				}
				var requestRedirect *shared.RequestRedirect
				if filtersItem.RequestRedirect != nil {
					hostname := new(string)
					if !filtersItem.RequestRedirect.Hostname.IsUnknown() && !filtersItem.RequestRedirect.Hostname.IsNull() {
						*hostname = filtersItem.RequestRedirect.Hostname.ValueString()
					} else {
						hostname = nil
					}
					var path *shared.MeshHTTPRouteItemSpecPath
					if filtersItem.RequestRedirect.Path != nil {
						replaceFullPath := new(string)
						if !filtersItem.RequestRedirect.Path.ReplaceFullPath.IsUnknown() && !filtersItem.RequestRedirect.Path.ReplaceFullPath.IsNull() {
							*replaceFullPath = filtersItem.RequestRedirect.Path.ReplaceFullPath.ValueString()
						} else {
							replaceFullPath = nil
						}
						replacePrefixMatch := new(string)
						if !filtersItem.RequestRedirect.Path.ReplacePrefixMatch.IsUnknown() && !filtersItem.RequestRedirect.Path.ReplacePrefixMatch.IsNull() {
							*replacePrefixMatch = filtersItem.RequestRedirect.Path.ReplacePrefixMatch.ValueString()
						} else {
							replacePrefixMatch = nil
						}
						typeVar1 := shared.MeshHTTPRouteItemSpecToRulesDefaultType(filtersItem.RequestRedirect.Path.Type.ValueString())
						path = &shared.MeshHTTPRouteItemSpecPath{
							ReplaceFullPath:    replaceFullPath,
							ReplacePrefixMatch: replacePrefixMatch,
							Type:               typeVar1,
						}
					}
					port2 := new(int)
					if !filtersItem.RequestRedirect.Port.IsUnknown() && !filtersItem.RequestRedirect.Port.IsNull() {
						*port2 = int(filtersItem.RequestRedirect.Port.ValueInt32())
					} else {
						port2 = nil
					}
					scheme := new(shared.Scheme)
					if !filtersItem.RequestRedirect.Scheme.IsUnknown() && !filtersItem.RequestRedirect.Scheme.IsNull() {
						*scheme = shared.Scheme(filtersItem.RequestRedirect.Scheme.ValueString())
					} else {
						scheme = nil
					}
					statusCode := new(shared.StatusCode)
					if !filtersItem.RequestRedirect.StatusCode.IsUnknown() && !filtersItem.RequestRedirect.StatusCode.IsNull() {
						*statusCode = shared.StatusCode(filtersItem.RequestRedirect.StatusCode.ValueInt64())
					} else {
						statusCode = nil
					}
					requestRedirect = &shared.RequestRedirect{
						Hostname:   hostname,
						Path:       path,
						Port:       port2,
						Scheme:     scheme,
						StatusCode: statusCode,
					}
				}
				var responseHeaderModifier *shared.ResponseHeaderModifier
				if filtersItem.ResponseHeaderModifier != nil {
					add1 := make([]shared.MeshHTTPRouteItemSpecAdd, 0, len(filtersItem.ResponseHeaderModifier.Add))
					for _, addItem1 := range filtersItem.ResponseHeaderModifier.Add {
						var name6 string
						name6 = addItem1.Name.ValueString()

						var value2 string
						value2 = addItem1.Value.ValueString()

						add1 = append(add1, shared.MeshHTTPRouteItemSpecAdd{
							Name:  name6,
							Value: value2,
						})
					}
					remove1 := make([]string, 0, len(filtersItem.ResponseHeaderModifier.Remove))
					for _, removeItem1 := range filtersItem.ResponseHeaderModifier.Remove {
						remove1 = append(remove1, removeItem1.ValueString())
					}
					set1 := make([]shared.MeshHTTPRouteItemSpecSet, 0, len(filtersItem.ResponseHeaderModifier.Set))
					for _, setItem1 := range filtersItem.ResponseHeaderModifier.Set {
						var name7 string
						name7 = setItem1.Name.ValueString()

						var value3 string
						value3 = setItem1.Value.ValueString()

						set1 = append(set1, shared.MeshHTTPRouteItemSpecSet{
							Name:  name7,
							Value: value3,
						})
					}
					responseHeaderModifier = &shared.ResponseHeaderModifier{
						Add:    add1,
						Remove: remove1,
						Set:    set1,
					}
				}
				type1 := shared.MeshHTTPRouteItemSpecType(filtersItem.Type.ValueString())
				var urlRewrite *shared.URLRewrite
				if filtersItem.URLRewrite != nil {
					hostToBackendHostname := new(bool)
					if !filtersItem.URLRewrite.HostToBackendHostname.IsUnknown() && !filtersItem.URLRewrite.HostToBackendHostname.IsNull() {
						*hostToBackendHostname = filtersItem.URLRewrite.HostToBackendHostname.ValueBool()
					} else {
						hostToBackendHostname = nil
					}
					hostname1 := new(string)
					if !filtersItem.URLRewrite.Hostname.IsUnknown() && !filtersItem.URLRewrite.Hostname.IsNull() {
						*hostname1 = filtersItem.URLRewrite.Hostname.ValueString()
					} else {
						hostname1 = nil
					}
					var path1 *shared.MeshHTTPRouteItemPath
					if filtersItem.URLRewrite.Path != nil {
						replaceFullPath1 := new(string)
						if !filtersItem.URLRewrite.Path.ReplaceFullPath.IsUnknown() && !filtersItem.URLRewrite.Path.ReplaceFullPath.IsNull() {
							*replaceFullPath1 = filtersItem.URLRewrite.Path.ReplaceFullPath.ValueString()
						} else {
							replaceFullPath1 = nil
						}
						replacePrefixMatch1 := new(string)
						if !filtersItem.URLRewrite.Path.ReplacePrefixMatch.IsUnknown() && !filtersItem.URLRewrite.Path.ReplacePrefixMatch.IsNull() {
							*replacePrefixMatch1 = filtersItem.URLRewrite.Path.ReplacePrefixMatch.ValueString()
						} else {
							replacePrefixMatch1 = nil
						}
						typeVar2 := shared.MeshHTTPRouteItemSpecToRulesDefaultFiltersType(filtersItem.URLRewrite.Path.Type.ValueString())
						path1 = &shared.MeshHTTPRouteItemPath{
							ReplaceFullPath:    replaceFullPath1,
							ReplacePrefixMatch: replacePrefixMatch1,
							Type:               typeVar2,
						}
					}
					urlRewrite = &shared.URLRewrite{
						HostToBackendHostname: hostToBackendHostname,
						Hostname:              hostname1,
						Path:                  path1,
					}
				}
				filters = append(filters, shared.Filters{
					RequestHeaderModifier:  requestHeaderModifier,
					RequestMirror:          requestMirror,
					RequestRedirect:        requestRedirect,
					ResponseHeaderModifier: responseHeaderModifier,
					Type:                   type1,
					URLRewrite:             urlRewrite,
				})
			}
			defaultVar := shared.MeshHTTPRouteItemDefault{
				BackendRefs: backendRefs,
				Filters:     filters,
			}
			matches := make([]shared.Matches, 0, len(rulesItem.Matches))
			for _, matchesItem := range rulesItem.Matches {
				headers := make([]shared.Headers, 0, len(matchesItem.Headers))
				for _, headersItem := range matchesItem.Headers {
					var name8 string
					name8 = headersItem.Name.ValueString()

					type2 := new(shared.MeshHTTPRouteItemSpecToType)
					if !headersItem.Type.IsUnknown() && !headersItem.Type.IsNull() {
						*type2 = shared.MeshHTTPRouteItemSpecToType(headersItem.Type.ValueString())
					} else {
						type2 = nil
					}
					value4 := new(string)
					if !headersItem.Value.IsUnknown() && !headersItem.Value.IsNull() {
						*value4 = headersItem.Value.ValueString()
					} else {
						value4 = nil
					}
					headers = append(headers, shared.Headers{
						Name:  name8,
						Type:  type2,
						Value: value4,
					})
				}
				method := new(shared.Method)
				if !matchesItem.Method.IsUnknown() && !matchesItem.Method.IsNull() {
					*method = shared.Method(matchesItem.Method.ValueString())
				} else {
					method = nil
				}
				var path2 *shared.Path
				if matchesItem.Path != nil {
					typeVar3 := shared.MeshHTTPRouteItemSpecToRulesType(matchesItem.Path.Type.ValueString())
					var value5 string
					value5 = matchesItem.Path.Value.ValueString()

					path2 = &shared.Path{
						Type:  typeVar3,
						Value: value5,
					}
				}
				queryParams := make([]shared.QueryParams, 0, len(matchesItem.QueryParams))
				for _, queryParamsItem := range matchesItem.QueryParams {
					var name9 string
					name9 = queryParamsItem.Name.ValueString()

					type3 := shared.MeshHTTPRouteItemSpecToRulesMatchesType(queryParamsItem.Type.ValueString())
					var value6 string
					value6 = queryParamsItem.Value.ValueString()

					queryParams = append(queryParams, shared.QueryParams{
						Name:  name9,
						Type:  type3,
						Value: value6,
					})
				}
				matches = append(matches, shared.Matches{
					Headers:     headers,
					Method:      method,
					Path:        path2,
					QueryParams: queryParams,
				})
			}
			rules = append(rules, shared.MeshHTTPRouteItemRules{
				Default: defaultVar,
				Matches: matches,
			})
		}
		kind3 := shared.MeshHTTPRouteItemSpecKind(toItem.TargetRef.Kind.ValueString())
		labels4 := make(map[string]string)
		for labelsKey4, labelsValue4 := range toItem.TargetRef.Labels {
			var labelsInst4 string
			labelsInst4 = labelsValue4.ValueString()

			labels4[labelsKey4] = labelsInst4
		}
		mesh4 := new(string)
		if !toItem.TargetRef.Mesh.IsUnknown() && !toItem.TargetRef.Mesh.IsNull() {
			*mesh4 = toItem.TargetRef.Mesh.ValueString()
		} else {
			mesh4 = nil
		}
		name10 := new(string)
		if !toItem.TargetRef.Name.IsUnknown() && !toItem.TargetRef.Name.IsNull() {
			*name10 = toItem.TargetRef.Name.ValueString()
		} else {
			name10 = nil
		}
		namespace3 := new(string)
		if !toItem.TargetRef.Namespace.IsUnknown() && !toItem.TargetRef.Namespace.IsNull() {
			*namespace3 = toItem.TargetRef.Namespace.ValueString()
		} else {
			namespace3 = nil
		}
		proxyTypes3 := make([]shared.MeshHTTPRouteItemSpecProxyTypes, 0, len(toItem.TargetRef.ProxyTypes))
		for _, proxyTypesItem3 := range toItem.TargetRef.ProxyTypes {
			proxyTypes3 = append(proxyTypes3, shared.MeshHTTPRouteItemSpecProxyTypes(proxyTypesItem3.ValueString()))
		}
		sectionName3 := new(string)
		if !toItem.TargetRef.SectionName.IsUnknown() && !toItem.TargetRef.SectionName.IsNull() {
			*sectionName3 = toItem.TargetRef.SectionName.ValueString()
		} else {
			sectionName3 = nil
		}
		tags3 := make(map[string]string)
		for tagsKey3, tagsValue3 := range toItem.TargetRef.Tags {
			var tagsInst3 string
			tagsInst3 = tagsValue3.ValueString()

			tags3[tagsKey3] = tagsInst3
		}
		targetRef1 := shared.MeshHTTPRouteItemSpecTargetRef{
			Kind:        kind3,
			Labels:      labels4,
			Mesh:        mesh4,
			Name:        name10,
			Namespace:   namespace3,
			ProxyTypes:  proxyTypes3,
			SectionName: sectionName3,
			Tags:        tags3,
		}
		to = append(to, shared.MeshHTTPRouteItemTo{
			Hostnames: hostnames,
			Rules:     rules,
			TargetRef: targetRef1,
		})
	}
	spec := shared.MeshHTTPRouteItemSpec{
		TargetRef: targetRef,
		To:        to,
	}
	out := shared.MeshHTTPRouteItemInput{
		Type:   typeVar,
		Mesh:   mesh,
		Name:   name,
		Labels: labels,
		Spec:   spec,
	}

	return &out, diags
}

func (r *MeshHTTPRouteResourceModel) ToOperationsCreateMeshHTTPRouteRequest(ctx context.Context) (*operations.CreateMeshHTTPRouteRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var mesh string
	mesh = r.Mesh.ValueString()

	var name string
	name = r.Name.ValueString()

	meshHTTPRouteItem, meshHTTPRouteItemDiags := r.ToSharedMeshHTTPRouteItemInput(ctx)
	diags.Append(meshHTTPRouteItemDiags...)

	if diags.HasError() {
		return nil, diags
	}

	out := operations.CreateMeshHTTPRouteRequest{
		Mesh:              mesh,
		Name:              name,
		MeshHTTPRouteItem: *meshHTTPRouteItem,
	}

	return &out, diags
}

func (r *MeshHTTPRouteResourceModel) ToOperationsUpdateMeshHTTPRouteRequest(ctx context.Context) (*operations.UpdateMeshHTTPRouteRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var mesh string
	mesh = r.Mesh.ValueString()

	var name string
	name = r.Name.ValueString()

	meshHTTPRouteItem, meshHTTPRouteItemDiags := r.ToSharedMeshHTTPRouteItemInput(ctx)
	diags.Append(meshHTTPRouteItemDiags...)

	if diags.HasError() {
		return nil, diags
	}

	out := operations.UpdateMeshHTTPRouteRequest{
		Mesh:              mesh,
		Name:              name,
		MeshHTTPRouteItem: *meshHTTPRouteItem,
	}

	return &out, diags
}

func (r *MeshHTTPRouteResourceModel) ToOperationsGetMeshHTTPRouteRequest(ctx context.Context) (*operations.GetMeshHTTPRouteRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var mesh string
	mesh = r.Mesh.ValueString()

	var name string
	name = r.Name.ValueString()

	out := operations.GetMeshHTTPRouteRequest{
		Mesh: mesh,
		Name: name,
	}

	return &out, diags
}

func (r *MeshHTTPRouteResourceModel) ToOperationsDeleteMeshHTTPRouteRequest(ctx context.Context) (*operations.DeleteMeshHTTPRouteRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var mesh string
	mesh = r.Mesh.ValueString()

	var name string
	name = r.Name.ValueString()

	out := operations.DeleteMeshHTTPRouteRequest{
		Mesh: mesh,
		Name: name,
	}

	return &out, diags
}

func (r *MeshHTTPRouteResourceModel) RefreshFromSharedMeshHTTPRouteCreateOrUpdateSuccessResponse(ctx context.Context, resp *shared.MeshHTTPRouteCreateOrUpdateSuccessResponse) diag.Diagnostics {
	var diags diag.Diagnostics

	if resp != nil {
		r.Warnings = make([]types.String, 0, len(resp.Warnings))
		for _, v := range resp.Warnings {
			r.Warnings = append(r.Warnings, types.StringValue(v))
		}
	}

	return diags
}

func (r *MeshHTTPRouteResourceModel) RefreshFromSharedMeshHTTPRouteItem(ctx context.Context, resp *shared.MeshHTTPRouteItem) diag.Diagnostics {
	var diags diag.Diagnostics

	if resp != nil {
		r.CreationTime = types.StringPointerValue(typeconvert.TimePointerToStringPointer(resp.CreationTime))
		if len(resp.Labels) > 0 {
			r.Labels = make(map[string]types.String, len(resp.Labels))
			for key, value := range resp.Labels {
				r.Labels[key] = types.StringValue(value)
			}
		}
		r.Mesh = types.StringPointerValue(resp.Mesh)
		r.ModificationTime = types.StringPointerValue(typeconvert.TimePointerToStringPointer(resp.ModificationTime))
		r.Name = types.StringValue(resp.Name)
		if resp.Spec.TargetRef == nil {
			r.Spec.TargetRef = nil
		} else {
			r.Spec.TargetRef = &tfTypes.MeshAccessLogItemTargetRef{}
			r.Spec.TargetRef.Kind = types.StringValue(string(resp.Spec.TargetRef.Kind))
			if len(resp.Spec.TargetRef.Labels) > 0 {
				r.Spec.TargetRef.Labels = make(map[string]types.String, len(resp.Spec.TargetRef.Labels))
				for key1, value1 := range resp.Spec.TargetRef.Labels {
					r.Spec.TargetRef.Labels[key1] = types.StringValue(value1)
				}
			}
			r.Spec.TargetRef.Mesh = types.StringPointerValue(resp.Spec.TargetRef.Mesh)
			r.Spec.TargetRef.Name = types.StringPointerValue(resp.Spec.TargetRef.Name)
			r.Spec.TargetRef.Namespace = types.StringPointerValue(resp.Spec.TargetRef.Namespace)
			r.Spec.TargetRef.ProxyTypes = make([]types.String, 0, len(resp.Spec.TargetRef.ProxyTypes))
			for _, v := range resp.Spec.TargetRef.ProxyTypes {
				r.Spec.TargetRef.ProxyTypes = append(r.Spec.TargetRef.ProxyTypes, types.StringValue(string(v)))
			}
			r.Spec.TargetRef.SectionName = types.StringPointerValue(resp.Spec.TargetRef.SectionName)
			if len(resp.Spec.TargetRef.Tags) > 0 {
				r.Spec.TargetRef.Tags = make(map[string]types.String, len(resp.Spec.TargetRef.Tags))
				for key2, value2 := range resp.Spec.TargetRef.Tags {
					r.Spec.TargetRef.Tags[key2] = types.StringValue(value2)
				}
			}
		}
		r.Spec.To = []tfTypes.MeshHTTPRouteItemTo{}
		if len(r.Spec.To) > len(resp.Spec.To) {
			r.Spec.To = r.Spec.To[:len(resp.Spec.To)]
		}
		for toCount, toItem := range resp.Spec.To {
			var to tfTypes.MeshHTTPRouteItemTo
			to.Hostnames = make([]types.String, 0, len(toItem.Hostnames))
			for _, v := range toItem.Hostnames {
				to.Hostnames = append(to.Hostnames, types.StringValue(v))
			}
			to.Rules = []tfTypes.MeshHTTPRouteItemRules{}
			for rulesCount, rulesItem := range toItem.Rules {
				var rules tfTypes.MeshHTTPRouteItemRules
				rules.Default.BackendRefs = []tfTypes.BackendRefs{}
				for backendRefsCount, backendRefsItem := range rulesItem.Default.BackendRefs {
					var backendRefs tfTypes.BackendRefs
					backendRefs.Kind = types.StringValue(string(backendRefsItem.Kind))
					if len(backendRefsItem.Labels) > 0 {
						backendRefs.Labels = make(map[string]types.String, len(backendRefsItem.Labels))
						for key3, value3 := range backendRefsItem.Labels {
							backendRefs.Labels[key3] = types.StringValue(value3)
						}
					}
					backendRefs.Mesh = types.StringPointerValue(backendRefsItem.Mesh)
					backendRefs.Name = types.StringPointerValue(backendRefsItem.Name)
					backendRefs.Namespace = types.StringPointerValue(backendRefsItem.Namespace)
					backendRefs.Port = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(backendRefsItem.Port))
					backendRefs.ProxyTypes = make([]types.String, 0, len(backendRefsItem.ProxyTypes))
					for _, v := range backendRefsItem.ProxyTypes {
						backendRefs.ProxyTypes = append(backendRefs.ProxyTypes, types.StringValue(string(v)))
					}
					backendRefs.SectionName = types.StringPointerValue(backendRefsItem.SectionName)
					if len(backendRefsItem.Tags) > 0 {
						backendRefs.Tags = make(map[string]types.String, len(backendRefsItem.Tags))
						for key4, value4 := range backendRefsItem.Tags {
							backendRefs.Tags[key4] = types.StringValue(value4)
						}
					}
					backendRefs.Weight = types.Int64PointerValue(backendRefsItem.Weight)
					if backendRefsCount+1 > len(rules.Default.BackendRefs) {
						rules.Default.BackendRefs = append(rules.Default.BackendRefs, backendRefs)
					} else {
						rules.Default.BackendRefs[backendRefsCount].Kind = backendRefs.Kind
						rules.Default.BackendRefs[backendRefsCount].Labels = backendRefs.Labels
						rules.Default.BackendRefs[backendRefsCount].Mesh = backendRefs.Mesh
						rules.Default.BackendRefs[backendRefsCount].Name = backendRefs.Name
						rules.Default.BackendRefs[backendRefsCount].Namespace = backendRefs.Namespace
						rules.Default.BackendRefs[backendRefsCount].Port = backendRefs.Port
						rules.Default.BackendRefs[backendRefsCount].ProxyTypes = backendRefs.ProxyTypes
						rules.Default.BackendRefs[backendRefsCount].SectionName = backendRefs.SectionName
						rules.Default.BackendRefs[backendRefsCount].Tags = backendRefs.Tags
						rules.Default.BackendRefs[backendRefsCount].Weight = backendRefs.Weight
					}
				}
				rules.Default.Filters = []tfTypes.Filters{}
				for filtersCount, filtersItem := range rulesItem.Default.Filters {
					var filters tfTypes.Filters
					if filtersItem.RequestHeaderModifier == nil {
						filters.RequestHeaderModifier = nil
					} else {
						filters.RequestHeaderModifier = &tfTypes.RequestHeaderModifier{}
						filters.RequestHeaderModifier.Add = []tfTypes.MeshGlobalRateLimitItemAdd{}
						for addCount, addItem := range filtersItem.RequestHeaderModifier.Add {
							var add tfTypes.MeshGlobalRateLimitItemAdd
							add.Name = types.StringValue(addItem.Name)
							add.Value = types.StringValue(addItem.Value)
							if addCount+1 > len(filters.RequestHeaderModifier.Add) {
								filters.RequestHeaderModifier.Add = append(filters.RequestHeaderModifier.Add, add)
							} else {
								filters.RequestHeaderModifier.Add[addCount].Name = add.Name
								filters.RequestHeaderModifier.Add[addCount].Value = add.Value
							}
						}
						filters.RequestHeaderModifier.Remove = make([]types.String, 0, len(filtersItem.RequestHeaderModifier.Remove))
						for _, v := range filtersItem.RequestHeaderModifier.Remove {
							filters.RequestHeaderModifier.Remove = append(filters.RequestHeaderModifier.Remove, types.StringValue(v))
						}
						filters.RequestHeaderModifier.Set = []tfTypes.MeshGlobalRateLimitItemAdd{}
						for setCount, setItem := range filtersItem.RequestHeaderModifier.Set {
							var set tfTypes.MeshGlobalRateLimitItemAdd
							set.Name = types.StringValue(setItem.Name)
							set.Value = types.StringValue(setItem.Value)
							if setCount+1 > len(filters.RequestHeaderModifier.Set) {
								filters.RequestHeaderModifier.Set = append(filters.RequestHeaderModifier.Set, set)
							} else {
								filters.RequestHeaderModifier.Set[setCount].Name = set.Name
								filters.RequestHeaderModifier.Set[setCount].Value = set.Value
							}
						}
					}
					if filtersItem.RequestMirror == nil {
						filters.RequestMirror = nil
					} else {
						filters.RequestMirror = &tfTypes.RequestMirror{}
						filters.RequestMirror.BackendRef.Kind = types.StringValue(string(filtersItem.RequestMirror.BackendRef.Kind))
						if len(filtersItem.RequestMirror.BackendRef.Labels) > 0 {
							filters.RequestMirror.BackendRef.Labels = make(map[string]types.String, len(filtersItem.RequestMirror.BackendRef.Labels))
							for key5, value5 := range filtersItem.RequestMirror.BackendRef.Labels {
								filters.RequestMirror.BackendRef.Labels[key5] = types.StringValue(value5)
							}
						}
						filters.RequestMirror.BackendRef.Mesh = types.StringPointerValue(filtersItem.RequestMirror.BackendRef.Mesh)
						filters.RequestMirror.BackendRef.Name = types.StringPointerValue(filtersItem.RequestMirror.BackendRef.Name)
						filters.RequestMirror.BackendRef.Namespace = types.StringPointerValue(filtersItem.RequestMirror.BackendRef.Namespace)
						filters.RequestMirror.BackendRef.Port = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(filtersItem.RequestMirror.BackendRef.Port))
						filters.RequestMirror.BackendRef.ProxyTypes = make([]types.String, 0, len(filtersItem.RequestMirror.BackendRef.ProxyTypes))
						for _, v := range filtersItem.RequestMirror.BackendRef.ProxyTypes {
							filters.RequestMirror.BackendRef.ProxyTypes = append(filters.RequestMirror.BackendRef.ProxyTypes, types.StringValue(string(v)))
						}
						filters.RequestMirror.BackendRef.SectionName = types.StringPointerValue(filtersItem.RequestMirror.BackendRef.SectionName)
						if len(filtersItem.RequestMirror.BackendRef.Tags) > 0 {
							filters.RequestMirror.BackendRef.Tags = make(map[string]types.String, len(filtersItem.RequestMirror.BackendRef.Tags))
							for key6, value6 := range filtersItem.RequestMirror.BackendRef.Tags {
								filters.RequestMirror.BackendRef.Tags[key6] = types.StringValue(value6)
							}
						}
						filters.RequestMirror.BackendRef.Weight = types.Int64PointerValue(filtersItem.RequestMirror.BackendRef.Weight)
						if filtersItem.RequestMirror.Percentage != nil {
							filters.RequestMirror.Percentage = &tfTypes.Mode{}
							if filtersItem.RequestMirror.Percentage.Integer != nil {
								filters.RequestMirror.Percentage.Integer = types.Int64PointerValue(filtersItem.RequestMirror.Percentage.Integer)
							}
							if filtersItem.RequestMirror.Percentage.Str != nil {
								filters.RequestMirror.Percentage.Str = types.StringPointerValue(filtersItem.RequestMirror.Percentage.Str)
							}
						}
					}
					if filtersItem.RequestRedirect == nil {
						filters.RequestRedirect = nil
					} else {
						filters.RequestRedirect = &tfTypes.RequestRedirect{}
						filters.RequestRedirect.Hostname = types.StringPointerValue(filtersItem.RequestRedirect.Hostname)
						if filtersItem.RequestRedirect.Path == nil {
							filters.RequestRedirect.Path = nil
						} else {
							filters.RequestRedirect.Path = &tfTypes.MeshHTTPRouteItemSpecPath{}
							filters.RequestRedirect.Path.ReplaceFullPath = types.StringPointerValue(filtersItem.RequestRedirect.Path.ReplaceFullPath)
							filters.RequestRedirect.Path.ReplacePrefixMatch = types.StringPointerValue(filtersItem.RequestRedirect.Path.ReplacePrefixMatch)
							filters.RequestRedirect.Path.Type = types.StringValue(string(filtersItem.RequestRedirect.Path.Type))
						}
						filters.RequestRedirect.Port = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(filtersItem.RequestRedirect.Port))
						if filtersItem.RequestRedirect.Scheme != nil {
							filters.RequestRedirect.Scheme = types.StringValue(string(*filtersItem.RequestRedirect.Scheme))
						} else {
							filters.RequestRedirect.Scheme = types.StringNull()
						}
						if filtersItem.RequestRedirect.StatusCode != nil {
							filters.RequestRedirect.StatusCode = types.Int64Value(int64(*filtersItem.RequestRedirect.StatusCode))
						} else {
							filters.RequestRedirect.StatusCode = types.Int64Null()
						}
					}
					if filtersItem.ResponseHeaderModifier == nil {
						filters.ResponseHeaderModifier = nil
					} else {
						filters.ResponseHeaderModifier = &tfTypes.RequestHeaderModifier{}
						filters.ResponseHeaderModifier.Add = []tfTypes.MeshGlobalRateLimitItemAdd{}
						for addCount1, addItem1 := range filtersItem.ResponseHeaderModifier.Add {
							var add1 tfTypes.MeshGlobalRateLimitItemAdd
							add1.Name = types.StringValue(addItem1.Name)
							add1.Value = types.StringValue(addItem1.Value)
							if addCount1+1 > len(filters.ResponseHeaderModifier.Add) {
								filters.ResponseHeaderModifier.Add = append(filters.ResponseHeaderModifier.Add, add1)
							} else {
								filters.ResponseHeaderModifier.Add[addCount1].Name = add1.Name
								filters.ResponseHeaderModifier.Add[addCount1].Value = add1.Value
							}
						}
						filters.ResponseHeaderModifier.Remove = make([]types.String, 0, len(filtersItem.ResponseHeaderModifier.Remove))
						for _, v := range filtersItem.ResponseHeaderModifier.Remove {
							filters.ResponseHeaderModifier.Remove = append(filters.ResponseHeaderModifier.Remove, types.StringValue(v))
						}
						filters.ResponseHeaderModifier.Set = []tfTypes.MeshGlobalRateLimitItemAdd{}
						for setCount1, setItem1 := range filtersItem.ResponseHeaderModifier.Set {
							var set1 tfTypes.MeshGlobalRateLimitItemAdd
							set1.Name = types.StringValue(setItem1.Name)
							set1.Value = types.StringValue(setItem1.Value)
							if setCount1+1 > len(filters.ResponseHeaderModifier.Set) {
								filters.ResponseHeaderModifier.Set = append(filters.ResponseHeaderModifier.Set, set1)
							} else {
								filters.ResponseHeaderModifier.Set[setCount1].Name = set1.Name
								filters.ResponseHeaderModifier.Set[setCount1].Value = set1.Value
							}
						}
					}
					filters.Type = types.StringValue(string(filtersItem.Type))
					if filtersItem.URLRewrite == nil {
						filters.URLRewrite = nil
					} else {
						filters.URLRewrite = &tfTypes.URLRewrite{}
						filters.URLRewrite.Hostname = types.StringPointerValue(filtersItem.URLRewrite.Hostname)
						filters.URLRewrite.HostToBackendHostname = types.BoolPointerValue(filtersItem.URLRewrite.HostToBackendHostname)
						if filtersItem.URLRewrite.Path == nil {
							filters.URLRewrite.Path = nil
						} else {
							filters.URLRewrite.Path = &tfTypes.MeshHTTPRouteItemSpecPath{}
							filters.URLRewrite.Path.ReplaceFullPath = types.StringPointerValue(filtersItem.URLRewrite.Path.ReplaceFullPath)
							filters.URLRewrite.Path.ReplacePrefixMatch = types.StringPointerValue(filtersItem.URLRewrite.Path.ReplacePrefixMatch)
							filters.URLRewrite.Path.Type = types.StringValue(string(filtersItem.URLRewrite.Path.Type))
						}
					}
					if filtersCount+1 > len(rules.Default.Filters) {
						rules.Default.Filters = append(rules.Default.Filters, filters)
					} else {
						rules.Default.Filters[filtersCount].RequestHeaderModifier = filters.RequestHeaderModifier
						rules.Default.Filters[filtersCount].RequestMirror = filters.RequestMirror
						rules.Default.Filters[filtersCount].RequestRedirect = filters.RequestRedirect
						rules.Default.Filters[filtersCount].ResponseHeaderModifier = filters.ResponseHeaderModifier
						rules.Default.Filters[filtersCount].Type = filters.Type
						rules.Default.Filters[filtersCount].URLRewrite = filters.URLRewrite
					}
				}
				rules.Matches = []tfTypes.Matches{}
				for matchesCount, matchesItem := range rulesItem.Matches {
					var matches tfTypes.Matches
					matches.Headers = []tfTypes.Headers{}
					for headersCount, headersItem := range matchesItem.Headers {
						var headers tfTypes.Headers
						headers.Name = types.StringValue(headersItem.Name)
						if headersItem.Type != nil {
							headers.Type = types.StringValue(string(*headersItem.Type))
						} else {
							headers.Type = types.StringNull()
						}
						headers.Value = types.StringPointerValue(headersItem.Value)
						if headersCount+1 > len(matches.Headers) {
							matches.Headers = append(matches.Headers, headers)
						} else {
							matches.Headers[headersCount].Name = headers.Name
							matches.Headers[headersCount].Type = headers.Type
							matches.Headers[headersCount].Value = headers.Value
						}
					}
					if matchesItem.Method != nil {
						matches.Method = types.StringValue(string(*matchesItem.Method))
					} else {
						matches.Method = types.StringNull()
					}
					if matchesItem.Path == nil {
						matches.Path = nil
					} else {
						matches.Path = &tfTypes.Path{}
						matches.Path.Type = types.StringValue(string(matchesItem.Path.Type))
						matches.Path.Value = types.StringValue(matchesItem.Path.Value)
					}
					matches.QueryParams = []tfTypes.QueryParams{}
					for queryParamsCount, queryParamsItem := range matchesItem.QueryParams {
						var queryParams tfTypes.QueryParams
						queryParams.Name = types.StringValue(queryParamsItem.Name)
						queryParams.Type = types.StringValue(string(queryParamsItem.Type))
						queryParams.Value = types.StringValue(queryParamsItem.Value)
						if queryParamsCount+1 > len(matches.QueryParams) {
							matches.QueryParams = append(matches.QueryParams, queryParams)
						} else {
							matches.QueryParams[queryParamsCount].Name = queryParams.Name
							matches.QueryParams[queryParamsCount].Type = queryParams.Type
							matches.QueryParams[queryParamsCount].Value = queryParams.Value
						}
					}
					if matchesCount+1 > len(rules.Matches) {
						rules.Matches = append(rules.Matches, matches)
					} else {
						rules.Matches[matchesCount].Headers = matches.Headers
						rules.Matches[matchesCount].Method = matches.Method
						rules.Matches[matchesCount].Path = matches.Path
						rules.Matches[matchesCount].QueryParams = matches.QueryParams
					}
				}
				if rulesCount+1 > len(to.Rules) {
					to.Rules = append(to.Rules, rules)
				} else {
					to.Rules[rulesCount].Default = rules.Default
					to.Rules[rulesCount].Matches = rules.Matches
				}
			}
			to.TargetRef.Kind = types.StringValue(string(toItem.TargetRef.Kind))
			if len(toItem.TargetRef.Labels) > 0 {
				to.TargetRef.Labels = make(map[string]types.String, len(toItem.TargetRef.Labels))
				for key7, value7 := range toItem.TargetRef.Labels {
					to.TargetRef.Labels[key7] = types.StringValue(value7)
				}
			}
			to.TargetRef.Mesh = types.StringPointerValue(toItem.TargetRef.Mesh)
			to.TargetRef.Name = types.StringPointerValue(toItem.TargetRef.Name)
			to.TargetRef.Namespace = types.StringPointerValue(toItem.TargetRef.Namespace)
			to.TargetRef.ProxyTypes = make([]types.String, 0, len(toItem.TargetRef.ProxyTypes))
			for _, v := range toItem.TargetRef.ProxyTypes {
				to.TargetRef.ProxyTypes = append(to.TargetRef.ProxyTypes, types.StringValue(string(v)))
			}
			to.TargetRef.SectionName = types.StringPointerValue(toItem.TargetRef.SectionName)
			if len(toItem.TargetRef.Tags) > 0 {
				to.TargetRef.Tags = make(map[string]types.String, len(toItem.TargetRef.Tags))
				for key8, value8 := range toItem.TargetRef.Tags {
					to.TargetRef.Tags[key8] = types.StringValue(value8)
				}
			}
			if toCount+1 > len(r.Spec.To) {
				r.Spec.To = append(r.Spec.To, to)
			} else {
				r.Spec.To[toCount].Hostnames = to.Hostnames
				r.Spec.To[toCount].Rules = to.Rules
				r.Spec.To[toCount].TargetRef = to.TargetRef
			}
		}
		r.Type = types.StringValue(string(resp.Type))
	}

	return diags
}
