// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package provider

import (
	"context"
	"github.com/Kong/shared-speakeasy/customtypes/kumalabels"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/kong/terraform-provider-kong-mesh/internal/provider/typeconvert"
	tfTypes "github.com/kong/terraform-provider-kong-mesh/internal/provider/types"
	"github.com/kong/terraform-provider-kong-mesh/internal/sdk/models/operations"
	"github.com/kong/terraform-provider-kong-mesh/internal/sdk/models/shared"
)

func (r *MeshLoadBalancingStrategyResourceModel) RefreshFromSharedMeshLoadBalancingStrategyCreateOrUpdateSuccessResponse(ctx context.Context, resp *shared.MeshLoadBalancingStrategyCreateOrUpdateSuccessResponse) diag.Diagnostics {
	var diags diag.Diagnostics

	if resp != nil {
		r.Warnings = make([]types.String, 0, len(resp.Warnings))
		for _, v := range resp.Warnings {
			r.Warnings = append(r.Warnings, types.StringValue(v))
		}
	}

	return diags
}

func (r *MeshLoadBalancingStrategyResourceModel) RefreshFromSharedMeshLoadBalancingStrategyItem(ctx context.Context, resp *shared.MeshLoadBalancingStrategyItem) diag.Diagnostics {
	var diags diag.Diagnostics

	if resp != nil {
		r.CreationTime = types.StringPointerValue(typeconvert.TimePointerToStringPointer(resp.CreationTime))
		labelsValue, labelsDiags := types.MapValueFrom(ctx, types.StringType, resp.Labels)
		diags.Append(labelsDiags...)
		labelsValuable, labelsDiags := kumalabels.KumaLabelsMapType{MapType: types.MapType{ElemType: types.StringType}}.ValueFromMap(ctx, labelsValue)
		diags.Append(labelsDiags...)
		r.Labels, _ = labelsValuable.(kumalabels.KumaLabelsMapValue)
		r.Mesh = types.StringPointerValue(resp.Mesh)
		r.ModificationTime = types.StringPointerValue(typeconvert.TimePointerToStringPointer(resp.ModificationTime))
		r.Name = types.StringValue(resp.Name)
		if resp.Spec.TargetRef == nil {
			r.Spec.TargetRef = nil
		} else {
			r.Spec.TargetRef = &tfTypes.MeshAccessLogItemTargetRef{}
			r.Spec.TargetRef.Kind = types.StringValue(string(resp.Spec.TargetRef.Kind))
			if len(resp.Spec.TargetRef.Labels) > 0 {
				r.Spec.TargetRef.Labels = make(map[string]types.String, len(resp.Spec.TargetRef.Labels))
				for key, value := range resp.Spec.TargetRef.Labels {
					r.Spec.TargetRef.Labels[key] = types.StringValue(value)
				}
			}
			r.Spec.TargetRef.Mesh = types.StringPointerValue(resp.Spec.TargetRef.Mesh)
			r.Spec.TargetRef.Name = types.StringPointerValue(resp.Spec.TargetRef.Name)
			r.Spec.TargetRef.Namespace = types.StringPointerValue(resp.Spec.TargetRef.Namespace)
			r.Spec.TargetRef.ProxyTypes = make([]types.String, 0, len(resp.Spec.TargetRef.ProxyTypes))
			for _, v := range resp.Spec.TargetRef.ProxyTypes {
				r.Spec.TargetRef.ProxyTypes = append(r.Spec.TargetRef.ProxyTypes, types.StringValue(string(v)))
			}
			r.Spec.TargetRef.SectionName = types.StringPointerValue(resp.Spec.TargetRef.SectionName)
			if len(resp.Spec.TargetRef.Tags) > 0 {
				r.Spec.TargetRef.Tags = make(map[string]types.String, len(resp.Spec.TargetRef.Tags))
				for key1, value1 := range resp.Spec.TargetRef.Tags {
					r.Spec.TargetRef.Tags[key1] = types.StringValue(value1)
				}
			}
		}
		r.Spec.To = []tfTypes.MeshLoadBalancingStrategyItemTo{}

		for _, toItem := range resp.Spec.To {
			var to tfTypes.MeshLoadBalancingStrategyItemTo

			if toItem.Default == nil {
				to.Default = nil
			} else {
				to.Default = &tfTypes.MeshLoadBalancingStrategyItemDefault{}
				to.Default.HashPolicies = []tfTypes.HashPolicies{}

				for _, hashPoliciesItem := range toItem.Default.HashPolicies {
					var hashPolicies tfTypes.HashPolicies

					if hashPoliciesItem.Connection == nil {
						hashPolicies.Connection = nil
					} else {
						hashPolicies.Connection = &tfTypes.Connection{}
						hashPolicies.Connection.SourceIP = types.BoolPointerValue(hashPoliciesItem.Connection.SourceIP)
					}
					if hashPoliciesItem.Cookie == nil {
						hashPolicies.Cookie = nil
					} else {
						hashPolicies.Cookie = &tfTypes.Cookie{}
						hashPolicies.Cookie.Name = types.StringValue(hashPoliciesItem.Cookie.Name)
						hashPolicies.Cookie.Path = types.StringPointerValue(hashPoliciesItem.Cookie.Path)
						hashPolicies.Cookie.TTL = types.StringPointerValue(hashPoliciesItem.Cookie.TTL)
					}
					if hashPoliciesItem.FilterState == nil {
						hashPolicies.FilterState = nil
					} else {
						hashPolicies.FilterState = &tfTypes.FilterState{}
						hashPolicies.FilterState.Key = types.StringValue(hashPoliciesItem.FilterState.Key)
					}
					if hashPoliciesItem.Header == nil {
						hashPolicies.Header = nil
					} else {
						hashPolicies.Header = &tfTypes.EnvVar{}
						hashPolicies.Header.Name = types.StringValue(hashPoliciesItem.Header.Name)
					}
					if hashPoliciesItem.QueryParameter == nil {
						hashPolicies.QueryParameter = nil
					} else {
						hashPolicies.QueryParameter = &tfTypes.EnvVar{}
						hashPolicies.QueryParameter.Name = types.StringValue(hashPoliciesItem.QueryParameter.Name)
					}
					hashPolicies.Terminal = types.BoolPointerValue(hashPoliciesItem.Terminal)
					hashPolicies.Type = types.StringValue(string(hashPoliciesItem.Type))

					to.Default.HashPolicies = append(to.Default.HashPolicies, hashPolicies)
				}
				if toItem.Default.LoadBalancer == nil {
					to.Default.LoadBalancer = nil
				} else {
					to.Default.LoadBalancer = &tfTypes.LoadBalancer{}
					if toItem.Default.LoadBalancer.LeastRequest == nil {
						to.Default.LoadBalancer.LeastRequest = nil
					} else {
						to.Default.LoadBalancer.LeastRequest = &tfTypes.LeastRequest{}
						if toItem.Default.LoadBalancer.LeastRequest.ActiveRequestBias != nil {
							to.Default.LoadBalancer.LeastRequest.ActiveRequestBias = &tfTypes.Mode{}
							if toItem.Default.LoadBalancer.LeastRequest.ActiveRequestBias.Integer != nil {
								to.Default.LoadBalancer.LeastRequest.ActiveRequestBias.Integer = types.Int64PointerValue(toItem.Default.LoadBalancer.LeastRequest.ActiveRequestBias.Integer)
							}
							if toItem.Default.LoadBalancer.LeastRequest.ActiveRequestBias.Str != nil {
								to.Default.LoadBalancer.LeastRequest.ActiveRequestBias.Str = types.StringPointerValue(toItem.Default.LoadBalancer.LeastRequest.ActiveRequestBias.Str)
							}
						}
						to.Default.LoadBalancer.LeastRequest.ChoiceCount = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(toItem.Default.LoadBalancer.LeastRequest.ChoiceCount))
					}
					if toItem.Default.LoadBalancer.Maglev == nil {
						to.Default.LoadBalancer.Maglev = nil
					} else {
						to.Default.LoadBalancer.Maglev = &tfTypes.Maglev{}
						to.Default.LoadBalancer.Maglev.HashPolicies = []tfTypes.HashPolicies{}

						for _, hashPoliciesItem1 := range toItem.Default.LoadBalancer.Maglev.HashPolicies {
							var hashPolicies1 tfTypes.HashPolicies

							if hashPoliciesItem1.Connection == nil {
								hashPolicies1.Connection = nil
							} else {
								hashPolicies1.Connection = &tfTypes.Connection{}
								hashPolicies1.Connection.SourceIP = types.BoolPointerValue(hashPoliciesItem1.Connection.SourceIP)
							}
							if hashPoliciesItem1.Cookie == nil {
								hashPolicies1.Cookie = nil
							} else {
								hashPolicies1.Cookie = &tfTypes.Cookie{}
								hashPolicies1.Cookie.Name = types.StringValue(hashPoliciesItem1.Cookie.Name)
								hashPolicies1.Cookie.Path = types.StringPointerValue(hashPoliciesItem1.Cookie.Path)
								hashPolicies1.Cookie.TTL = types.StringPointerValue(hashPoliciesItem1.Cookie.TTL)
							}
							if hashPoliciesItem1.FilterState == nil {
								hashPolicies1.FilterState = nil
							} else {
								hashPolicies1.FilterState = &tfTypes.FilterState{}
								hashPolicies1.FilterState.Key = types.StringValue(hashPoliciesItem1.FilterState.Key)
							}
							if hashPoliciesItem1.Header == nil {
								hashPolicies1.Header = nil
							} else {
								hashPolicies1.Header = &tfTypes.EnvVar{}
								hashPolicies1.Header.Name = types.StringValue(hashPoliciesItem1.Header.Name)
							}
							if hashPoliciesItem1.QueryParameter == nil {
								hashPolicies1.QueryParameter = nil
							} else {
								hashPolicies1.QueryParameter = &tfTypes.EnvVar{}
								hashPolicies1.QueryParameter.Name = types.StringValue(hashPoliciesItem1.QueryParameter.Name)
							}
							hashPolicies1.Terminal = types.BoolPointerValue(hashPoliciesItem1.Terminal)
							hashPolicies1.Type = types.StringValue(string(hashPoliciesItem1.Type))

							to.Default.LoadBalancer.Maglev.HashPolicies = append(to.Default.LoadBalancer.Maglev.HashPolicies, hashPolicies1)
						}
						to.Default.LoadBalancer.Maglev.TableSize = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(toItem.Default.LoadBalancer.Maglev.TableSize))
					}
					if toItem.Default.LoadBalancer.Random == nil {
						to.Default.LoadBalancer.Random = nil
					} else {
						to.Default.LoadBalancer.Random = &tfTypes.OptionsObj{}
					}
					if toItem.Default.LoadBalancer.RingHash == nil {
						to.Default.LoadBalancer.RingHash = nil
					} else {
						to.Default.LoadBalancer.RingHash = &tfTypes.RingHash{}
						if toItem.Default.LoadBalancer.RingHash.HashFunction != nil {
							to.Default.LoadBalancer.RingHash.HashFunction = types.StringValue(string(*toItem.Default.LoadBalancer.RingHash.HashFunction))
						} else {
							to.Default.LoadBalancer.RingHash.HashFunction = types.StringNull()
						}
						to.Default.LoadBalancer.RingHash.HashPolicies = []tfTypes.HashPolicies{}

						for _, hashPoliciesItem2 := range toItem.Default.LoadBalancer.RingHash.HashPolicies {
							var hashPolicies2 tfTypes.HashPolicies

							if hashPoliciesItem2.Connection == nil {
								hashPolicies2.Connection = nil
							} else {
								hashPolicies2.Connection = &tfTypes.Connection{}
								hashPolicies2.Connection.SourceIP = types.BoolPointerValue(hashPoliciesItem2.Connection.SourceIP)
							}
							if hashPoliciesItem2.Cookie == nil {
								hashPolicies2.Cookie = nil
							} else {
								hashPolicies2.Cookie = &tfTypes.Cookie{}
								hashPolicies2.Cookie.Name = types.StringValue(hashPoliciesItem2.Cookie.Name)
								hashPolicies2.Cookie.Path = types.StringPointerValue(hashPoliciesItem2.Cookie.Path)
								hashPolicies2.Cookie.TTL = types.StringPointerValue(hashPoliciesItem2.Cookie.TTL)
							}
							if hashPoliciesItem2.FilterState == nil {
								hashPolicies2.FilterState = nil
							} else {
								hashPolicies2.FilterState = &tfTypes.FilterState{}
								hashPolicies2.FilterState.Key = types.StringValue(hashPoliciesItem2.FilterState.Key)
							}
							if hashPoliciesItem2.Header == nil {
								hashPolicies2.Header = nil
							} else {
								hashPolicies2.Header = &tfTypes.EnvVar{}
								hashPolicies2.Header.Name = types.StringValue(hashPoliciesItem2.Header.Name)
							}
							if hashPoliciesItem2.QueryParameter == nil {
								hashPolicies2.QueryParameter = nil
							} else {
								hashPolicies2.QueryParameter = &tfTypes.EnvVar{}
								hashPolicies2.QueryParameter.Name = types.StringValue(hashPoliciesItem2.QueryParameter.Name)
							}
							hashPolicies2.Terminal = types.BoolPointerValue(hashPoliciesItem2.Terminal)
							hashPolicies2.Type = types.StringValue(string(hashPoliciesItem2.Type))

							to.Default.LoadBalancer.RingHash.HashPolicies = append(to.Default.LoadBalancer.RingHash.HashPolicies, hashPolicies2)
						}
						to.Default.LoadBalancer.RingHash.MaxRingSize = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(toItem.Default.LoadBalancer.RingHash.MaxRingSize))
						to.Default.LoadBalancer.RingHash.MinRingSize = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(toItem.Default.LoadBalancer.RingHash.MinRingSize))
					}
					if toItem.Default.LoadBalancer.RoundRobin == nil {
						to.Default.LoadBalancer.RoundRobin = nil
					} else {
						to.Default.LoadBalancer.RoundRobin = &tfTypes.OptionsObj{}
					}
					to.Default.LoadBalancer.Type = types.StringValue(string(toItem.Default.LoadBalancer.Type))
				}
				if toItem.Default.LocalityAwareness == nil {
					to.Default.LocalityAwareness = nil
				} else {
					to.Default.LocalityAwareness = &tfTypes.LocalityAwareness{}
					if toItem.Default.LocalityAwareness.CrossZone == nil {
						to.Default.LocalityAwareness.CrossZone = nil
					} else {
						to.Default.LocalityAwareness.CrossZone = &tfTypes.CrossZone{}
						to.Default.LocalityAwareness.CrossZone.Failover = []tfTypes.Failover{}

						for _, failoverItem := range toItem.Default.LocalityAwareness.CrossZone.Failover {
							var failover tfTypes.Failover

							if failoverItem.From == nil {
								failover.From = nil
							} else {
								failover.From = &tfTypes.MeshLoadBalancingStrategyItemFrom{}
								failover.From.Zones = make([]types.String, 0, len(failoverItem.From.Zones))
								for _, v := range failoverItem.From.Zones {
									failover.From.Zones = append(failover.From.Zones, types.StringValue(v))
								}
							}
							failover.To.Type = types.StringValue(string(failoverItem.To.Type))
							failover.To.Zones = make([]types.String, 0, len(failoverItem.To.Zones))
							for _, v := range failoverItem.To.Zones {
								failover.To.Zones = append(failover.To.Zones, types.StringValue(v))
							}

							to.Default.LocalityAwareness.CrossZone.Failover = append(to.Default.LocalityAwareness.CrossZone.Failover, failover)
						}
						if toItem.Default.LocalityAwareness.CrossZone.FailoverThreshold == nil {
							to.Default.LocalityAwareness.CrossZone.FailoverThreshold = nil
						} else {
							to.Default.LocalityAwareness.CrossZone.FailoverThreshold = &tfTypes.FailoverThreshold{}
							if toItem.Default.LocalityAwareness.CrossZone.FailoverThreshold.Percentage.Integer != nil {
								to.Default.LocalityAwareness.CrossZone.FailoverThreshold.Percentage.Integer = types.Int64PointerValue(toItem.Default.LocalityAwareness.CrossZone.FailoverThreshold.Percentage.Integer)
							}
							if toItem.Default.LocalityAwareness.CrossZone.FailoverThreshold.Percentage.Str != nil {
								to.Default.LocalityAwareness.CrossZone.FailoverThreshold.Percentage.Str = types.StringPointerValue(toItem.Default.LocalityAwareness.CrossZone.FailoverThreshold.Percentage.Str)
							}
						}
					}
					to.Default.LocalityAwareness.Disabled = types.BoolPointerValue(toItem.Default.LocalityAwareness.Disabled)
					if toItem.Default.LocalityAwareness.LocalZone == nil {
						to.Default.LocalityAwareness.LocalZone = nil
					} else {
						to.Default.LocalityAwareness.LocalZone = &tfTypes.LocalZone{}
						to.Default.LocalityAwareness.LocalZone.AffinityTags = []tfTypes.AffinityTags{}

						for _, affinityTagsItem := range toItem.Default.LocalityAwareness.LocalZone.AffinityTags {
							var affinityTags tfTypes.AffinityTags

							affinityTags.Key = types.StringValue(affinityTagsItem.Key)
							affinityTags.Weight = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(affinityTagsItem.Weight))

							to.Default.LocalityAwareness.LocalZone.AffinityTags = append(to.Default.LocalityAwareness.LocalZone.AffinityTags, affinityTags)
						}
					}
				}
			}
			to.TargetRef.Kind = types.StringValue(string(toItem.TargetRef.Kind))
			if len(toItem.TargetRef.Labels) > 0 {
				to.TargetRef.Labels = make(map[string]types.String, len(toItem.TargetRef.Labels))
				for key2, value2 := range toItem.TargetRef.Labels {
					to.TargetRef.Labels[key2] = types.StringValue(value2)
				}
			}
			to.TargetRef.Mesh = types.StringPointerValue(toItem.TargetRef.Mesh)
			to.TargetRef.Name = types.StringPointerValue(toItem.TargetRef.Name)
			to.TargetRef.Namespace = types.StringPointerValue(toItem.TargetRef.Namespace)
			to.TargetRef.ProxyTypes = make([]types.String, 0, len(toItem.TargetRef.ProxyTypes))
			for _, v := range toItem.TargetRef.ProxyTypes {
				to.TargetRef.ProxyTypes = append(to.TargetRef.ProxyTypes, types.StringValue(string(v)))
			}
			to.TargetRef.SectionName = types.StringPointerValue(toItem.TargetRef.SectionName)
			if len(toItem.TargetRef.Tags) > 0 {
				to.TargetRef.Tags = make(map[string]types.String, len(toItem.TargetRef.Tags))
				for key3, value3 := range toItem.TargetRef.Tags {
					to.TargetRef.Tags[key3] = types.StringValue(value3)
				}
			}

			r.Spec.To = append(r.Spec.To, to)
		}
		r.Type = types.StringValue(string(resp.Type))
	}

	return diags
}

func (r *MeshLoadBalancingStrategyResourceModel) ToOperationsDeleteMeshLoadBalancingStrategyRequest(ctx context.Context) (*operations.DeleteMeshLoadBalancingStrategyRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var mesh string
	mesh = r.Mesh.ValueString()

	var name string
	name = r.Name.ValueString()

	out := operations.DeleteMeshLoadBalancingStrategyRequest{
		Mesh: mesh,
		Name: name,
	}

	return &out, diags
}

func (r *MeshLoadBalancingStrategyResourceModel) ToOperationsGetMeshLoadBalancingStrategyRequest(ctx context.Context) (*operations.GetMeshLoadBalancingStrategyRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var mesh string
	mesh = r.Mesh.ValueString()

	var name string
	name = r.Name.ValueString()

	out := operations.GetMeshLoadBalancingStrategyRequest{
		Mesh: mesh,
		Name: name,
	}

	return &out, diags
}

func (r *MeshLoadBalancingStrategyResourceModel) ToOperationsPutMeshLoadBalancingStrategyRequest(ctx context.Context) (*operations.PutMeshLoadBalancingStrategyRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var mesh string
	mesh = r.Mesh.ValueString()

	var name string
	name = r.Name.ValueString()

	meshLoadBalancingStrategyItem, meshLoadBalancingStrategyItemDiags := r.ToSharedMeshLoadBalancingStrategyItemInput(ctx)
	diags.Append(meshLoadBalancingStrategyItemDiags...)

	if diags.HasError() {
		return nil, diags
	}

	out := operations.PutMeshLoadBalancingStrategyRequest{
		Mesh:                          mesh,
		Name:                          name,
		MeshLoadBalancingStrategyItem: *meshLoadBalancingStrategyItem,
	}

	return &out, diags
}

func (r *MeshLoadBalancingStrategyResourceModel) ToSharedMeshLoadBalancingStrategyItemInput(ctx context.Context) (*shared.MeshLoadBalancingStrategyItemInput, diag.Diagnostics) {
	var diags diag.Diagnostics

	typeVar := shared.MeshLoadBalancingStrategyItemType(r.Type.ValueString())
	mesh := new(string)
	if !r.Mesh.IsUnknown() && !r.Mesh.IsNull() {
		*mesh = r.Mesh.ValueString()
	} else {
		mesh = nil
	}
	var name string
	name = r.Name.ValueString()

	var labels map[string]string
	if !r.Labels.IsUnknown() && !r.Labels.IsNull() {
		diags.Append(r.Labels.ElementsAs(ctx, &labels, true)...)
	}
	var targetRef *shared.MeshLoadBalancingStrategyItemTargetRef
	if r.Spec.TargetRef != nil {
		kind := shared.MeshLoadBalancingStrategyItemKind(r.Spec.TargetRef.Kind.ValueString())
		labels1 := make(map[string]string)
		for labelsKey, labelsValue := range r.Spec.TargetRef.Labels {
			var labelsInst string
			labelsInst = labelsValue.ValueString()

			labels1[labelsKey] = labelsInst
		}
		mesh1 := new(string)
		if !r.Spec.TargetRef.Mesh.IsUnknown() && !r.Spec.TargetRef.Mesh.IsNull() {
			*mesh1 = r.Spec.TargetRef.Mesh.ValueString()
		} else {
			mesh1 = nil
		}
		name1 := new(string)
		if !r.Spec.TargetRef.Name.IsUnknown() && !r.Spec.TargetRef.Name.IsNull() {
			*name1 = r.Spec.TargetRef.Name.ValueString()
		} else {
			name1 = nil
		}
		namespace := new(string)
		if !r.Spec.TargetRef.Namespace.IsUnknown() && !r.Spec.TargetRef.Namespace.IsNull() {
			*namespace = r.Spec.TargetRef.Namespace.ValueString()
		} else {
			namespace = nil
		}
		proxyTypes := make([]shared.MeshLoadBalancingStrategyItemProxyTypes, 0, len(r.Spec.TargetRef.ProxyTypes))
		for _, proxyTypesItem := range r.Spec.TargetRef.ProxyTypes {
			proxyTypes = append(proxyTypes, shared.MeshLoadBalancingStrategyItemProxyTypes(proxyTypesItem.ValueString()))
		}
		sectionName := new(string)
		if !r.Spec.TargetRef.SectionName.IsUnknown() && !r.Spec.TargetRef.SectionName.IsNull() {
			*sectionName = r.Spec.TargetRef.SectionName.ValueString()
		} else {
			sectionName = nil
		}
		tags := make(map[string]string)
		for tagsKey, tagsValue := range r.Spec.TargetRef.Tags {
			var tagsInst string
			tagsInst = tagsValue.ValueString()

			tags[tagsKey] = tagsInst
		}
		targetRef = &shared.MeshLoadBalancingStrategyItemTargetRef{
			Kind:        kind,
			Labels:      labels1,
			Mesh:        mesh1,
			Name:        name1,
			Namespace:   namespace,
			ProxyTypes:  proxyTypes,
			SectionName: sectionName,
			Tags:        tags,
		}
	}
	to := make([]shared.MeshLoadBalancingStrategyItemTo, 0, len(r.Spec.To))
	for _, toItem := range r.Spec.To {
		var defaultVar *shared.MeshLoadBalancingStrategyItemDefault
		if toItem.Default != nil {
			hashPolicies := make([]shared.HashPolicies, 0, len(toItem.Default.HashPolicies))
			for _, hashPoliciesItem := range toItem.Default.HashPolicies {
				var connection *shared.Connection
				if hashPoliciesItem.Connection != nil {
					sourceIP := new(bool)
					if !hashPoliciesItem.Connection.SourceIP.IsUnknown() && !hashPoliciesItem.Connection.SourceIP.IsNull() {
						*sourceIP = hashPoliciesItem.Connection.SourceIP.ValueBool()
					} else {
						sourceIP = nil
					}
					connection = &shared.Connection{
						SourceIP: sourceIP,
					}
				}
				var cookie *shared.Cookie
				if hashPoliciesItem.Cookie != nil {
					var name2 string
					name2 = hashPoliciesItem.Cookie.Name.ValueString()

					path := new(string)
					if !hashPoliciesItem.Cookie.Path.IsUnknown() && !hashPoliciesItem.Cookie.Path.IsNull() {
						*path = hashPoliciesItem.Cookie.Path.ValueString()
					} else {
						path = nil
					}
					ttl := new(string)
					if !hashPoliciesItem.Cookie.TTL.IsUnknown() && !hashPoliciesItem.Cookie.TTL.IsNull() {
						*ttl = hashPoliciesItem.Cookie.TTL.ValueString()
					} else {
						ttl = nil
					}
					cookie = &shared.Cookie{
						Name: name2,
						Path: path,
						TTL:  ttl,
					}
				}
				var filterState *shared.FilterState
				if hashPoliciesItem.FilterState != nil {
					var key string
					key = hashPoliciesItem.FilterState.Key.ValueString()

					filterState = &shared.FilterState{
						Key: key,
					}
				}
				var header *shared.MeshLoadBalancingStrategyItemHeader
				if hashPoliciesItem.Header != nil {
					var name3 string
					name3 = hashPoliciesItem.Header.Name.ValueString()

					header = &shared.MeshLoadBalancingStrategyItemHeader{
						Name: name3,
					}
				}
				var queryParameter *shared.QueryParameter
				if hashPoliciesItem.QueryParameter != nil {
					var name4 string
					name4 = hashPoliciesItem.QueryParameter.Name.ValueString()

					queryParameter = &shared.QueryParameter{
						Name: name4,
					}
				}
				terminal := new(bool)
				if !hashPoliciesItem.Terminal.IsUnknown() && !hashPoliciesItem.Terminal.IsNull() {
					*terminal = hashPoliciesItem.Terminal.ValueBool()
				} else {
					terminal = nil
				}
				type1 := shared.MeshLoadBalancingStrategyItemSpecType(hashPoliciesItem.Type.ValueString())
				hashPolicies = append(hashPolicies, shared.HashPolicies{
					Connection:     connection,
					Cookie:         cookie,
					FilterState:    filterState,
					Header:         header,
					QueryParameter: queryParameter,
					Terminal:       terminal,
					Type:           type1,
				})
			}
			var loadBalancer *shared.LoadBalancer
			if toItem.Default.LoadBalancer != nil {
				var leastRequest *shared.LeastRequest
				if toItem.Default.LoadBalancer.LeastRequest != nil {
					var activeRequestBias *shared.ActiveRequestBias
					if toItem.Default.LoadBalancer.LeastRequest.ActiveRequestBias != nil {
						integer := new(int64)
						if !toItem.Default.LoadBalancer.LeastRequest.ActiveRequestBias.Integer.IsUnknown() && !toItem.Default.LoadBalancer.LeastRequest.ActiveRequestBias.Integer.IsNull() {
							*integer = toItem.Default.LoadBalancer.LeastRequest.ActiveRequestBias.Integer.ValueInt64()
						} else {
							integer = nil
						}
						if integer != nil {
							activeRequestBias = &shared.ActiveRequestBias{
								Integer: integer,
							}
						}
						str := new(string)
						if !toItem.Default.LoadBalancer.LeastRequest.ActiveRequestBias.Str.IsUnknown() && !toItem.Default.LoadBalancer.LeastRequest.ActiveRequestBias.Str.IsNull() {
							*str = toItem.Default.LoadBalancer.LeastRequest.ActiveRequestBias.Str.ValueString()
						} else {
							str = nil
						}
						if str != nil {
							activeRequestBias = &shared.ActiveRequestBias{
								Str: str,
							}
						}
					}
					choiceCount := new(int)
					if !toItem.Default.LoadBalancer.LeastRequest.ChoiceCount.IsUnknown() && !toItem.Default.LoadBalancer.LeastRequest.ChoiceCount.IsNull() {
						*choiceCount = int(toItem.Default.LoadBalancer.LeastRequest.ChoiceCount.ValueInt32())
					} else {
						choiceCount = nil
					}
					leastRequest = &shared.LeastRequest{
						ActiveRequestBias: activeRequestBias,
						ChoiceCount:       choiceCount,
					}
				}
				var maglev *shared.Maglev
				if toItem.Default.LoadBalancer.Maglev != nil {
					hashPolicies1 := make([]shared.MeshLoadBalancingStrategyItemHashPolicies, 0, len(toItem.Default.LoadBalancer.Maglev.HashPolicies))
					for _, hashPoliciesItem1 := range toItem.Default.LoadBalancer.Maglev.HashPolicies {
						var connection1 *shared.MeshLoadBalancingStrategyItemConnection
						if hashPoliciesItem1.Connection != nil {
							sourceIp1 := new(bool)
							if !hashPoliciesItem1.Connection.SourceIP.IsUnknown() && !hashPoliciesItem1.Connection.SourceIP.IsNull() {
								*sourceIp1 = hashPoliciesItem1.Connection.SourceIP.ValueBool()
							} else {
								sourceIp1 = nil
							}
							connection1 = &shared.MeshLoadBalancingStrategyItemConnection{
								SourceIP: sourceIp1,
							}
						}
						var cookie1 *shared.MeshLoadBalancingStrategyItemCookie
						if hashPoliciesItem1.Cookie != nil {
							var name5 string
							name5 = hashPoliciesItem1.Cookie.Name.ValueString()

							path1 := new(string)
							if !hashPoliciesItem1.Cookie.Path.IsUnknown() && !hashPoliciesItem1.Cookie.Path.IsNull() {
								*path1 = hashPoliciesItem1.Cookie.Path.ValueString()
							} else {
								path1 = nil
							}
							ttl1 := new(string)
							if !hashPoliciesItem1.Cookie.TTL.IsUnknown() && !hashPoliciesItem1.Cookie.TTL.IsNull() {
								*ttl1 = hashPoliciesItem1.Cookie.TTL.ValueString()
							} else {
								ttl1 = nil
							}
							cookie1 = &shared.MeshLoadBalancingStrategyItemCookie{
								Name: name5,
								Path: path1,
								TTL:  ttl1,
							}
						}
						var filterState1 *shared.MeshLoadBalancingStrategyItemFilterState
						if hashPoliciesItem1.FilterState != nil {
							var key1 string
							key1 = hashPoliciesItem1.FilterState.Key.ValueString()

							filterState1 = &shared.MeshLoadBalancingStrategyItemFilterState{
								Key: key1,
							}
						}
						var header1 *shared.MeshLoadBalancingStrategyItemSpecToHeader
						if hashPoliciesItem1.Header != nil {
							var name6 string
							name6 = hashPoliciesItem1.Header.Name.ValueString()

							header1 = &shared.MeshLoadBalancingStrategyItemSpecToHeader{
								Name: name6,
							}
						}
						var queryParameter1 *shared.MeshLoadBalancingStrategyItemQueryParameter
						if hashPoliciesItem1.QueryParameter != nil {
							var name7 string
							name7 = hashPoliciesItem1.QueryParameter.Name.ValueString()

							queryParameter1 = &shared.MeshLoadBalancingStrategyItemQueryParameter{
								Name: name7,
							}
						}
						terminal1 := new(bool)
						if !hashPoliciesItem1.Terminal.IsUnknown() && !hashPoliciesItem1.Terminal.IsNull() {
							*terminal1 = hashPoliciesItem1.Terminal.ValueBool()
						} else {
							terminal1 = nil
						}
						type2 := shared.MeshLoadBalancingStrategyItemSpecToDefaultLoadBalancerType(hashPoliciesItem1.Type.ValueString())
						hashPolicies1 = append(hashPolicies1, shared.MeshLoadBalancingStrategyItemHashPolicies{
							Connection:     connection1,
							Cookie:         cookie1,
							FilterState:    filterState1,
							Header:         header1,
							QueryParameter: queryParameter1,
							Terminal:       terminal1,
							Type:           type2,
						})
					}
					tableSize := new(int)
					if !toItem.Default.LoadBalancer.Maglev.TableSize.IsUnknown() && !toItem.Default.LoadBalancer.Maglev.TableSize.IsNull() {
						*tableSize = int(toItem.Default.LoadBalancer.Maglev.TableSize.ValueInt32())
					} else {
						tableSize = nil
					}
					maglev = &shared.Maglev{
						HashPolicies: hashPolicies1,
						TableSize:    tableSize,
					}
				}
				var random *shared.MeshLoadBalancingStrategyItemRandom
				if toItem.Default.LoadBalancer.Random != nil {
					random = &shared.MeshLoadBalancingStrategyItemRandom{}
				}
				var ringHash *shared.RingHash
				if toItem.Default.LoadBalancer.RingHash != nil {
					hashFunction := new(shared.HashFunction)
					if !toItem.Default.LoadBalancer.RingHash.HashFunction.IsUnknown() && !toItem.Default.LoadBalancer.RingHash.HashFunction.IsNull() {
						*hashFunction = shared.HashFunction(toItem.Default.LoadBalancer.RingHash.HashFunction.ValueString())
					} else {
						hashFunction = nil
					}
					hashPolicies2 := make([]shared.MeshLoadBalancingStrategyItemSpecHashPolicies, 0, len(toItem.Default.LoadBalancer.RingHash.HashPolicies))
					for _, hashPoliciesItem2 := range toItem.Default.LoadBalancer.RingHash.HashPolicies {
						var connection2 *shared.MeshLoadBalancingStrategyItemSpecConnection
						if hashPoliciesItem2.Connection != nil {
							sourceIp2 := new(bool)
							if !hashPoliciesItem2.Connection.SourceIP.IsUnknown() && !hashPoliciesItem2.Connection.SourceIP.IsNull() {
								*sourceIp2 = hashPoliciesItem2.Connection.SourceIP.ValueBool()
							} else {
								sourceIp2 = nil
							}
							connection2 = &shared.MeshLoadBalancingStrategyItemSpecConnection{
								SourceIP: sourceIp2,
							}
						}
						var cookie2 *shared.MeshLoadBalancingStrategyItemSpecCookie
						if hashPoliciesItem2.Cookie != nil {
							var name8 string
							name8 = hashPoliciesItem2.Cookie.Name.ValueString()

							path2 := new(string)
							if !hashPoliciesItem2.Cookie.Path.IsUnknown() && !hashPoliciesItem2.Cookie.Path.IsNull() {
								*path2 = hashPoliciesItem2.Cookie.Path.ValueString()
							} else {
								path2 = nil
							}
							ttl2 := new(string)
							if !hashPoliciesItem2.Cookie.TTL.IsUnknown() && !hashPoliciesItem2.Cookie.TTL.IsNull() {
								*ttl2 = hashPoliciesItem2.Cookie.TTL.ValueString()
							} else {
								ttl2 = nil
							}
							cookie2 = &shared.MeshLoadBalancingStrategyItemSpecCookie{
								Name: name8,
								Path: path2,
								TTL:  ttl2,
							}
						}
						var filterState2 *shared.MeshLoadBalancingStrategyItemSpecFilterState
						if hashPoliciesItem2.FilterState != nil {
							var key2 string
							key2 = hashPoliciesItem2.FilterState.Key.ValueString()

							filterState2 = &shared.MeshLoadBalancingStrategyItemSpecFilterState{
								Key: key2,
							}
						}
						var header2 *shared.MeshLoadBalancingStrategyItemSpecHeader
						if hashPoliciesItem2.Header != nil {
							var name9 string
							name9 = hashPoliciesItem2.Header.Name.ValueString()

							header2 = &shared.MeshLoadBalancingStrategyItemSpecHeader{
								Name: name9,
							}
						}
						var queryParameter2 *shared.MeshLoadBalancingStrategyItemSpecQueryParameter
						if hashPoliciesItem2.QueryParameter != nil {
							var name10 string
							name10 = hashPoliciesItem2.QueryParameter.Name.ValueString()

							queryParameter2 = &shared.MeshLoadBalancingStrategyItemSpecQueryParameter{
								Name: name10,
							}
						}
						terminal2 := new(bool)
						if !hashPoliciesItem2.Terminal.IsUnknown() && !hashPoliciesItem2.Terminal.IsNull() {
							*terminal2 = hashPoliciesItem2.Terminal.ValueBool()
						} else {
							terminal2 = nil
						}
						type3 := shared.MeshLoadBalancingStrategyItemSpecToDefaultType(hashPoliciesItem2.Type.ValueString())
						hashPolicies2 = append(hashPolicies2, shared.MeshLoadBalancingStrategyItemSpecHashPolicies{
							Connection:     connection2,
							Cookie:         cookie2,
							FilterState:    filterState2,
							Header:         header2,
							QueryParameter: queryParameter2,
							Terminal:       terminal2,
							Type:           type3,
						})
					}
					maxRingSize := new(int)
					if !toItem.Default.LoadBalancer.RingHash.MaxRingSize.IsUnknown() && !toItem.Default.LoadBalancer.RingHash.MaxRingSize.IsNull() {
						*maxRingSize = int(toItem.Default.LoadBalancer.RingHash.MaxRingSize.ValueInt32())
					} else {
						maxRingSize = nil
					}
					minRingSize := new(int)
					if !toItem.Default.LoadBalancer.RingHash.MinRingSize.IsUnknown() && !toItem.Default.LoadBalancer.RingHash.MinRingSize.IsNull() {
						*minRingSize = int(toItem.Default.LoadBalancer.RingHash.MinRingSize.ValueInt32())
					} else {
						minRingSize = nil
					}
					ringHash = &shared.RingHash{
						HashFunction: hashFunction,
						HashPolicies: hashPolicies2,
						MaxRingSize:  maxRingSize,
						MinRingSize:  minRingSize,
					}
				}
				var roundRobin *shared.RoundRobin
				if toItem.Default.LoadBalancer.RoundRobin != nil {
					roundRobin = &shared.RoundRobin{}
				}
				typeVar1 := shared.MeshLoadBalancingStrategyItemSpecToType(toItem.Default.LoadBalancer.Type.ValueString())
				loadBalancer = &shared.LoadBalancer{
					LeastRequest: leastRequest,
					Maglev:       maglev,
					Random:       random,
					RingHash:     ringHash,
					RoundRobin:   roundRobin,
					Type:         typeVar1,
				}
			}
			var localityAwareness *shared.LocalityAwareness
			if toItem.Default.LocalityAwareness != nil {
				var crossZone *shared.CrossZone
				if toItem.Default.LocalityAwareness.CrossZone != nil {
					failover := make([]shared.Failover, 0, len(toItem.Default.LocalityAwareness.CrossZone.Failover))
					for _, failoverItem := range toItem.Default.LocalityAwareness.CrossZone.Failover {
						var from *shared.MeshLoadBalancingStrategyItemFrom
						if failoverItem.From != nil {
							zones := make([]string, 0, len(failoverItem.From.Zones))
							for _, zonesItem := range failoverItem.From.Zones {
								zones = append(zones, zonesItem.ValueString())
							}
							from = &shared.MeshLoadBalancingStrategyItemFrom{
								Zones: zones,
							}
						}
						typeVar2 := shared.MeshLoadBalancingStrategyItemSpecToDefaultLocalityAwarenessType(failoverItem.To.Type.ValueString())
						zones1 := make([]string, 0, len(failoverItem.To.Zones))
						for _, zonesItem1 := range failoverItem.To.Zones {
							zones1 = append(zones1, zonesItem1.ValueString())
						}
						to1 := shared.MeshLoadBalancingStrategyItemSpecTo{
							Type:  typeVar2,
							Zones: zones1,
						}
						failover = append(failover, shared.Failover{
							From: from,
							To:   to1,
						})
					}
					var failoverThreshold *shared.FailoverThreshold
					if toItem.Default.LocalityAwareness.CrossZone.FailoverThreshold != nil {
						var percentage shared.MeshLoadBalancingStrategyItemPercentage
						integer1 := new(int64)
						if !toItem.Default.LocalityAwareness.CrossZone.FailoverThreshold.Percentage.Integer.IsUnknown() && !toItem.Default.LocalityAwareness.CrossZone.FailoverThreshold.Percentage.Integer.IsNull() {
							*integer1 = toItem.Default.LocalityAwareness.CrossZone.FailoverThreshold.Percentage.Integer.ValueInt64()
						} else {
							integer1 = nil
						}
						if integer1 != nil {
							percentage = shared.MeshLoadBalancingStrategyItemPercentage{
								Integer: integer1,
							}
						}
						str1 := new(string)
						if !toItem.Default.LocalityAwareness.CrossZone.FailoverThreshold.Percentage.Str.IsUnknown() && !toItem.Default.LocalityAwareness.CrossZone.FailoverThreshold.Percentage.Str.IsNull() {
							*str1 = toItem.Default.LocalityAwareness.CrossZone.FailoverThreshold.Percentage.Str.ValueString()
						} else {
							str1 = nil
						}
						if str1 != nil {
							percentage = shared.MeshLoadBalancingStrategyItemPercentage{
								Str: str1,
							}
						}
						failoverThreshold = &shared.FailoverThreshold{
							Percentage: percentage,
						}
					}
					crossZone = &shared.CrossZone{
						Failover:          failover,
						FailoverThreshold: failoverThreshold,
					}
				}
				disabled := new(bool)
				if !toItem.Default.LocalityAwareness.Disabled.IsUnknown() && !toItem.Default.LocalityAwareness.Disabled.IsNull() {
					*disabled = toItem.Default.LocalityAwareness.Disabled.ValueBool()
				} else {
					disabled = nil
				}
				var localZone *shared.LocalZone
				if toItem.Default.LocalityAwareness.LocalZone != nil {
					affinityTags := make([]shared.AffinityTags, 0, len(toItem.Default.LocalityAwareness.LocalZone.AffinityTags))
					for _, affinityTagsItem := range toItem.Default.LocalityAwareness.LocalZone.AffinityTags {
						var key3 string
						key3 = affinityTagsItem.Key.ValueString()

						weight := new(int)
						if !affinityTagsItem.Weight.IsUnknown() && !affinityTagsItem.Weight.IsNull() {
							*weight = int(affinityTagsItem.Weight.ValueInt32())
						} else {
							weight = nil
						}
						affinityTags = append(affinityTags, shared.AffinityTags{
							Key:    key3,
							Weight: weight,
						})
					}
					localZone = &shared.LocalZone{
						AffinityTags: affinityTags,
					}
				}
				localityAwareness = &shared.LocalityAwareness{
					CrossZone: crossZone,
					Disabled:  disabled,
					LocalZone: localZone,
				}
			}
			defaultVar = &shared.MeshLoadBalancingStrategyItemDefault{
				HashPolicies:      hashPolicies,
				LoadBalancer:      loadBalancer,
				LocalityAwareness: localityAwareness,
			}
		}
		kind1 := shared.MeshLoadBalancingStrategyItemSpecKind(toItem.TargetRef.Kind.ValueString())
		labels2 := make(map[string]string)
		for labelsKey1, labelsValue1 := range toItem.TargetRef.Labels {
			var labelsInst1 string
			labelsInst1 = labelsValue1.ValueString()

			labels2[labelsKey1] = labelsInst1
		}
		mesh2 := new(string)
		if !toItem.TargetRef.Mesh.IsUnknown() && !toItem.TargetRef.Mesh.IsNull() {
			*mesh2 = toItem.TargetRef.Mesh.ValueString()
		} else {
			mesh2 = nil
		}
		name11 := new(string)
		if !toItem.TargetRef.Name.IsUnknown() && !toItem.TargetRef.Name.IsNull() {
			*name11 = toItem.TargetRef.Name.ValueString()
		} else {
			name11 = nil
		}
		namespace1 := new(string)
		if !toItem.TargetRef.Namespace.IsUnknown() && !toItem.TargetRef.Namespace.IsNull() {
			*namespace1 = toItem.TargetRef.Namespace.ValueString()
		} else {
			namespace1 = nil
		}
		proxyTypes1 := make([]shared.MeshLoadBalancingStrategyItemSpecProxyTypes, 0, len(toItem.TargetRef.ProxyTypes))
		for _, proxyTypesItem1 := range toItem.TargetRef.ProxyTypes {
			proxyTypes1 = append(proxyTypes1, shared.MeshLoadBalancingStrategyItemSpecProxyTypes(proxyTypesItem1.ValueString()))
		}
		sectionName1 := new(string)
		if !toItem.TargetRef.SectionName.IsUnknown() && !toItem.TargetRef.SectionName.IsNull() {
			*sectionName1 = toItem.TargetRef.SectionName.ValueString()
		} else {
			sectionName1 = nil
		}
		tags1 := make(map[string]string)
		for tagsKey1, tagsValue1 := range toItem.TargetRef.Tags {
			var tagsInst1 string
			tagsInst1 = tagsValue1.ValueString()

			tags1[tagsKey1] = tagsInst1
		}
		targetRef1 := shared.MeshLoadBalancingStrategyItemSpecTargetRef{
			Kind:        kind1,
			Labels:      labels2,
			Mesh:        mesh2,
			Name:        name11,
			Namespace:   namespace1,
			ProxyTypes:  proxyTypes1,
			SectionName: sectionName1,
			Tags:        tags1,
		}
		to = append(to, shared.MeshLoadBalancingStrategyItemTo{
			Default:   defaultVar,
			TargetRef: targetRef1,
		})
	}
	spec := shared.MeshLoadBalancingStrategyItemSpec{
		TargetRef: targetRef,
		To:        to,
	}
	out := shared.MeshLoadBalancingStrategyItemInput{
		Type:   typeVar,
		Mesh:   mesh,
		Name:   name,
		Labels: labels,
		Spec:   spec,
	}

	return &out, diags
}
