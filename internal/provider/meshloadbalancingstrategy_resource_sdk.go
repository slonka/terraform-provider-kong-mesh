// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package provider

import (
	"context"
	"github.com/Kong/shared-speakeasy/customtypes/kumalabels"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/kong/terraform-provider-kong-mesh/internal/provider/typeconvert"
	tfTypes "github.com/kong/terraform-provider-kong-mesh/internal/provider/types"
	"github.com/kong/terraform-provider-kong-mesh/internal/sdk/models/operations"
	"github.com/kong/terraform-provider-kong-mesh/internal/sdk/models/shared"
)

func (r *MeshLoadBalancingStrategyResourceModel) ToSharedMeshLoadBalancingStrategyItemInput(ctx context.Context) (*shared.MeshLoadBalancingStrategyItemInput, diag.Diagnostics) {
	var diags diag.Diagnostics

	typeVar := shared.MeshLoadBalancingStrategyItemType(r.Type.ValueString())
	mesh := new(string)
	if !r.Mesh.IsUnknown() && !r.Mesh.IsNull() {
		*mesh = r.Mesh.ValueString()
	} else {
		mesh = nil
	}
	var name string
	name = r.Name.ValueString()

	var labels map[string]string
	if !r.Labels.IsUnknown() && !r.Labels.IsNull() {
		diags.Append(r.Labels.ElementsAs(ctx, &labels, true)...)
	}
	var targetRef *shared.MeshLoadBalancingStrategyItemTargetRef
	if r.Spec.TargetRef != nil {
		kind := shared.MeshLoadBalancingStrategyItemKind(r.Spec.TargetRef.Kind.ValueString())
		labels1 := make(map[string]string)
		for labelsKey, labelsValue := range r.Spec.TargetRef.Labels {
			var labelsInst string
			labelsInst = labelsValue.ValueString()

			labels1[labelsKey] = labelsInst
		}
		mesh1 := new(string)
		if !r.Spec.TargetRef.Mesh.IsUnknown() && !r.Spec.TargetRef.Mesh.IsNull() {
			*mesh1 = r.Spec.TargetRef.Mesh.ValueString()
		} else {
			mesh1 = nil
		}
		name1 := new(string)
		if !r.Spec.TargetRef.Name.IsUnknown() && !r.Spec.TargetRef.Name.IsNull() {
			*name1 = r.Spec.TargetRef.Name.ValueString()
		} else {
			name1 = nil
		}
		namespace := new(string)
		if !r.Spec.TargetRef.Namespace.IsUnknown() && !r.Spec.TargetRef.Namespace.IsNull() {
			*namespace = r.Spec.TargetRef.Namespace.ValueString()
		} else {
			namespace = nil
		}
		proxyTypes := make([]shared.MeshLoadBalancingStrategyItemProxyTypes, 0, len(r.Spec.TargetRef.ProxyTypes))
		for _, proxyTypesItem := range r.Spec.TargetRef.ProxyTypes {
			proxyTypes = append(proxyTypes, shared.MeshLoadBalancingStrategyItemProxyTypes(proxyTypesItem.ValueString()))
		}
		sectionName := new(string)
		if !r.Spec.TargetRef.SectionName.IsUnknown() && !r.Spec.TargetRef.SectionName.IsNull() {
			*sectionName = r.Spec.TargetRef.SectionName.ValueString()
		} else {
			sectionName = nil
		}
		tags := make(map[string]string)
		for tagsKey, tagsValue := range r.Spec.TargetRef.Tags {
			var tagsInst string
			tagsInst = tagsValue.ValueString()

			tags[tagsKey] = tagsInst
		}
		targetRef = &shared.MeshLoadBalancingStrategyItemTargetRef{
			Kind:        kind,
			Labels:      labels1,
			Mesh:        mesh1,
			Name:        name1,
			Namespace:   namespace,
			ProxyTypes:  proxyTypes,
			SectionName: sectionName,
			Tags:        tags,
		}
	}
	to := make([]shared.MeshLoadBalancingStrategyItemTo, 0, len(r.Spec.To))
	for _, toItem := range r.Spec.To {
		var defaultVar *shared.MeshLoadBalancingStrategyItemDefault
		if toItem.Default != nil {
			var loadBalancer *shared.LoadBalancer
			if toItem.Default.LoadBalancer != nil {
				var leastRequest *shared.LeastRequest
				if toItem.Default.LoadBalancer.LeastRequest != nil {
					var activeRequestBias *shared.ActiveRequestBias
					if toItem.Default.LoadBalancer.LeastRequest.ActiveRequestBias != nil {
						integer := new(int64)
						if !toItem.Default.LoadBalancer.LeastRequest.ActiveRequestBias.Integer.IsUnknown() && !toItem.Default.LoadBalancer.LeastRequest.ActiveRequestBias.Integer.IsNull() {
							*integer = toItem.Default.LoadBalancer.LeastRequest.ActiveRequestBias.Integer.ValueInt64()
						} else {
							integer = nil
						}
						if integer != nil {
							activeRequestBias = &shared.ActiveRequestBias{
								Integer: integer,
							}
						}
						str := new(string)
						if !toItem.Default.LoadBalancer.LeastRequest.ActiveRequestBias.Str.IsUnknown() && !toItem.Default.LoadBalancer.LeastRequest.ActiveRequestBias.Str.IsNull() {
							*str = toItem.Default.LoadBalancer.LeastRequest.ActiveRequestBias.Str.ValueString()
						} else {
							str = nil
						}
						if str != nil {
							activeRequestBias = &shared.ActiveRequestBias{
								Str: str,
							}
						}
					}
					choiceCount := new(int)
					if !toItem.Default.LoadBalancer.LeastRequest.ChoiceCount.IsUnknown() && !toItem.Default.LoadBalancer.LeastRequest.ChoiceCount.IsNull() {
						*choiceCount = int(toItem.Default.LoadBalancer.LeastRequest.ChoiceCount.ValueInt32())
					} else {
						choiceCount = nil
					}
					leastRequest = &shared.LeastRequest{
						ActiveRequestBias: activeRequestBias,
						ChoiceCount:       choiceCount,
					}
				}
				var maglev *shared.Maglev
				if toItem.Default.LoadBalancer.Maglev != nil {
					hashPolicies := make([]shared.HashPolicies, 0, len(toItem.Default.LoadBalancer.Maglev.HashPolicies))
					for _, hashPoliciesItem := range toItem.Default.LoadBalancer.Maglev.HashPolicies {
						var connection *shared.Connection
						if hashPoliciesItem.Connection != nil {
							sourceIP := new(bool)
							if !hashPoliciesItem.Connection.SourceIP.IsUnknown() && !hashPoliciesItem.Connection.SourceIP.IsNull() {
								*sourceIP = hashPoliciesItem.Connection.SourceIP.ValueBool()
							} else {
								sourceIP = nil
							}
							connection = &shared.Connection{
								SourceIP: sourceIP,
							}
						}
						var cookie *shared.Cookie
						if hashPoliciesItem.Cookie != nil {
							var name2 string
							name2 = hashPoliciesItem.Cookie.Name.ValueString()

							path := new(string)
							if !hashPoliciesItem.Cookie.Path.IsUnknown() && !hashPoliciesItem.Cookie.Path.IsNull() {
								*path = hashPoliciesItem.Cookie.Path.ValueString()
							} else {
								path = nil
							}
							ttl := new(string)
							if !hashPoliciesItem.Cookie.TTL.IsUnknown() && !hashPoliciesItem.Cookie.TTL.IsNull() {
								*ttl = hashPoliciesItem.Cookie.TTL.ValueString()
							} else {
								ttl = nil
							}
							cookie = &shared.Cookie{
								Name: name2,
								Path: path,
								TTL:  ttl,
							}
						}
						var filterState *shared.FilterState
						if hashPoliciesItem.FilterState != nil {
							var key string
							key = hashPoliciesItem.FilterState.Key.ValueString()

							filterState = &shared.FilterState{
								Key: key,
							}
						}
						var header *shared.MeshLoadBalancingStrategyItemSpecHeader
						if hashPoliciesItem.Header != nil {
							var name3 string
							name3 = hashPoliciesItem.Header.Name.ValueString()

							header = &shared.MeshLoadBalancingStrategyItemSpecHeader{
								Name: name3,
							}
						}
						var queryParameter *shared.QueryParameter
						if hashPoliciesItem.QueryParameter != nil {
							var name4 string
							name4 = hashPoliciesItem.QueryParameter.Name.ValueString()

							queryParameter = &shared.QueryParameter{
								Name: name4,
							}
						}
						terminal := new(bool)
						if !hashPoliciesItem.Terminal.IsUnknown() && !hashPoliciesItem.Terminal.IsNull() {
							*terminal = hashPoliciesItem.Terminal.ValueBool()
						} else {
							terminal = nil
						}
						type1 := shared.MeshLoadBalancingStrategyItemSpecToDefaultType(hashPoliciesItem.Type.ValueString())
						hashPolicies = append(hashPolicies, shared.HashPolicies{
							Connection:     connection,
							Cookie:         cookie,
							FilterState:    filterState,
							Header:         header,
							QueryParameter: queryParameter,
							Terminal:       terminal,
							Type:           type1,
						})
					}
					tableSize := new(int)
					if !toItem.Default.LoadBalancer.Maglev.TableSize.IsUnknown() && !toItem.Default.LoadBalancer.Maglev.TableSize.IsNull() {
						*tableSize = int(toItem.Default.LoadBalancer.Maglev.TableSize.ValueInt32())
					} else {
						tableSize = nil
					}
					maglev = &shared.Maglev{
						HashPolicies: hashPolicies,
						TableSize:    tableSize,
					}
				}
				var random *shared.MeshLoadBalancingStrategyItemRandom
				if toItem.Default.LoadBalancer.Random != nil {
					random = &shared.MeshLoadBalancingStrategyItemRandom{}
				}
				var ringHash *shared.RingHash
				if toItem.Default.LoadBalancer.RingHash != nil {
					hashFunction := new(shared.HashFunction)
					if !toItem.Default.LoadBalancer.RingHash.HashFunction.IsUnknown() && !toItem.Default.LoadBalancer.RingHash.HashFunction.IsNull() {
						*hashFunction = shared.HashFunction(toItem.Default.LoadBalancer.RingHash.HashFunction.ValueString())
					} else {
						hashFunction = nil
					}
					hashPolicies1 := make([]shared.MeshLoadBalancingStrategyItemHashPolicies, 0, len(toItem.Default.LoadBalancer.RingHash.HashPolicies))
					for _, hashPoliciesItem1 := range toItem.Default.LoadBalancer.RingHash.HashPolicies {
						var connection1 *shared.MeshLoadBalancingStrategyItemConnection
						if hashPoliciesItem1.Connection != nil {
							sourceIp1 := new(bool)
							if !hashPoliciesItem1.Connection.SourceIP.IsUnknown() && !hashPoliciesItem1.Connection.SourceIP.IsNull() {
								*sourceIp1 = hashPoliciesItem1.Connection.SourceIP.ValueBool()
							} else {
								sourceIp1 = nil
							}
							connection1 = &shared.MeshLoadBalancingStrategyItemConnection{
								SourceIP: sourceIp1,
							}
						}
						var cookie1 *shared.MeshLoadBalancingStrategyItemCookie
						if hashPoliciesItem1.Cookie != nil {
							var name5 string
							name5 = hashPoliciesItem1.Cookie.Name.ValueString()

							path1 := new(string)
							if !hashPoliciesItem1.Cookie.Path.IsUnknown() && !hashPoliciesItem1.Cookie.Path.IsNull() {
								*path1 = hashPoliciesItem1.Cookie.Path.ValueString()
							} else {
								path1 = nil
							}
							ttl1 := new(string)
							if !hashPoliciesItem1.Cookie.TTL.IsUnknown() && !hashPoliciesItem1.Cookie.TTL.IsNull() {
								*ttl1 = hashPoliciesItem1.Cookie.TTL.ValueString()
							} else {
								ttl1 = nil
							}
							cookie1 = &shared.MeshLoadBalancingStrategyItemCookie{
								Name: name5,
								Path: path1,
								TTL:  ttl1,
							}
						}
						var filterState1 *shared.MeshLoadBalancingStrategyItemFilterState
						if hashPoliciesItem1.FilterState != nil {
							var key1 string
							key1 = hashPoliciesItem1.FilterState.Key.ValueString()

							filterState1 = &shared.MeshLoadBalancingStrategyItemFilterState{
								Key: key1,
							}
						}
						var header1 *shared.MeshLoadBalancingStrategyItemHeader
						if hashPoliciesItem1.Header != nil {
							var name6 string
							name6 = hashPoliciesItem1.Header.Name.ValueString()

							header1 = &shared.MeshLoadBalancingStrategyItemHeader{
								Name: name6,
							}
						}
						var queryParameter1 *shared.MeshLoadBalancingStrategyItemQueryParameter
						if hashPoliciesItem1.QueryParameter != nil {
							var name7 string
							name7 = hashPoliciesItem1.QueryParameter.Name.ValueString()

							queryParameter1 = &shared.MeshLoadBalancingStrategyItemQueryParameter{
								Name: name7,
							}
						}
						terminal1 := new(bool)
						if !hashPoliciesItem1.Terminal.IsUnknown() && !hashPoliciesItem1.Terminal.IsNull() {
							*terminal1 = hashPoliciesItem1.Terminal.ValueBool()
						} else {
							terminal1 = nil
						}
						type2 := shared.MeshLoadBalancingStrategyItemSpecToType(hashPoliciesItem1.Type.ValueString())
						hashPolicies1 = append(hashPolicies1, shared.MeshLoadBalancingStrategyItemHashPolicies{
							Connection:     connection1,
							Cookie:         cookie1,
							FilterState:    filterState1,
							Header:         header1,
							QueryParameter: queryParameter1,
							Terminal:       terminal1,
							Type:           type2,
						})
					}
					maxRingSize := new(int)
					if !toItem.Default.LoadBalancer.RingHash.MaxRingSize.IsUnknown() && !toItem.Default.LoadBalancer.RingHash.MaxRingSize.IsNull() {
						*maxRingSize = int(toItem.Default.LoadBalancer.RingHash.MaxRingSize.ValueInt32())
					} else {
						maxRingSize = nil
					}
					minRingSize := new(int)
					if !toItem.Default.LoadBalancer.RingHash.MinRingSize.IsUnknown() && !toItem.Default.LoadBalancer.RingHash.MinRingSize.IsNull() {
						*minRingSize = int(toItem.Default.LoadBalancer.RingHash.MinRingSize.ValueInt32())
					} else {
						minRingSize = nil
					}
					ringHash = &shared.RingHash{
						HashFunction: hashFunction,
						HashPolicies: hashPolicies1,
						MaxRingSize:  maxRingSize,
						MinRingSize:  minRingSize,
					}
				}
				var roundRobin *shared.RoundRobin
				if toItem.Default.LoadBalancer.RoundRobin != nil {
					roundRobin = &shared.RoundRobin{}
				}
				typeVar1 := shared.MeshLoadBalancingStrategyItemSpecType(toItem.Default.LoadBalancer.Type.ValueString())
				loadBalancer = &shared.LoadBalancer{
					LeastRequest: leastRequest,
					Maglev:       maglev,
					Random:       random,
					RingHash:     ringHash,
					RoundRobin:   roundRobin,
					Type:         typeVar1,
				}
			}
			var localityAwareness *shared.LocalityAwareness
			if toItem.Default.LocalityAwareness != nil {
				var crossZone *shared.CrossZone
				if toItem.Default.LocalityAwareness.CrossZone != nil {
					failover := make([]shared.Failover, 0, len(toItem.Default.LocalityAwareness.CrossZone.Failover))
					for _, failoverItem := range toItem.Default.LocalityAwareness.CrossZone.Failover {
						var from *shared.MeshLoadBalancingStrategyItemFrom
						if failoverItem.From != nil {
							zones := make([]string, 0, len(failoverItem.From.Zones))
							for _, zonesItem := range failoverItem.From.Zones {
								zones = append(zones, zonesItem.ValueString())
							}
							from = &shared.MeshLoadBalancingStrategyItemFrom{
								Zones: zones,
							}
						}
						typeVar2 := shared.MeshLoadBalancingStrategyItemSpecToDefaultLocalityAwarenessType(failoverItem.To.Type.ValueString())
						zones1 := make([]string, 0, len(failoverItem.To.Zones))
						for _, zonesItem1 := range failoverItem.To.Zones {
							zones1 = append(zones1, zonesItem1.ValueString())
						}
						to1 := shared.MeshLoadBalancingStrategyItemSpecTo{
							Type:  typeVar2,
							Zones: zones1,
						}
						failover = append(failover, shared.Failover{
							From: from,
							To:   to1,
						})
					}
					var failoverThreshold *shared.FailoverThreshold
					if toItem.Default.LocalityAwareness.CrossZone.FailoverThreshold != nil {
						var percentage shared.MeshLoadBalancingStrategyItemPercentage
						integer1 := new(int64)
						if !toItem.Default.LocalityAwareness.CrossZone.FailoverThreshold.Percentage.Integer.IsUnknown() && !toItem.Default.LocalityAwareness.CrossZone.FailoverThreshold.Percentage.Integer.IsNull() {
							*integer1 = toItem.Default.LocalityAwareness.CrossZone.FailoverThreshold.Percentage.Integer.ValueInt64()
						} else {
							integer1 = nil
						}
						if integer1 != nil {
							percentage = shared.MeshLoadBalancingStrategyItemPercentage{
								Integer: integer1,
							}
						}
						str1 := new(string)
						if !toItem.Default.LocalityAwareness.CrossZone.FailoverThreshold.Percentage.Str.IsUnknown() && !toItem.Default.LocalityAwareness.CrossZone.FailoverThreshold.Percentage.Str.IsNull() {
							*str1 = toItem.Default.LocalityAwareness.CrossZone.FailoverThreshold.Percentage.Str.ValueString()
						} else {
							str1 = nil
						}
						if str1 != nil {
							percentage = shared.MeshLoadBalancingStrategyItemPercentage{
								Str: str1,
							}
						}
						failoverThreshold = &shared.FailoverThreshold{
							Percentage: percentage,
						}
					}
					crossZone = &shared.CrossZone{
						Failover:          failover,
						FailoverThreshold: failoverThreshold,
					}
				}
				disabled := new(bool)
				if !toItem.Default.LocalityAwareness.Disabled.IsUnknown() && !toItem.Default.LocalityAwareness.Disabled.IsNull() {
					*disabled = toItem.Default.LocalityAwareness.Disabled.ValueBool()
				} else {
					disabled = nil
				}
				var localZone *shared.LocalZone
				if toItem.Default.LocalityAwareness.LocalZone != nil {
					affinityTags := make([]shared.AffinityTags, 0, len(toItem.Default.LocalityAwareness.LocalZone.AffinityTags))
					for _, affinityTagsItem := range toItem.Default.LocalityAwareness.LocalZone.AffinityTags {
						var key2 string
						key2 = affinityTagsItem.Key.ValueString()

						weight := new(int)
						if !affinityTagsItem.Weight.IsUnknown() && !affinityTagsItem.Weight.IsNull() {
							*weight = int(affinityTagsItem.Weight.ValueInt32())
						} else {
							weight = nil
						}
						affinityTags = append(affinityTags, shared.AffinityTags{
							Key:    key2,
							Weight: weight,
						})
					}
					localZone = &shared.LocalZone{
						AffinityTags: affinityTags,
					}
				}
				localityAwareness = &shared.LocalityAwareness{
					CrossZone: crossZone,
					Disabled:  disabled,
					LocalZone: localZone,
				}
			}
			defaultVar = &shared.MeshLoadBalancingStrategyItemDefault{
				LoadBalancer:      loadBalancer,
				LocalityAwareness: localityAwareness,
			}
		}
		kind1 := shared.MeshLoadBalancingStrategyItemSpecKind(toItem.TargetRef.Kind.ValueString())
		labels2 := make(map[string]string)
		for labelsKey1, labelsValue1 := range toItem.TargetRef.Labels {
			var labelsInst1 string
			labelsInst1 = labelsValue1.ValueString()

			labels2[labelsKey1] = labelsInst1
		}
		mesh2 := new(string)
		if !toItem.TargetRef.Mesh.IsUnknown() && !toItem.TargetRef.Mesh.IsNull() {
			*mesh2 = toItem.TargetRef.Mesh.ValueString()
		} else {
			mesh2 = nil
		}
		name8 := new(string)
		if !toItem.TargetRef.Name.IsUnknown() && !toItem.TargetRef.Name.IsNull() {
			*name8 = toItem.TargetRef.Name.ValueString()
		} else {
			name8 = nil
		}
		namespace1 := new(string)
		if !toItem.TargetRef.Namespace.IsUnknown() && !toItem.TargetRef.Namespace.IsNull() {
			*namespace1 = toItem.TargetRef.Namespace.ValueString()
		} else {
			namespace1 = nil
		}
		proxyTypes1 := make([]shared.MeshLoadBalancingStrategyItemSpecProxyTypes, 0, len(toItem.TargetRef.ProxyTypes))
		for _, proxyTypesItem1 := range toItem.TargetRef.ProxyTypes {
			proxyTypes1 = append(proxyTypes1, shared.MeshLoadBalancingStrategyItemSpecProxyTypes(proxyTypesItem1.ValueString()))
		}
		sectionName1 := new(string)
		if !toItem.TargetRef.SectionName.IsUnknown() && !toItem.TargetRef.SectionName.IsNull() {
			*sectionName1 = toItem.TargetRef.SectionName.ValueString()
		} else {
			sectionName1 = nil
		}
		tags1 := make(map[string]string)
		for tagsKey1, tagsValue1 := range toItem.TargetRef.Tags {
			var tagsInst1 string
			tagsInst1 = tagsValue1.ValueString()

			tags1[tagsKey1] = tagsInst1
		}
		targetRef1 := shared.MeshLoadBalancingStrategyItemSpecTargetRef{
			Kind:        kind1,
			Labels:      labels2,
			Mesh:        mesh2,
			Name:        name8,
			Namespace:   namespace1,
			ProxyTypes:  proxyTypes1,
			SectionName: sectionName1,
			Tags:        tags1,
		}
		to = append(to, shared.MeshLoadBalancingStrategyItemTo{
			Default:   defaultVar,
			TargetRef: targetRef1,
		})
	}
	spec := shared.MeshLoadBalancingStrategyItemSpec{
		TargetRef: targetRef,
		To:        to,
	}
	out := shared.MeshLoadBalancingStrategyItemInput{
		Type:   typeVar,
		Mesh:   mesh,
		Name:   name,
		Labels: labels,
		Spec:   spec,
	}

	return &out, diags
}

func (r *MeshLoadBalancingStrategyResourceModel) ToOperationsCreateMeshLoadBalancingStrategyRequest(ctx context.Context) (*operations.CreateMeshLoadBalancingStrategyRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var mesh string
	mesh = r.Mesh.ValueString()

	var name string
	name = r.Name.ValueString()

	meshLoadBalancingStrategyItem, meshLoadBalancingStrategyItemDiags := r.ToSharedMeshLoadBalancingStrategyItemInput(ctx)
	diags.Append(meshLoadBalancingStrategyItemDiags...)

	if diags.HasError() {
		return nil, diags
	}

	out := operations.CreateMeshLoadBalancingStrategyRequest{
		Mesh:                          mesh,
		Name:                          name,
		MeshLoadBalancingStrategyItem: *meshLoadBalancingStrategyItem,
	}

	return &out, diags
}

func (r *MeshLoadBalancingStrategyResourceModel) ToOperationsUpdateMeshLoadBalancingStrategyRequest(ctx context.Context) (*operations.UpdateMeshLoadBalancingStrategyRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var mesh string
	mesh = r.Mesh.ValueString()

	var name string
	name = r.Name.ValueString()

	meshLoadBalancingStrategyItem, meshLoadBalancingStrategyItemDiags := r.ToSharedMeshLoadBalancingStrategyItemInput(ctx)
	diags.Append(meshLoadBalancingStrategyItemDiags...)

	if diags.HasError() {
		return nil, diags
	}

	out := operations.UpdateMeshLoadBalancingStrategyRequest{
		Mesh:                          mesh,
		Name:                          name,
		MeshLoadBalancingStrategyItem: *meshLoadBalancingStrategyItem,
	}

	return &out, diags
}

func (r *MeshLoadBalancingStrategyResourceModel) ToOperationsGetMeshLoadBalancingStrategyRequest(ctx context.Context) (*operations.GetMeshLoadBalancingStrategyRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var mesh string
	mesh = r.Mesh.ValueString()

	var name string
	name = r.Name.ValueString()

	out := operations.GetMeshLoadBalancingStrategyRequest{
		Mesh: mesh,
		Name: name,
	}

	return &out, diags
}

func (r *MeshLoadBalancingStrategyResourceModel) ToOperationsDeleteMeshLoadBalancingStrategyRequest(ctx context.Context) (*operations.DeleteMeshLoadBalancingStrategyRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var mesh string
	mesh = r.Mesh.ValueString()

	var name string
	name = r.Name.ValueString()

	out := operations.DeleteMeshLoadBalancingStrategyRequest{
		Mesh: mesh,
		Name: name,
	}

	return &out, diags
}

func (r *MeshLoadBalancingStrategyResourceModel) RefreshFromSharedMeshLoadBalancingStrategyCreateOrUpdateSuccessResponse(ctx context.Context, resp *shared.MeshLoadBalancingStrategyCreateOrUpdateSuccessResponse) diag.Diagnostics {
	var diags diag.Diagnostics

	if resp != nil {
		r.Warnings = make([]types.String, 0, len(resp.Warnings))
		for _, v := range resp.Warnings {
			r.Warnings = append(r.Warnings, types.StringValue(v))
		}
	}

	return diags
}

func (r *MeshLoadBalancingStrategyResourceModel) RefreshFromSharedMeshLoadBalancingStrategyItem(ctx context.Context, resp *shared.MeshLoadBalancingStrategyItem) diag.Diagnostics {
	var diags diag.Diagnostics

	if resp != nil {
		r.CreationTime = types.StringPointerValue(typeconvert.TimePointerToStringPointer(resp.CreationTime))
		labelsValue, labelsDiags := types.MapValueFrom(ctx, types.StringType, resp.Labels)
		diags.Append(labelsDiags...)
		labelsValuable, labelsDiags := kumalabels.KumaLabelsMapType{MapType: types.MapType{ElemType: types.StringType}}.ValueFromMap(ctx, labelsValue)
		diags.Append(labelsDiags...)
		r.Labels, _ = labelsValuable.(kumalabels.KumaLabelsMapValue)
		r.Mesh = types.StringPointerValue(resp.Mesh)
		r.ModificationTime = types.StringPointerValue(typeconvert.TimePointerToStringPointer(resp.ModificationTime))
		r.Name = types.StringValue(resp.Name)
		if resp.Spec.TargetRef == nil {
			r.Spec.TargetRef = nil
		} else {
			r.Spec.TargetRef = &tfTypes.MeshAccessLogItemTargetRef{}
			r.Spec.TargetRef.Kind = types.StringValue(string(resp.Spec.TargetRef.Kind))
			if len(resp.Spec.TargetRef.Labels) > 0 {
				r.Spec.TargetRef.Labels = make(map[string]types.String, len(resp.Spec.TargetRef.Labels))
				for key, value := range resp.Spec.TargetRef.Labels {
					r.Spec.TargetRef.Labels[key] = types.StringValue(value)
				}
			}
			r.Spec.TargetRef.Mesh = types.StringPointerValue(resp.Spec.TargetRef.Mesh)
			r.Spec.TargetRef.Name = types.StringPointerValue(resp.Spec.TargetRef.Name)
			r.Spec.TargetRef.Namespace = types.StringPointerValue(resp.Spec.TargetRef.Namespace)
			r.Spec.TargetRef.ProxyTypes = make([]types.String, 0, len(resp.Spec.TargetRef.ProxyTypes))
			for _, v := range resp.Spec.TargetRef.ProxyTypes {
				r.Spec.TargetRef.ProxyTypes = append(r.Spec.TargetRef.ProxyTypes, types.StringValue(string(v)))
			}
			r.Spec.TargetRef.SectionName = types.StringPointerValue(resp.Spec.TargetRef.SectionName)
			if len(resp.Spec.TargetRef.Tags) > 0 {
				r.Spec.TargetRef.Tags = make(map[string]types.String, len(resp.Spec.TargetRef.Tags))
				for key1, value1 := range resp.Spec.TargetRef.Tags {
					r.Spec.TargetRef.Tags[key1] = types.StringValue(value1)
				}
			}
		}
		r.Spec.To = []tfTypes.MeshLoadBalancingStrategyItemTo{}
		if len(r.Spec.To) > len(resp.Spec.To) {
			r.Spec.To = r.Spec.To[:len(resp.Spec.To)]
		}
		for toCount, toItem := range resp.Spec.To {
			var to tfTypes.MeshLoadBalancingStrategyItemTo
			if toItem.Default == nil {
				to.Default = nil
			} else {
				to.Default = &tfTypes.MeshLoadBalancingStrategyItemDefault{}
				if toItem.Default.LoadBalancer == nil {
					to.Default.LoadBalancer = nil
				} else {
					to.Default.LoadBalancer = &tfTypes.LoadBalancer{}
					if toItem.Default.LoadBalancer.LeastRequest == nil {
						to.Default.LoadBalancer.LeastRequest = nil
					} else {
						to.Default.LoadBalancer.LeastRequest = &tfTypes.LeastRequest{}
						if toItem.Default.LoadBalancer.LeastRequest.ActiveRequestBias != nil {
							to.Default.LoadBalancer.LeastRequest.ActiveRequestBias = &tfTypes.ConfMode{}
							if toItem.Default.LoadBalancer.LeastRequest.ActiveRequestBias.Integer != nil {
								to.Default.LoadBalancer.LeastRequest.ActiveRequestBias.Integer = types.Int64PointerValue(toItem.Default.LoadBalancer.LeastRequest.ActiveRequestBias.Integer)
							}
							if toItem.Default.LoadBalancer.LeastRequest.ActiveRequestBias.Str != nil {
								to.Default.LoadBalancer.LeastRequest.ActiveRequestBias.Str = types.StringPointerValue(toItem.Default.LoadBalancer.LeastRequest.ActiveRequestBias.Str)
							}
						}
						to.Default.LoadBalancer.LeastRequest.ChoiceCount = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(toItem.Default.LoadBalancer.LeastRequest.ChoiceCount))
					}
					if toItem.Default.LoadBalancer.Maglev == nil {
						to.Default.LoadBalancer.Maglev = nil
					} else {
						to.Default.LoadBalancer.Maglev = &tfTypes.Maglev{}
						to.Default.LoadBalancer.Maglev.HashPolicies = []tfTypes.HashPolicies{}
						for hashPoliciesCount, hashPoliciesItem := range toItem.Default.LoadBalancer.Maglev.HashPolicies {
							var hashPolicies tfTypes.HashPolicies
							if hashPoliciesItem.Connection == nil {
								hashPolicies.Connection = nil
							} else {
								hashPolicies.Connection = &tfTypes.Connection{}
								hashPolicies.Connection.SourceIP = types.BoolPointerValue(hashPoliciesItem.Connection.SourceIP)
							}
							if hashPoliciesItem.Cookie == nil {
								hashPolicies.Cookie = nil
							} else {
								hashPolicies.Cookie = &tfTypes.Cookie{}
								hashPolicies.Cookie.Name = types.StringValue(hashPoliciesItem.Cookie.Name)
								hashPolicies.Cookie.Path = types.StringPointerValue(hashPoliciesItem.Cookie.Path)
								hashPolicies.Cookie.TTL = types.StringPointerValue(hashPoliciesItem.Cookie.TTL)
							}
							if hashPoliciesItem.FilterState == nil {
								hashPolicies.FilterState = nil
							} else {
								hashPolicies.FilterState = &tfTypes.FilterState{}
								hashPolicies.FilterState.Key = types.StringValue(hashPoliciesItem.FilterState.Key)
							}
							if hashPoliciesItem.Header == nil {
								hashPolicies.Header = nil
							} else {
								hashPolicies.Header = &tfTypes.MeshLoadBalancingStrategyItemSpecHeader{}
								hashPolicies.Header.Name = types.StringValue(hashPoliciesItem.Header.Name)
							}
							if hashPoliciesItem.QueryParameter == nil {
								hashPolicies.QueryParameter = nil
							} else {
								hashPolicies.QueryParameter = &tfTypes.MeshLoadBalancingStrategyItemSpecHeader{}
								hashPolicies.QueryParameter.Name = types.StringValue(hashPoliciesItem.QueryParameter.Name)
							}
							hashPolicies.Terminal = types.BoolPointerValue(hashPoliciesItem.Terminal)
							hashPolicies.Type = types.StringValue(string(hashPoliciesItem.Type))
							if hashPoliciesCount+1 > len(to.Default.LoadBalancer.Maglev.HashPolicies) {
								to.Default.LoadBalancer.Maglev.HashPolicies = append(to.Default.LoadBalancer.Maglev.HashPolicies, hashPolicies)
							} else {
								to.Default.LoadBalancer.Maglev.HashPolicies[hashPoliciesCount].Connection = hashPolicies.Connection
								to.Default.LoadBalancer.Maglev.HashPolicies[hashPoliciesCount].Cookie = hashPolicies.Cookie
								to.Default.LoadBalancer.Maglev.HashPolicies[hashPoliciesCount].FilterState = hashPolicies.FilterState
								to.Default.LoadBalancer.Maglev.HashPolicies[hashPoliciesCount].Header = hashPolicies.Header
								to.Default.LoadBalancer.Maglev.HashPolicies[hashPoliciesCount].QueryParameter = hashPolicies.QueryParameter
								to.Default.LoadBalancer.Maglev.HashPolicies[hashPoliciesCount].Terminal = hashPolicies.Terminal
								to.Default.LoadBalancer.Maglev.HashPolicies[hashPoliciesCount].Type = hashPolicies.Type
							}
						}
						to.Default.LoadBalancer.Maglev.TableSize = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(toItem.Default.LoadBalancer.Maglev.TableSize))
					}
					if toItem.Default.LoadBalancer.Random == nil {
						to.Default.LoadBalancer.Random = nil
					} else {
						to.Default.LoadBalancer.Random = &tfTypes.DataplaneItemTCP{}
					}
					if toItem.Default.LoadBalancer.RingHash == nil {
						to.Default.LoadBalancer.RingHash = nil
					} else {
						to.Default.LoadBalancer.RingHash = &tfTypes.RingHash{}
						if toItem.Default.LoadBalancer.RingHash.HashFunction != nil {
							to.Default.LoadBalancer.RingHash.HashFunction = types.StringValue(string(*toItem.Default.LoadBalancer.RingHash.HashFunction))
						} else {
							to.Default.LoadBalancer.RingHash.HashFunction = types.StringNull()
						}
						to.Default.LoadBalancer.RingHash.HashPolicies = []tfTypes.HashPolicies{}
						for hashPoliciesCount1, hashPoliciesItem1 := range toItem.Default.LoadBalancer.RingHash.HashPolicies {
							var hashPolicies1 tfTypes.HashPolicies
							if hashPoliciesItem1.Connection == nil {
								hashPolicies1.Connection = nil
							} else {
								hashPolicies1.Connection = &tfTypes.Connection{}
								hashPolicies1.Connection.SourceIP = types.BoolPointerValue(hashPoliciesItem1.Connection.SourceIP)
							}
							if hashPoliciesItem1.Cookie == nil {
								hashPolicies1.Cookie = nil
							} else {
								hashPolicies1.Cookie = &tfTypes.Cookie{}
								hashPolicies1.Cookie.Name = types.StringValue(hashPoliciesItem1.Cookie.Name)
								hashPolicies1.Cookie.Path = types.StringPointerValue(hashPoliciesItem1.Cookie.Path)
								hashPolicies1.Cookie.TTL = types.StringPointerValue(hashPoliciesItem1.Cookie.TTL)
							}
							if hashPoliciesItem1.FilterState == nil {
								hashPolicies1.FilterState = nil
							} else {
								hashPolicies1.FilterState = &tfTypes.FilterState{}
								hashPolicies1.FilterState.Key = types.StringValue(hashPoliciesItem1.FilterState.Key)
							}
							if hashPoliciesItem1.Header == nil {
								hashPolicies1.Header = nil
							} else {
								hashPolicies1.Header = &tfTypes.MeshLoadBalancingStrategyItemSpecHeader{}
								hashPolicies1.Header.Name = types.StringValue(hashPoliciesItem1.Header.Name)
							}
							if hashPoliciesItem1.QueryParameter == nil {
								hashPolicies1.QueryParameter = nil
							} else {
								hashPolicies1.QueryParameter = &tfTypes.MeshLoadBalancingStrategyItemSpecHeader{}
								hashPolicies1.QueryParameter.Name = types.StringValue(hashPoliciesItem1.QueryParameter.Name)
							}
							hashPolicies1.Terminal = types.BoolPointerValue(hashPoliciesItem1.Terminal)
							hashPolicies1.Type = types.StringValue(string(hashPoliciesItem1.Type))
							if hashPoliciesCount1+1 > len(to.Default.LoadBalancer.RingHash.HashPolicies) {
								to.Default.LoadBalancer.RingHash.HashPolicies = append(to.Default.LoadBalancer.RingHash.HashPolicies, hashPolicies1)
							} else {
								to.Default.LoadBalancer.RingHash.HashPolicies[hashPoliciesCount1].Connection = hashPolicies1.Connection
								to.Default.LoadBalancer.RingHash.HashPolicies[hashPoliciesCount1].Cookie = hashPolicies1.Cookie
								to.Default.LoadBalancer.RingHash.HashPolicies[hashPoliciesCount1].FilterState = hashPolicies1.FilterState
								to.Default.LoadBalancer.RingHash.HashPolicies[hashPoliciesCount1].Header = hashPolicies1.Header
								to.Default.LoadBalancer.RingHash.HashPolicies[hashPoliciesCount1].QueryParameter = hashPolicies1.QueryParameter
								to.Default.LoadBalancer.RingHash.HashPolicies[hashPoliciesCount1].Terminal = hashPolicies1.Terminal
								to.Default.LoadBalancer.RingHash.HashPolicies[hashPoliciesCount1].Type = hashPolicies1.Type
							}
						}
						to.Default.LoadBalancer.RingHash.MaxRingSize = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(toItem.Default.LoadBalancer.RingHash.MaxRingSize))
						to.Default.LoadBalancer.RingHash.MinRingSize = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(toItem.Default.LoadBalancer.RingHash.MinRingSize))
					}
					if toItem.Default.LoadBalancer.RoundRobin == nil {
						to.Default.LoadBalancer.RoundRobin = nil
					} else {
						to.Default.LoadBalancer.RoundRobin = &tfTypes.DataplaneItemTCP{}
					}
					to.Default.LoadBalancer.Type = types.StringValue(string(toItem.Default.LoadBalancer.Type))
				}
				if toItem.Default.LocalityAwareness == nil {
					to.Default.LocalityAwareness = nil
				} else {
					to.Default.LocalityAwareness = &tfTypes.LocalityAwareness{}
					if toItem.Default.LocalityAwareness.CrossZone == nil {
						to.Default.LocalityAwareness.CrossZone = nil
					} else {
						to.Default.LocalityAwareness.CrossZone = &tfTypes.CrossZone{}
						to.Default.LocalityAwareness.CrossZone.Failover = []tfTypes.Failover{}
						for failoverCount, failoverItem := range toItem.Default.LocalityAwareness.CrossZone.Failover {
							var failover tfTypes.Failover
							if failoverItem.From == nil {
								failover.From = nil
							} else {
								failover.From = &tfTypes.MeshLoadBalancingStrategyItemFrom{}
								failover.From.Zones = make([]types.String, 0, len(failoverItem.From.Zones))
								for _, v := range failoverItem.From.Zones {
									failover.From.Zones = append(failover.From.Zones, types.StringValue(v))
								}
							}
							failover.To.Type = types.StringValue(string(failoverItem.To.Type))
							failover.To.Zones = make([]types.String, 0, len(failoverItem.To.Zones))
							for _, v := range failoverItem.To.Zones {
								failover.To.Zones = append(failover.To.Zones, types.StringValue(v))
							}
							if failoverCount+1 > len(to.Default.LocalityAwareness.CrossZone.Failover) {
								to.Default.LocalityAwareness.CrossZone.Failover = append(to.Default.LocalityAwareness.CrossZone.Failover, failover)
							} else {
								to.Default.LocalityAwareness.CrossZone.Failover[failoverCount].From = failover.From
								to.Default.LocalityAwareness.CrossZone.Failover[failoverCount].To = failover.To
							}
						}
						if toItem.Default.LocalityAwareness.CrossZone.FailoverThreshold == nil {
							to.Default.LocalityAwareness.CrossZone.FailoverThreshold = nil
						} else {
							to.Default.LocalityAwareness.CrossZone.FailoverThreshold = &tfTypes.FailoverThreshold{}
							if toItem.Default.LocalityAwareness.CrossZone.FailoverThreshold.Percentage.Integer != nil {
								to.Default.LocalityAwareness.CrossZone.FailoverThreshold.Percentage.Integer = types.Int64PointerValue(toItem.Default.LocalityAwareness.CrossZone.FailoverThreshold.Percentage.Integer)
							}
							if toItem.Default.LocalityAwareness.CrossZone.FailoverThreshold.Percentage.Str != nil {
								to.Default.LocalityAwareness.CrossZone.FailoverThreshold.Percentage.Str = types.StringPointerValue(toItem.Default.LocalityAwareness.CrossZone.FailoverThreshold.Percentage.Str)
							}
						}
					}
					to.Default.LocalityAwareness.Disabled = types.BoolPointerValue(toItem.Default.LocalityAwareness.Disabled)
					if toItem.Default.LocalityAwareness.LocalZone == nil {
						to.Default.LocalityAwareness.LocalZone = nil
					} else {
						to.Default.LocalityAwareness.LocalZone = &tfTypes.LocalZone{}
						to.Default.LocalityAwareness.LocalZone.AffinityTags = []tfTypes.AffinityTags{}
						for affinityTagsCount, affinityTagsItem := range toItem.Default.LocalityAwareness.LocalZone.AffinityTags {
							var affinityTags tfTypes.AffinityTags
							affinityTags.Key = types.StringValue(affinityTagsItem.Key)
							affinityTags.Weight = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(affinityTagsItem.Weight))
							if affinityTagsCount+1 > len(to.Default.LocalityAwareness.LocalZone.AffinityTags) {
								to.Default.LocalityAwareness.LocalZone.AffinityTags = append(to.Default.LocalityAwareness.LocalZone.AffinityTags, affinityTags)
							} else {
								to.Default.LocalityAwareness.LocalZone.AffinityTags[affinityTagsCount].Key = affinityTags.Key
								to.Default.LocalityAwareness.LocalZone.AffinityTags[affinityTagsCount].Weight = affinityTags.Weight
							}
						}
					}
				}
			}
			to.TargetRef.Kind = types.StringValue(string(toItem.TargetRef.Kind))
			if len(toItem.TargetRef.Labels) > 0 {
				to.TargetRef.Labels = make(map[string]types.String, len(toItem.TargetRef.Labels))
				for key2, value2 := range toItem.TargetRef.Labels {
					to.TargetRef.Labels[key2] = types.StringValue(value2)
				}
			}
			to.TargetRef.Mesh = types.StringPointerValue(toItem.TargetRef.Mesh)
			to.TargetRef.Name = types.StringPointerValue(toItem.TargetRef.Name)
			to.TargetRef.Namespace = types.StringPointerValue(toItem.TargetRef.Namespace)
			to.TargetRef.ProxyTypes = make([]types.String, 0, len(toItem.TargetRef.ProxyTypes))
			for _, v := range toItem.TargetRef.ProxyTypes {
				to.TargetRef.ProxyTypes = append(to.TargetRef.ProxyTypes, types.StringValue(string(v)))
			}
			to.TargetRef.SectionName = types.StringPointerValue(toItem.TargetRef.SectionName)
			if len(toItem.TargetRef.Tags) > 0 {
				to.TargetRef.Tags = make(map[string]types.String, len(toItem.TargetRef.Tags))
				for key3, value3 := range toItem.TargetRef.Tags {
					to.TargetRef.Tags[key3] = types.StringValue(value3)
				}
			}
			if toCount+1 > len(r.Spec.To) {
				r.Spec.To = append(r.Spec.To, to)
			} else {
				r.Spec.To[toCount].Default = to.Default
				r.Spec.To[toCount].TargetRef = to.TargetRef
			}
		}
		r.Type = types.StringValue(string(resp.Type))
	}

	return diags
}
