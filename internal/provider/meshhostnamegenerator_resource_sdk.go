// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package provider

import (
	"context"
	"encoding/json"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/kong/terraform-provider-kong-mesh/internal/provider/typeconvert"
	tfTypes "github.com/kong/terraform-provider-kong-mesh/internal/provider/types"
	"github.com/kong/terraform-provider-kong-mesh/internal/sdk/models/operations"
	"github.com/kong/terraform-provider-kong-mesh/internal/sdk/models/shared"
)

func (r *MeshHostnameGeneratorResourceModel) ToSharedHostnameGeneratorItemInput(ctx context.Context) (*shared.HostnameGeneratorItemInput, diag.Diagnostics) {
	var diags diag.Diagnostics

	typeVar := shared.HostnameGeneratorItemType(r.Type.ValueString())
	var name string
	name = r.Name.ValueString()

	labels := make(map[string]string)
	for labelsKey, labelsValue := range r.Labels {
		var labelsInst string
		labelsInst = labelsValue.ValueString()

		labels[labelsKey] = labelsInst
	}
	var extension *shared.Extension
	if r.Spec.Extension != nil {
		var config interface{}
		if !r.Spec.Extension.Config.IsUnknown() && !r.Spec.Extension.Config.IsNull() {
			_ = json.Unmarshal([]byte(r.Spec.Extension.Config.ValueString()), &config)
		}
		var typeVar1 string
		typeVar1 = r.Spec.Extension.Type.ValueString()

		extension = &shared.Extension{
			Config: config,
			Type:   typeVar1,
		}
	}
	var selector *shared.Selector
	if r.Spec.Selector != nil {
		var meshExternalService *shared.MeshExternalService
		if r.Spec.Selector.MeshExternalService != nil {
			matchLabels := make(map[string]string)
			for matchLabelsKey, matchLabelsValue := range r.Spec.Selector.MeshExternalService.MatchLabels {
				var matchLabelsInst string
				matchLabelsInst = matchLabelsValue.ValueString()

				matchLabels[matchLabelsKey] = matchLabelsInst
			}
			meshExternalService = &shared.MeshExternalService{
				MatchLabels: matchLabels,
			}
		}
		var meshMultiZoneService *shared.MeshMultiZoneService
		if r.Spec.Selector.MeshMultiZoneService != nil {
			matchLabels1 := make(map[string]string)
			for matchLabelsKey1, matchLabelsValue1 := range r.Spec.Selector.MeshMultiZoneService.MatchLabels {
				var matchLabelsInst1 string
				matchLabelsInst1 = matchLabelsValue1.ValueString()

				matchLabels1[matchLabelsKey1] = matchLabelsInst1
			}
			meshMultiZoneService = &shared.MeshMultiZoneService{
				MatchLabels: matchLabels1,
			}
		}
		var meshService *shared.MeshService
		if r.Spec.Selector.MeshService != nil {
			matchLabels2 := make(map[string]string)
			for matchLabelsKey2, matchLabelsValue2 := range r.Spec.Selector.MeshService.MatchLabels {
				var matchLabelsInst2 string
				matchLabelsInst2 = matchLabelsValue2.ValueString()

				matchLabels2[matchLabelsKey2] = matchLabelsInst2
			}
			meshService = &shared.MeshService{
				MatchLabels: matchLabels2,
			}
		}
		selector = &shared.Selector{
			MeshExternalService:  meshExternalService,
			MeshMultiZoneService: meshMultiZoneService,
			MeshService:          meshService,
		}
	}
	template := new(string)
	if !r.Spec.Template.IsUnknown() && !r.Spec.Template.IsNull() {
		*template = r.Spec.Template.ValueString()
	} else {
		template = nil
	}
	spec := shared.HostnameGeneratorItemSpec{
		Extension: extension,
		Selector:  selector,
		Template:  template,
	}
	out := shared.HostnameGeneratorItemInput{
		Type:   typeVar,
		Name:   name,
		Labels: labels,
		Spec:   spec,
	}

	return &out, diags
}

func (r *MeshHostnameGeneratorResourceModel) ToOperationsCreateHostnameGeneratorRequest(ctx context.Context) (*operations.CreateHostnameGeneratorRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var name string
	name = r.Name.ValueString()

	hostnameGeneratorItem, hostnameGeneratorItemDiags := r.ToSharedHostnameGeneratorItemInput(ctx)
	diags.Append(hostnameGeneratorItemDiags...)

	if diags.HasError() {
		return nil, diags
	}

	out := operations.CreateHostnameGeneratorRequest{
		Name:                  name,
		HostnameGeneratorItem: *hostnameGeneratorItem,
	}

	return &out, diags
}

func (r *MeshHostnameGeneratorResourceModel) ToOperationsUpdateHostnameGeneratorRequest(ctx context.Context) (*operations.UpdateHostnameGeneratorRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var name string
	name = r.Name.ValueString()

	hostnameGeneratorItem, hostnameGeneratorItemDiags := r.ToSharedHostnameGeneratorItemInput(ctx)
	diags.Append(hostnameGeneratorItemDiags...)

	if diags.HasError() {
		return nil, diags
	}

	out := operations.UpdateHostnameGeneratorRequest{
		Name:                  name,
		HostnameGeneratorItem: *hostnameGeneratorItem,
	}

	return &out, diags
}

func (r *MeshHostnameGeneratorResourceModel) ToOperationsGetHostnameGeneratorRequest(ctx context.Context) (*operations.GetHostnameGeneratorRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var name string
	name = r.Name.ValueString()

	out := operations.GetHostnameGeneratorRequest{
		Name: name,
	}

	return &out, diags
}

func (r *MeshHostnameGeneratorResourceModel) ToOperationsDeleteHostnameGeneratorRequest(ctx context.Context) (*operations.DeleteHostnameGeneratorRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var name string
	name = r.Name.ValueString()

	out := operations.DeleteHostnameGeneratorRequest{
		Name: name,
	}

	return &out, diags
}

func (r *MeshHostnameGeneratorResourceModel) RefreshFromSharedHostnameGeneratorCreateOrUpdateSuccessResponse(ctx context.Context, resp *shared.HostnameGeneratorCreateOrUpdateSuccessResponse) diag.Diagnostics {
	var diags diag.Diagnostics

	if resp != nil {
		r.Warnings = make([]types.String, 0, len(resp.Warnings))
		for _, v := range resp.Warnings {
			r.Warnings = append(r.Warnings, types.StringValue(v))
		}
	}

	return diags
}

func (r *MeshHostnameGeneratorResourceModel) RefreshFromSharedHostnameGeneratorItem(ctx context.Context, resp *shared.HostnameGeneratorItem) diag.Diagnostics {
	var diags diag.Diagnostics

	if resp != nil {
		r.CreationTime = types.StringPointerValue(typeconvert.TimePointerToStringPointer(resp.CreationTime))
		if len(resp.Labels) > 0 {
			r.Labels = make(map[string]types.String, len(resp.Labels))
			for key, value := range resp.Labels {
				r.Labels[key] = types.StringValue(value)
			}
		}
		r.ModificationTime = types.StringPointerValue(typeconvert.TimePointerToStringPointer(resp.ModificationTime))
		r.Name = types.StringValue(resp.Name)
		if resp.Spec.Extension == nil {
			r.Spec.Extension = nil
		} else {
			r.Spec.Extension = &tfTypes.MeshExternalServiceItemExtension{}
			if resp.Spec.Extension.Config == nil {
				r.Spec.Extension.Config = types.StringNull()
			} else {
				configResult, _ := json.Marshal(resp.Spec.Extension.Config)
				r.Spec.Extension.Config = types.StringValue(string(configResult))
			}
			r.Spec.Extension.Type = types.StringValue(resp.Spec.Extension.Type)
		}
		if resp.Spec.Selector == nil {
			r.Spec.Selector = nil
		} else {
			r.Spec.Selector = &tfTypes.Selector{}
			if resp.Spec.Selector.MeshExternalService == nil {
				r.Spec.Selector.MeshExternalService = nil
			} else {
				r.Spec.Selector.MeshExternalService = &tfTypes.MeshExternalService{}
				if len(resp.Spec.Selector.MeshExternalService.MatchLabels) > 0 {
					r.Spec.Selector.MeshExternalService.MatchLabels = make(map[string]types.String, len(resp.Spec.Selector.MeshExternalService.MatchLabels))
					for key1, value1 := range resp.Spec.Selector.MeshExternalService.MatchLabels {
						r.Spec.Selector.MeshExternalService.MatchLabels[key1] = types.StringValue(value1)
					}
				}
			}
			if resp.Spec.Selector.MeshMultiZoneService == nil {
				r.Spec.Selector.MeshMultiZoneService = nil
			} else {
				r.Spec.Selector.MeshMultiZoneService = &tfTypes.MeshExternalService{}
				if len(resp.Spec.Selector.MeshMultiZoneService.MatchLabels) > 0 {
					r.Spec.Selector.MeshMultiZoneService.MatchLabels = make(map[string]types.String, len(resp.Spec.Selector.MeshMultiZoneService.MatchLabels))
					for key2, value2 := range resp.Spec.Selector.MeshMultiZoneService.MatchLabels {
						r.Spec.Selector.MeshMultiZoneService.MatchLabels[key2] = types.StringValue(value2)
					}
				}
			}
			if resp.Spec.Selector.MeshService == nil {
				r.Spec.Selector.MeshService = nil
			} else {
				r.Spec.Selector.MeshService = &tfTypes.MeshExternalService{}
				if len(resp.Spec.Selector.MeshService.MatchLabels) > 0 {
					r.Spec.Selector.MeshService.MatchLabels = make(map[string]types.String, len(resp.Spec.Selector.MeshService.MatchLabels))
					for key3, value3 := range resp.Spec.Selector.MeshService.MatchLabels {
						r.Spec.Selector.MeshService.MatchLabels[key3] = types.StringValue(value3)
					}
				}
			}
		}
		r.Spec.Template = types.StringPointerValue(resp.Spec.Template)
		r.Type = types.StringValue(string(resp.Type))
	}

	return diags
}
