// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package provider

import (
	"context"
	"github.com/Kong/shared-speakeasy/customtypes/kumalabels"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/kong/terraform-provider-kong-mesh/internal/provider/typeconvert"
	tfTypes "github.com/kong/terraform-provider-kong-mesh/internal/provider/types"
	"github.com/kong/terraform-provider-kong-mesh/internal/sdk/models/operations"
	"github.com/kong/terraform-provider-kong-mesh/internal/sdk/models/shared"
)

func (r *MeshGlobalRateLimitResourceModel) RefreshFromSharedMeshGlobalRateLimitCreateOrUpdateSuccessResponse(ctx context.Context, resp *shared.MeshGlobalRateLimitCreateOrUpdateSuccessResponse) diag.Diagnostics {
	var diags diag.Diagnostics

	if resp != nil {
		r.Warnings = make([]types.String, 0, len(resp.Warnings))
		for _, v := range resp.Warnings {
			r.Warnings = append(r.Warnings, types.StringValue(v))
		}
	}

	return diags
}

func (r *MeshGlobalRateLimitResourceModel) RefreshFromSharedMeshGlobalRateLimitItem(ctx context.Context, resp *shared.MeshGlobalRateLimitItem) diag.Diagnostics {
	var diags diag.Diagnostics

	if resp != nil {
		r.CreationTime = types.StringPointerValue(typeconvert.TimePointerToStringPointer(resp.CreationTime))
		labelsValue, labelsDiags := types.MapValueFrom(ctx, types.StringType, resp.Labels)
		diags.Append(labelsDiags...)
		labelsValuable, labelsDiags := kumalabels.KumaLabelsMapType{MapType: types.MapType{ElemType: types.StringType}}.ValueFromMap(ctx, labelsValue)
		diags.Append(labelsDiags...)
		r.Labels, _ = labelsValuable.(kumalabels.KumaLabelsMapValue)
		r.Mesh = types.StringPointerValue(resp.Mesh)
		r.ModificationTime = types.StringPointerValue(typeconvert.TimePointerToStringPointer(resp.ModificationTime))
		r.Name = types.StringValue(resp.Name)
		r.Spec.From = []tfTypes.MeshGlobalRateLimitItemFrom{}

		for _, fromItem := range resp.Spec.From {
			var from tfTypes.MeshGlobalRateLimitItemFrom

			if fromItem.Default == nil {
				from.Default = nil
			} else {
				from.Default = &tfTypes.MeshGlobalRateLimitItemDefault{}
				from.Default.Backend.RateLimitService.LimitOnServiceFail = types.BoolPointerValue(fromItem.Default.Backend.RateLimitService.LimitOnServiceFail)
				from.Default.Backend.RateLimitService.Timeout = types.StringPointerValue(fromItem.Default.Backend.RateLimitService.Timeout)
				from.Default.Backend.RateLimitService.URL = types.StringPointerValue(fromItem.Default.Backend.RateLimitService.URL)
				from.Default.HTTP.Disabled = types.BoolPointerValue(fromItem.Default.HTTP.Disabled)
				if fromItem.Default.HTTP.OnRateLimit == nil {
					from.Default.HTTP.OnRateLimit = nil
				} else {
					from.Default.HTTP.OnRateLimit = &tfTypes.OnRateLimit{}
					if fromItem.Default.HTTP.OnRateLimit.Headers == nil {
						from.Default.HTTP.OnRateLimit.Headers = nil
					} else {
						from.Default.HTTP.OnRateLimit.Headers = &tfTypes.MeshGlobalRateLimitItemHeaders{}
						from.Default.HTTP.OnRateLimit.Headers.Add = []tfTypes.MeshGlobalRateLimitItemAdd{}

						for _, addItem := range fromItem.Default.HTTP.OnRateLimit.Headers.Add {
							var add tfTypes.MeshGlobalRateLimitItemAdd

							add.Name = types.StringValue(addItem.Name)
							add.Value = types.StringValue(addItem.Value)

							from.Default.HTTP.OnRateLimit.Headers.Add = append(from.Default.HTTP.OnRateLimit.Headers.Add, add)
						}
						from.Default.HTTP.OnRateLimit.Headers.Set = []tfTypes.MeshGlobalRateLimitItemAdd{}

						for _, setItem := range fromItem.Default.HTTP.OnRateLimit.Headers.Set {
							var set tfTypes.MeshGlobalRateLimitItemAdd

							set.Name = types.StringValue(setItem.Name)
							set.Value = types.StringValue(setItem.Value)

							from.Default.HTTP.OnRateLimit.Headers.Set = append(from.Default.HTTP.OnRateLimit.Headers.Set, set)
						}
					}
					from.Default.HTTP.OnRateLimit.Status = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(fromItem.Default.HTTP.OnRateLimit.Status))
				}
				from.Default.HTTP.RatelimitOnRequest = []tfTypes.RatelimitOnRequest{}

				for _, ratelimitOnRequestItem := range fromItem.Default.HTTP.RatelimitOnRequest {
					var ratelimitOnRequest tfTypes.RatelimitOnRequest

					ratelimitOnRequest.Kind = types.StringValue(string(ratelimitOnRequestItem.Kind))
					ratelimitOnRequest.Limits = []tfTypes.Limits{}

					for _, limitsItem := range ratelimitOnRequestItem.Limits {
						var limits tfTypes.Limits

						if limitsItem.RequestRate == nil {
							limits.RequestRate = nil
						} else {
							limits.RequestRate = &tfTypes.MeshGlobalRateLimitItemSpecFromRequestRate{}
							limits.RequestRate.Interval = types.StringValue(limitsItem.RequestRate.Interval)
							limits.RequestRate.Num = types.Int32Value(int32(limitsItem.RequestRate.Num))
						}
						limits.Value = types.StringValue(limitsItem.Value)

						ratelimitOnRequest.Limits = append(ratelimitOnRequest.Limits, limits)
					}
					ratelimitOnRequest.Name = types.StringValue(ratelimitOnRequestItem.Name)

					from.Default.HTTP.RatelimitOnRequest = append(from.Default.HTTP.RatelimitOnRequest, ratelimitOnRequest)
				}
				if fromItem.Default.HTTP.RequestRate == nil {
					from.Default.HTTP.RequestRate = nil
				} else {
					from.Default.HTTP.RequestRate = &tfTypes.MeshGlobalRateLimitItemSpecFromRequestRate{}
					from.Default.HTTP.RequestRate.Interval = types.StringValue(fromItem.Default.HTTP.RequestRate.Interval)
					from.Default.HTTP.RequestRate.Num = types.Int32Value(int32(fromItem.Default.HTTP.RequestRate.Num))
				}
				if fromItem.Default.Mode != nil {
					from.Default.Mode = types.StringValue(string(*fromItem.Default.Mode))
				} else {
					from.Default.Mode = types.StringNull()
				}
			}
			from.TargetRef.Kind = types.StringValue(string(fromItem.TargetRef.Kind))
			if len(fromItem.TargetRef.Labels) > 0 {
				from.TargetRef.Labels = make(map[string]types.String, len(fromItem.TargetRef.Labels))
				for key, value := range fromItem.TargetRef.Labels {
					from.TargetRef.Labels[key] = types.StringValue(value)
				}
			}
			from.TargetRef.Mesh = types.StringPointerValue(fromItem.TargetRef.Mesh)
			from.TargetRef.Name = types.StringPointerValue(fromItem.TargetRef.Name)
			from.TargetRef.Namespace = types.StringPointerValue(fromItem.TargetRef.Namespace)
			from.TargetRef.ProxyTypes = make([]types.String, 0, len(fromItem.TargetRef.ProxyTypes))
			for _, v := range fromItem.TargetRef.ProxyTypes {
				from.TargetRef.ProxyTypes = append(from.TargetRef.ProxyTypes, types.StringValue(string(v)))
			}
			from.TargetRef.SectionName = types.StringPointerValue(fromItem.TargetRef.SectionName)
			if len(fromItem.TargetRef.Tags) > 0 {
				from.TargetRef.Tags = make(map[string]types.String, len(fromItem.TargetRef.Tags))
				for key1, value1 := range fromItem.TargetRef.Tags {
					from.TargetRef.Tags[key1] = types.StringValue(value1)
				}
			}

			r.Spec.From = append(r.Spec.From, from)
		}
		if resp.Spec.TargetRef == nil {
			r.Spec.TargetRef = nil
		} else {
			r.Spec.TargetRef = &tfTypes.MeshAccessLogItemTargetRef{}
			r.Spec.TargetRef.Kind = types.StringValue(string(resp.Spec.TargetRef.Kind))
			if len(resp.Spec.TargetRef.Labels) > 0 {
				r.Spec.TargetRef.Labels = make(map[string]types.String, len(resp.Spec.TargetRef.Labels))
				for key2, value2 := range resp.Spec.TargetRef.Labels {
					r.Spec.TargetRef.Labels[key2] = types.StringValue(value2)
				}
			}
			r.Spec.TargetRef.Mesh = types.StringPointerValue(resp.Spec.TargetRef.Mesh)
			r.Spec.TargetRef.Name = types.StringPointerValue(resp.Spec.TargetRef.Name)
			r.Spec.TargetRef.Namespace = types.StringPointerValue(resp.Spec.TargetRef.Namespace)
			r.Spec.TargetRef.ProxyTypes = make([]types.String, 0, len(resp.Spec.TargetRef.ProxyTypes))
			for _, v := range resp.Spec.TargetRef.ProxyTypes {
				r.Spec.TargetRef.ProxyTypes = append(r.Spec.TargetRef.ProxyTypes, types.StringValue(string(v)))
			}
			r.Spec.TargetRef.SectionName = types.StringPointerValue(resp.Spec.TargetRef.SectionName)
			if len(resp.Spec.TargetRef.Tags) > 0 {
				r.Spec.TargetRef.Tags = make(map[string]types.String, len(resp.Spec.TargetRef.Tags))
				for key3, value3 := range resp.Spec.TargetRef.Tags {
					r.Spec.TargetRef.Tags[key3] = types.StringValue(value3)
				}
			}
		}
		r.Spec.To = []tfTypes.MeshGlobalRateLimitItemFrom{}

		for _, toItem := range resp.Spec.To {
			var to tfTypes.MeshGlobalRateLimitItemFrom

			if toItem.Default == nil {
				to.Default = nil
			} else {
				to.Default = &tfTypes.MeshGlobalRateLimitItemDefault{}
				to.Default.Backend.RateLimitService.LimitOnServiceFail = types.BoolPointerValue(toItem.Default.Backend.RateLimitService.LimitOnServiceFail)
				to.Default.Backend.RateLimitService.Timeout = types.StringPointerValue(toItem.Default.Backend.RateLimitService.Timeout)
				to.Default.Backend.RateLimitService.URL = types.StringPointerValue(toItem.Default.Backend.RateLimitService.URL)
				to.Default.HTTP.Disabled = types.BoolPointerValue(toItem.Default.HTTP.Disabled)
				if toItem.Default.HTTP.OnRateLimit == nil {
					to.Default.HTTP.OnRateLimit = nil
				} else {
					to.Default.HTTP.OnRateLimit = &tfTypes.OnRateLimit{}
					if toItem.Default.HTTP.OnRateLimit.Headers == nil {
						to.Default.HTTP.OnRateLimit.Headers = nil
					} else {
						to.Default.HTTP.OnRateLimit.Headers = &tfTypes.MeshGlobalRateLimitItemHeaders{}
						to.Default.HTTP.OnRateLimit.Headers.Add = []tfTypes.MeshGlobalRateLimitItemAdd{}

						for _, addItem1 := range toItem.Default.HTTP.OnRateLimit.Headers.Add {
							var add1 tfTypes.MeshGlobalRateLimitItemAdd

							add1.Name = types.StringValue(addItem1.Name)
							add1.Value = types.StringValue(addItem1.Value)

							to.Default.HTTP.OnRateLimit.Headers.Add = append(to.Default.HTTP.OnRateLimit.Headers.Add, add1)
						}
						to.Default.HTTP.OnRateLimit.Headers.Set = []tfTypes.MeshGlobalRateLimitItemAdd{}

						for _, setItem1 := range toItem.Default.HTTP.OnRateLimit.Headers.Set {
							var set1 tfTypes.MeshGlobalRateLimitItemAdd

							set1.Name = types.StringValue(setItem1.Name)
							set1.Value = types.StringValue(setItem1.Value)

							to.Default.HTTP.OnRateLimit.Headers.Set = append(to.Default.HTTP.OnRateLimit.Headers.Set, set1)
						}
					}
					to.Default.HTTP.OnRateLimit.Status = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(toItem.Default.HTTP.OnRateLimit.Status))
				}
				to.Default.HTTP.RatelimitOnRequest = []tfTypes.RatelimitOnRequest{}

				for _, ratelimitOnRequestItem1 := range toItem.Default.HTTP.RatelimitOnRequest {
					var ratelimitOnRequest1 tfTypes.RatelimitOnRequest

					ratelimitOnRequest1.Kind = types.StringValue(string(ratelimitOnRequestItem1.Kind))
					ratelimitOnRequest1.Limits = []tfTypes.Limits{}

					for _, limitsItem1 := range ratelimitOnRequestItem1.Limits {
						var limits1 tfTypes.Limits

						if limitsItem1.RequestRate == nil {
							limits1.RequestRate = nil
						} else {
							limits1.RequestRate = &tfTypes.MeshGlobalRateLimitItemSpecFromRequestRate{}
							limits1.RequestRate.Interval = types.StringValue(limitsItem1.RequestRate.Interval)
							limits1.RequestRate.Num = types.Int32Value(int32(limitsItem1.RequestRate.Num))
						}
						limits1.Value = types.StringValue(limitsItem1.Value)

						ratelimitOnRequest1.Limits = append(ratelimitOnRequest1.Limits, limits1)
					}
					ratelimitOnRequest1.Name = types.StringValue(ratelimitOnRequestItem1.Name)

					to.Default.HTTP.RatelimitOnRequest = append(to.Default.HTTP.RatelimitOnRequest, ratelimitOnRequest1)
				}
				if toItem.Default.HTTP.RequestRate == nil {
					to.Default.HTTP.RequestRate = nil
				} else {
					to.Default.HTTP.RequestRate = &tfTypes.MeshGlobalRateLimitItemSpecFromRequestRate{}
					to.Default.HTTP.RequestRate.Interval = types.StringValue(toItem.Default.HTTP.RequestRate.Interval)
					to.Default.HTTP.RequestRate.Num = types.Int32Value(int32(toItem.Default.HTTP.RequestRate.Num))
				}
				if toItem.Default.Mode != nil {
					to.Default.Mode = types.StringValue(string(*toItem.Default.Mode))
				} else {
					to.Default.Mode = types.StringNull()
				}
			}
			to.TargetRef.Kind = types.StringValue(string(toItem.TargetRef.Kind))
			if len(toItem.TargetRef.Labels) > 0 {
				to.TargetRef.Labels = make(map[string]types.String, len(toItem.TargetRef.Labels))
				for key4, value4 := range toItem.TargetRef.Labels {
					to.TargetRef.Labels[key4] = types.StringValue(value4)
				}
			}
			to.TargetRef.Mesh = types.StringPointerValue(toItem.TargetRef.Mesh)
			to.TargetRef.Name = types.StringPointerValue(toItem.TargetRef.Name)
			to.TargetRef.Namespace = types.StringPointerValue(toItem.TargetRef.Namespace)
			to.TargetRef.ProxyTypes = make([]types.String, 0, len(toItem.TargetRef.ProxyTypes))
			for _, v := range toItem.TargetRef.ProxyTypes {
				to.TargetRef.ProxyTypes = append(to.TargetRef.ProxyTypes, types.StringValue(string(v)))
			}
			to.TargetRef.SectionName = types.StringPointerValue(toItem.TargetRef.SectionName)
			if len(toItem.TargetRef.Tags) > 0 {
				to.TargetRef.Tags = make(map[string]types.String, len(toItem.TargetRef.Tags))
				for key5, value5 := range toItem.TargetRef.Tags {
					to.TargetRef.Tags[key5] = types.StringValue(value5)
				}
			}

			r.Spec.To = append(r.Spec.To, to)
		}
		r.Type = types.StringValue(string(resp.Type))
	}

	return diags
}

func (r *MeshGlobalRateLimitResourceModel) ToOperationsDeleteMeshGlobalRateLimitRequest(ctx context.Context) (*operations.DeleteMeshGlobalRateLimitRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var mesh string
	mesh = r.Mesh.ValueString()

	var name string
	name = r.Name.ValueString()

	out := operations.DeleteMeshGlobalRateLimitRequest{
		Mesh: mesh,
		Name: name,
	}

	return &out, diags
}

func (r *MeshGlobalRateLimitResourceModel) ToOperationsGetMeshGlobalRateLimitRequest(ctx context.Context) (*operations.GetMeshGlobalRateLimitRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var mesh string
	mesh = r.Mesh.ValueString()

	var name string
	name = r.Name.ValueString()

	out := operations.GetMeshGlobalRateLimitRequest{
		Mesh: mesh,
		Name: name,
	}

	return &out, diags
}

func (r *MeshGlobalRateLimitResourceModel) ToOperationsPutMeshGlobalRateLimitRequest(ctx context.Context) (*operations.PutMeshGlobalRateLimitRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var mesh string
	mesh = r.Mesh.ValueString()

	var name string
	name = r.Name.ValueString()

	meshGlobalRateLimitItem, meshGlobalRateLimitItemDiags := r.ToSharedMeshGlobalRateLimitItemInput(ctx)
	diags.Append(meshGlobalRateLimitItemDiags...)

	if diags.HasError() {
		return nil, diags
	}

	out := operations.PutMeshGlobalRateLimitRequest{
		Mesh:                    mesh,
		Name:                    name,
		MeshGlobalRateLimitItem: *meshGlobalRateLimitItem,
	}

	return &out, diags
}

func (r *MeshGlobalRateLimitResourceModel) ToSharedMeshGlobalRateLimitItemInput(ctx context.Context) (*shared.MeshGlobalRateLimitItemInput, diag.Diagnostics) {
	var diags diag.Diagnostics

	typeVar := shared.MeshGlobalRateLimitItemType(r.Type.ValueString())
	mesh := new(string)
	if !r.Mesh.IsUnknown() && !r.Mesh.IsNull() {
		*mesh = r.Mesh.ValueString()
	} else {
		mesh = nil
	}
	var name string
	name = r.Name.ValueString()

	var labels map[string]string
	if !r.Labels.IsUnknown() && !r.Labels.IsNull() {
		diags.Append(r.Labels.ElementsAs(ctx, &labels, true)...)
	}
	from := make([]shared.MeshGlobalRateLimitItemFrom, 0, len(r.Spec.From))
	for _, fromItem := range r.Spec.From {
		var defaultVar *shared.MeshGlobalRateLimitItemDefault
		if fromItem.Default != nil {
			limitOnServiceFail := new(bool)
			if !fromItem.Default.Backend.RateLimitService.LimitOnServiceFail.IsUnknown() && !fromItem.Default.Backend.RateLimitService.LimitOnServiceFail.IsNull() {
				*limitOnServiceFail = fromItem.Default.Backend.RateLimitService.LimitOnServiceFail.ValueBool()
			} else {
				limitOnServiceFail = nil
			}
			timeout := new(string)
			if !fromItem.Default.Backend.RateLimitService.Timeout.IsUnknown() && !fromItem.Default.Backend.RateLimitService.Timeout.IsNull() {
				*timeout = fromItem.Default.Backend.RateLimitService.Timeout.ValueString()
			} else {
				timeout = nil
			}
			url := new(string)
			if !fromItem.Default.Backend.RateLimitService.URL.IsUnknown() && !fromItem.Default.Backend.RateLimitService.URL.IsNull() {
				*url = fromItem.Default.Backend.RateLimitService.URL.ValueString()
			} else {
				url = nil
			}
			rateLimitService := shared.RateLimitService{
				LimitOnServiceFail: limitOnServiceFail,
				Timeout:            timeout,
				URL:                url,
			}
			backend := shared.Backend{
				RateLimitService: rateLimitService,
			}
			disabled := new(bool)
			if !fromItem.Default.HTTP.Disabled.IsUnknown() && !fromItem.Default.HTTP.Disabled.IsNull() {
				*disabled = fromItem.Default.HTTP.Disabled.ValueBool()
			} else {
				disabled = nil
			}
			var onRateLimit *shared.OnRateLimit
			if fromItem.Default.HTTP.OnRateLimit != nil {
				var headers *shared.MeshGlobalRateLimitItemHeaders
				if fromItem.Default.HTTP.OnRateLimit.Headers != nil {
					add := make([]shared.MeshGlobalRateLimitItemAdd, 0, len(fromItem.Default.HTTP.OnRateLimit.Headers.Add))
					for _, addItem := range fromItem.Default.HTTP.OnRateLimit.Headers.Add {
						var name1 string
						name1 = addItem.Name.ValueString()

						var value string
						value = addItem.Value.ValueString()

						add = append(add, shared.MeshGlobalRateLimitItemAdd{
							Name:  name1,
							Value: value,
						})
					}
					set := make([]shared.MeshGlobalRateLimitItemSet, 0, len(fromItem.Default.HTTP.OnRateLimit.Headers.Set))
					for _, setItem := range fromItem.Default.HTTP.OnRateLimit.Headers.Set {
						var name2 string
						name2 = setItem.Name.ValueString()

						var value1 string
						value1 = setItem.Value.ValueString()

						set = append(set, shared.MeshGlobalRateLimitItemSet{
							Name:  name2,
							Value: value1,
						})
					}
					headers = &shared.MeshGlobalRateLimitItemHeaders{
						Add: add,
						Set: set,
					}
				}
				status := new(int)
				if !fromItem.Default.HTTP.OnRateLimit.Status.IsUnknown() && !fromItem.Default.HTTP.OnRateLimit.Status.IsNull() {
					*status = int(fromItem.Default.HTTP.OnRateLimit.Status.ValueInt32())
				} else {
					status = nil
				}
				onRateLimit = &shared.OnRateLimit{
					Headers: headers,
					Status:  status,
				}
			}
			ratelimitOnRequest := make([]shared.RatelimitOnRequest, 0, len(fromItem.Default.HTTP.RatelimitOnRequest))
			for _, ratelimitOnRequestItem := range fromItem.Default.HTTP.RatelimitOnRequest {
				kind := shared.MeshGlobalRateLimitItemSpecFromKind(ratelimitOnRequestItem.Kind.ValueString())
				limits := make([]shared.Limits, 0, len(ratelimitOnRequestItem.Limits))
				for _, limitsItem := range ratelimitOnRequestItem.Limits {
					var requestRate *shared.MeshGlobalRateLimitItemSpecFromRequestRate
					if limitsItem.RequestRate != nil {
						var interval string
						interval = limitsItem.RequestRate.Interval.ValueString()

						var num int
						num = int(limitsItem.RequestRate.Num.ValueInt32())

						requestRate = &shared.MeshGlobalRateLimitItemSpecFromRequestRate{
							Interval: interval,
							Num:      num,
						}
					}
					var value2 string
					value2 = limitsItem.Value.ValueString()

					limits = append(limits, shared.Limits{
						RequestRate: requestRate,
						Value:       value2,
					})
				}
				var name3 string
				name3 = ratelimitOnRequestItem.Name.ValueString()

				ratelimitOnRequest = append(ratelimitOnRequest, shared.RatelimitOnRequest{
					Kind:   kind,
					Limits: limits,
					Name:   name3,
				})
			}
			var requestRate1 *shared.RequestRate
			if fromItem.Default.HTTP.RequestRate != nil {
				var interval1 string
				interval1 = fromItem.Default.HTTP.RequestRate.Interval.ValueString()

				var num1 int
				num1 = int(fromItem.Default.HTTP.RequestRate.Num.ValueInt32())

				requestRate1 = &shared.RequestRate{
					Interval: interval1,
					Num:      num1,
				}
			}
			http := shared.MeshGlobalRateLimitItemHTTP{
				Disabled:           disabled,
				OnRateLimit:        onRateLimit,
				RatelimitOnRequest: ratelimitOnRequest,
				RequestRate:        requestRate1,
			}
			mode := new(shared.MeshGlobalRateLimitItemMode)
			if !fromItem.Default.Mode.IsUnknown() && !fromItem.Default.Mode.IsNull() {
				*mode = shared.MeshGlobalRateLimitItemMode(fromItem.Default.Mode.ValueString())
			} else {
				mode = nil
			}
			defaultVar = &shared.MeshGlobalRateLimitItemDefault{
				Backend: backend,
				HTTP:    http,
				Mode:    mode,
			}
		}
		kind1 := shared.MeshGlobalRateLimitItemSpecKind(fromItem.TargetRef.Kind.ValueString())
		labels1 := make(map[string]string)
		for labelsKey, labelsValue := range fromItem.TargetRef.Labels {
			var labelsInst string
			labelsInst = labelsValue.ValueString()

			labels1[labelsKey] = labelsInst
		}
		mesh1 := new(string)
		if !fromItem.TargetRef.Mesh.IsUnknown() && !fromItem.TargetRef.Mesh.IsNull() {
			*mesh1 = fromItem.TargetRef.Mesh.ValueString()
		} else {
			mesh1 = nil
		}
		name4 := new(string)
		if !fromItem.TargetRef.Name.IsUnknown() && !fromItem.TargetRef.Name.IsNull() {
			*name4 = fromItem.TargetRef.Name.ValueString()
		} else {
			name4 = nil
		}
		namespace := new(string)
		if !fromItem.TargetRef.Namespace.IsUnknown() && !fromItem.TargetRef.Namespace.IsNull() {
			*namespace = fromItem.TargetRef.Namespace.ValueString()
		} else {
			namespace = nil
		}
		proxyTypes := make([]shared.MeshGlobalRateLimitItemSpecProxyTypes, 0, len(fromItem.TargetRef.ProxyTypes))
		for _, proxyTypesItem := range fromItem.TargetRef.ProxyTypes {
			proxyTypes = append(proxyTypes, shared.MeshGlobalRateLimitItemSpecProxyTypes(proxyTypesItem.ValueString()))
		}
		sectionName := new(string)
		if !fromItem.TargetRef.SectionName.IsUnknown() && !fromItem.TargetRef.SectionName.IsNull() {
			*sectionName = fromItem.TargetRef.SectionName.ValueString()
		} else {
			sectionName = nil
		}
		tags := make(map[string]string)
		for tagsKey, tagsValue := range fromItem.TargetRef.Tags {
			var tagsInst string
			tagsInst = tagsValue.ValueString()

			tags[tagsKey] = tagsInst
		}
		targetRef := shared.MeshGlobalRateLimitItemSpecTargetRef{
			Kind:        kind1,
			Labels:      labels1,
			Mesh:        mesh1,
			Name:        name4,
			Namespace:   namespace,
			ProxyTypes:  proxyTypes,
			SectionName: sectionName,
			Tags:        tags,
		}
		from = append(from, shared.MeshGlobalRateLimitItemFrom{
			Default:   defaultVar,
			TargetRef: targetRef,
		})
	}
	var targetRef1 *shared.MeshGlobalRateLimitItemTargetRef
	if r.Spec.TargetRef != nil {
		kind2 := shared.MeshGlobalRateLimitItemKind(r.Spec.TargetRef.Kind.ValueString())
		labels2 := make(map[string]string)
		for labelsKey1, labelsValue1 := range r.Spec.TargetRef.Labels {
			var labelsInst1 string
			labelsInst1 = labelsValue1.ValueString()

			labels2[labelsKey1] = labelsInst1
		}
		mesh2 := new(string)
		if !r.Spec.TargetRef.Mesh.IsUnknown() && !r.Spec.TargetRef.Mesh.IsNull() {
			*mesh2 = r.Spec.TargetRef.Mesh.ValueString()
		} else {
			mesh2 = nil
		}
		name5 := new(string)
		if !r.Spec.TargetRef.Name.IsUnknown() && !r.Spec.TargetRef.Name.IsNull() {
			*name5 = r.Spec.TargetRef.Name.ValueString()
		} else {
			name5 = nil
		}
		namespace1 := new(string)
		if !r.Spec.TargetRef.Namespace.IsUnknown() && !r.Spec.TargetRef.Namespace.IsNull() {
			*namespace1 = r.Spec.TargetRef.Namespace.ValueString()
		} else {
			namespace1 = nil
		}
		proxyTypes1 := make([]shared.MeshGlobalRateLimitItemProxyTypes, 0, len(r.Spec.TargetRef.ProxyTypes))
		for _, proxyTypesItem1 := range r.Spec.TargetRef.ProxyTypes {
			proxyTypes1 = append(proxyTypes1, shared.MeshGlobalRateLimitItemProxyTypes(proxyTypesItem1.ValueString()))
		}
		sectionName1 := new(string)
		if !r.Spec.TargetRef.SectionName.IsUnknown() && !r.Spec.TargetRef.SectionName.IsNull() {
			*sectionName1 = r.Spec.TargetRef.SectionName.ValueString()
		} else {
			sectionName1 = nil
		}
		tags1 := make(map[string]string)
		for tagsKey1, tagsValue1 := range r.Spec.TargetRef.Tags {
			var tagsInst1 string
			tagsInst1 = tagsValue1.ValueString()

			tags1[tagsKey1] = tagsInst1
		}
		targetRef1 = &shared.MeshGlobalRateLimitItemTargetRef{
			Kind:        kind2,
			Labels:      labels2,
			Mesh:        mesh2,
			Name:        name5,
			Namespace:   namespace1,
			ProxyTypes:  proxyTypes1,
			SectionName: sectionName1,
			Tags:        tags1,
		}
	}
	to := make([]shared.MeshGlobalRateLimitItemTo, 0, len(r.Spec.To))
	for _, toItem := range r.Spec.To {
		var default1 *shared.MeshGlobalRateLimitItemSpecDefault
		if toItem.Default != nil {
			limitOnServiceFail1 := new(bool)
			if !toItem.Default.Backend.RateLimitService.LimitOnServiceFail.IsUnknown() && !toItem.Default.Backend.RateLimitService.LimitOnServiceFail.IsNull() {
				*limitOnServiceFail1 = toItem.Default.Backend.RateLimitService.LimitOnServiceFail.ValueBool()
			} else {
				limitOnServiceFail1 = nil
			}
			timeout1 := new(string)
			if !toItem.Default.Backend.RateLimitService.Timeout.IsUnknown() && !toItem.Default.Backend.RateLimitService.Timeout.IsNull() {
				*timeout1 = toItem.Default.Backend.RateLimitService.Timeout.ValueString()
			} else {
				timeout1 = nil
			}
			url1 := new(string)
			if !toItem.Default.Backend.RateLimitService.URL.IsUnknown() && !toItem.Default.Backend.RateLimitService.URL.IsNull() {
				*url1 = toItem.Default.Backend.RateLimitService.URL.ValueString()
			} else {
				url1 = nil
			}
			rateLimitService1 := shared.MeshGlobalRateLimitItemRateLimitService{
				LimitOnServiceFail: limitOnServiceFail1,
				Timeout:            timeout1,
				URL:                url1,
			}
			backend1 := shared.MeshGlobalRateLimitItemBackend{
				RateLimitService: rateLimitService1,
			}
			disabled1 := new(bool)
			if !toItem.Default.HTTP.Disabled.IsUnknown() && !toItem.Default.HTTP.Disabled.IsNull() {
				*disabled1 = toItem.Default.HTTP.Disabled.ValueBool()
			} else {
				disabled1 = nil
			}
			var onRateLimit1 *shared.MeshGlobalRateLimitItemOnRateLimit
			if toItem.Default.HTTP.OnRateLimit != nil {
				var headers1 *shared.MeshGlobalRateLimitItemSpecHeaders
				if toItem.Default.HTTP.OnRateLimit.Headers != nil {
					add1 := make([]shared.MeshGlobalRateLimitItemSpecAdd, 0, len(toItem.Default.HTTP.OnRateLimit.Headers.Add))
					for _, addItem1 := range toItem.Default.HTTP.OnRateLimit.Headers.Add {
						var name6 string
						name6 = addItem1.Name.ValueString()

						var value3 string
						value3 = addItem1.Value.ValueString()

						add1 = append(add1, shared.MeshGlobalRateLimitItemSpecAdd{
							Name:  name6,
							Value: value3,
						})
					}
					set1 := make([]shared.MeshGlobalRateLimitItemSpecSet, 0, len(toItem.Default.HTTP.OnRateLimit.Headers.Set))
					for _, setItem1 := range toItem.Default.HTTP.OnRateLimit.Headers.Set {
						var name7 string
						name7 = setItem1.Name.ValueString()

						var value4 string
						value4 = setItem1.Value.ValueString()

						set1 = append(set1, shared.MeshGlobalRateLimitItemSpecSet{
							Name:  name7,
							Value: value4,
						})
					}
					headers1 = &shared.MeshGlobalRateLimitItemSpecHeaders{
						Add: add1,
						Set: set1,
					}
				}
				status1 := new(int)
				if !toItem.Default.HTTP.OnRateLimit.Status.IsUnknown() && !toItem.Default.HTTP.OnRateLimit.Status.IsNull() {
					*status1 = int(toItem.Default.HTTP.OnRateLimit.Status.ValueInt32())
				} else {
					status1 = nil
				}
				onRateLimit1 = &shared.MeshGlobalRateLimitItemOnRateLimit{
					Headers: headers1,
					Status:  status1,
				}
			}
			ratelimitOnRequest1 := make([]shared.MeshGlobalRateLimitItemRatelimitOnRequest, 0, len(toItem.Default.HTTP.RatelimitOnRequest))
			for _, ratelimitOnRequestItem1 := range toItem.Default.HTTP.RatelimitOnRequest {
				kind3 := shared.MeshGlobalRateLimitItemSpecToDefaultKind(ratelimitOnRequestItem1.Kind.ValueString())
				limits1 := make([]shared.MeshGlobalRateLimitItemLimits, 0, len(ratelimitOnRequestItem1.Limits))
				for _, limitsItem1 := range ratelimitOnRequestItem1.Limits {
					var requestRate2 *shared.MeshGlobalRateLimitItemSpecRequestRate
					if limitsItem1.RequestRate != nil {
						var interval2 string
						interval2 = limitsItem1.RequestRate.Interval.ValueString()

						var num2 int
						num2 = int(limitsItem1.RequestRate.Num.ValueInt32())

						requestRate2 = &shared.MeshGlobalRateLimitItemSpecRequestRate{
							Interval: interval2,
							Num:      num2,
						}
					}
					var value5 string
					value5 = limitsItem1.Value.ValueString()

					limits1 = append(limits1, shared.MeshGlobalRateLimitItemLimits{
						RequestRate: requestRate2,
						Value:       value5,
					})
				}
				var name8 string
				name8 = ratelimitOnRequestItem1.Name.ValueString()

				ratelimitOnRequest1 = append(ratelimitOnRequest1, shared.MeshGlobalRateLimitItemRatelimitOnRequest{
					Kind:   kind3,
					Limits: limits1,
					Name:   name8,
				})
			}
			var requestRate3 *shared.MeshGlobalRateLimitItemRequestRate
			if toItem.Default.HTTP.RequestRate != nil {
				var interval3 string
				interval3 = toItem.Default.HTTP.RequestRate.Interval.ValueString()

				var num3 int
				num3 = int(toItem.Default.HTTP.RequestRate.Num.ValueInt32())

				requestRate3 = &shared.MeshGlobalRateLimitItemRequestRate{
					Interval: interval3,
					Num:      num3,
				}
			}
			http1 := shared.MeshGlobalRateLimitItemSpecHTTP{
				Disabled:           disabled1,
				OnRateLimit:        onRateLimit1,
				RatelimitOnRequest: ratelimitOnRequest1,
				RequestRate:        requestRate3,
			}
			mode1 := new(shared.MeshGlobalRateLimitItemSpecMode)
			if !toItem.Default.Mode.IsUnknown() && !toItem.Default.Mode.IsNull() {
				*mode1 = shared.MeshGlobalRateLimitItemSpecMode(toItem.Default.Mode.ValueString())
			} else {
				mode1 = nil
			}
			default1 = &shared.MeshGlobalRateLimitItemSpecDefault{
				Backend: backend1,
				HTTP:    http1,
				Mode:    mode1,
			}
		}
		kind4 := shared.MeshGlobalRateLimitItemSpecToKind(toItem.TargetRef.Kind.ValueString())
		labels3 := make(map[string]string)
		for labelsKey2, labelsValue2 := range toItem.TargetRef.Labels {
			var labelsInst2 string
			labelsInst2 = labelsValue2.ValueString()

			labels3[labelsKey2] = labelsInst2
		}
		mesh3 := new(string)
		if !toItem.TargetRef.Mesh.IsUnknown() && !toItem.TargetRef.Mesh.IsNull() {
			*mesh3 = toItem.TargetRef.Mesh.ValueString()
		} else {
			mesh3 = nil
		}
		name9 := new(string)
		if !toItem.TargetRef.Name.IsUnknown() && !toItem.TargetRef.Name.IsNull() {
			*name9 = toItem.TargetRef.Name.ValueString()
		} else {
			name9 = nil
		}
		namespace2 := new(string)
		if !toItem.TargetRef.Namespace.IsUnknown() && !toItem.TargetRef.Namespace.IsNull() {
			*namespace2 = toItem.TargetRef.Namespace.ValueString()
		} else {
			namespace2 = nil
		}
		proxyTypes2 := make([]shared.MeshGlobalRateLimitItemSpecToProxyTypes, 0, len(toItem.TargetRef.ProxyTypes))
		for _, proxyTypesItem2 := range toItem.TargetRef.ProxyTypes {
			proxyTypes2 = append(proxyTypes2, shared.MeshGlobalRateLimitItemSpecToProxyTypes(proxyTypesItem2.ValueString()))
		}
		sectionName2 := new(string)
		if !toItem.TargetRef.SectionName.IsUnknown() && !toItem.TargetRef.SectionName.IsNull() {
			*sectionName2 = toItem.TargetRef.SectionName.ValueString()
		} else {
			sectionName2 = nil
		}
		tags2 := make(map[string]string)
		for tagsKey2, tagsValue2 := range toItem.TargetRef.Tags {
			var tagsInst2 string
			tagsInst2 = tagsValue2.ValueString()

			tags2[tagsKey2] = tagsInst2
		}
		targetRef2 := shared.MeshGlobalRateLimitItemSpecToTargetRef{
			Kind:        kind4,
			Labels:      labels3,
			Mesh:        mesh3,
			Name:        name9,
			Namespace:   namespace2,
			ProxyTypes:  proxyTypes2,
			SectionName: sectionName2,
			Tags:        tags2,
		}
		to = append(to, shared.MeshGlobalRateLimitItemTo{
			Default:   default1,
			TargetRef: targetRef2,
		})
	}
	spec := shared.MeshGlobalRateLimitItemSpec{
		From:      from,
		TargetRef: targetRef1,
		To:        to,
	}
	out := shared.MeshGlobalRateLimitItemInput{
		Type:   typeVar,
		Mesh:   mesh,
		Name:   name,
		Labels: labels,
		Spec:   spec,
	}

	return &out, diags
}
