// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package provider

import (
	"context"
	"github.com/Kong/shared-speakeasy/customtypes/kumalabels"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/kong/terraform-provider-kong-mesh/internal/provider/typeconvert"
	tfTypes "github.com/kong/terraform-provider-kong-mesh/internal/provider/types"
	"github.com/kong/terraform-provider-kong-mesh/internal/sdk/models/operations"
	"github.com/kong/terraform-provider-kong-mesh/internal/sdk/models/shared"
)

func (r *MeshCircuitBreakerResourceModel) ToSharedMeshCircuitBreakerItemInput(ctx context.Context) (*shared.MeshCircuitBreakerItemInput, diag.Diagnostics) {
	var diags diag.Diagnostics

	typeVar := shared.MeshCircuitBreakerItemType(r.Type.ValueString())
	mesh := new(string)
	if !r.Mesh.IsUnknown() && !r.Mesh.IsNull() {
		*mesh = r.Mesh.ValueString()
	} else {
		mesh = nil
	}
	var name string
	name = r.Name.ValueString()

	var labels map[string]string
	if !r.Labels.IsUnknown() && !r.Labels.IsNull() {
		diags.Append(r.Labels.ElementsAs(ctx, &labels, true)...)
	}
	from := make([]shared.MeshCircuitBreakerItemFrom, 0, len(r.Spec.From))
	for _, fromItem := range r.Spec.From {
		var defaultVar *shared.MeshCircuitBreakerItemDefault
		if fromItem.Default != nil {
			var connectionLimits *shared.ConnectionLimits
			if fromItem.Default.ConnectionLimits != nil {
				maxConnectionPools := new(int)
				if !fromItem.Default.ConnectionLimits.MaxConnectionPools.IsUnknown() && !fromItem.Default.ConnectionLimits.MaxConnectionPools.IsNull() {
					*maxConnectionPools = int(fromItem.Default.ConnectionLimits.MaxConnectionPools.ValueInt32())
				} else {
					maxConnectionPools = nil
				}
				maxConnections := new(int)
				if !fromItem.Default.ConnectionLimits.MaxConnections.IsUnknown() && !fromItem.Default.ConnectionLimits.MaxConnections.IsNull() {
					*maxConnections = int(fromItem.Default.ConnectionLimits.MaxConnections.ValueInt32())
				} else {
					maxConnections = nil
				}
				maxPendingRequests := new(int)
				if !fromItem.Default.ConnectionLimits.MaxPendingRequests.IsUnknown() && !fromItem.Default.ConnectionLimits.MaxPendingRequests.IsNull() {
					*maxPendingRequests = int(fromItem.Default.ConnectionLimits.MaxPendingRequests.ValueInt32())
				} else {
					maxPendingRequests = nil
				}
				maxRequests := new(int)
				if !fromItem.Default.ConnectionLimits.MaxRequests.IsUnknown() && !fromItem.Default.ConnectionLimits.MaxRequests.IsNull() {
					*maxRequests = int(fromItem.Default.ConnectionLimits.MaxRequests.ValueInt32())
				} else {
					maxRequests = nil
				}
				maxRetries := new(int)
				if !fromItem.Default.ConnectionLimits.MaxRetries.IsUnknown() && !fromItem.Default.ConnectionLimits.MaxRetries.IsNull() {
					*maxRetries = int(fromItem.Default.ConnectionLimits.MaxRetries.ValueInt32())
				} else {
					maxRetries = nil
				}
				connectionLimits = &shared.ConnectionLimits{
					MaxConnectionPools: maxConnectionPools,
					MaxConnections:     maxConnections,
					MaxPendingRequests: maxPendingRequests,
					MaxRequests:        maxRequests,
					MaxRetries:         maxRetries,
				}
			}
			var outlierDetection *shared.OutlierDetection
			if fromItem.Default.OutlierDetection != nil {
				baseEjectionTime := new(string)
				if !fromItem.Default.OutlierDetection.BaseEjectionTime.IsUnknown() && !fromItem.Default.OutlierDetection.BaseEjectionTime.IsNull() {
					*baseEjectionTime = fromItem.Default.OutlierDetection.BaseEjectionTime.ValueString()
				} else {
					baseEjectionTime = nil
				}
				var detectors *shared.Detectors
				if fromItem.Default.OutlierDetection.Detectors != nil {
					var failurePercentage *shared.FailurePercentage
					if fromItem.Default.OutlierDetection.Detectors.FailurePercentage != nil {
						minimumHosts := new(int)
						if !fromItem.Default.OutlierDetection.Detectors.FailurePercentage.MinimumHosts.IsUnknown() && !fromItem.Default.OutlierDetection.Detectors.FailurePercentage.MinimumHosts.IsNull() {
							*minimumHosts = int(fromItem.Default.OutlierDetection.Detectors.FailurePercentage.MinimumHosts.ValueInt32())
						} else {
							minimumHosts = nil
						}
						requestVolume := new(int)
						if !fromItem.Default.OutlierDetection.Detectors.FailurePercentage.RequestVolume.IsUnknown() && !fromItem.Default.OutlierDetection.Detectors.FailurePercentage.RequestVolume.IsNull() {
							*requestVolume = int(fromItem.Default.OutlierDetection.Detectors.FailurePercentage.RequestVolume.ValueInt32())
						} else {
							requestVolume = nil
						}
						threshold := new(int)
						if !fromItem.Default.OutlierDetection.Detectors.FailurePercentage.Threshold.IsUnknown() && !fromItem.Default.OutlierDetection.Detectors.FailurePercentage.Threshold.IsNull() {
							*threshold = int(fromItem.Default.OutlierDetection.Detectors.FailurePercentage.Threshold.ValueInt32())
						} else {
							threshold = nil
						}
						failurePercentage = &shared.FailurePercentage{
							MinimumHosts:  minimumHosts,
							RequestVolume: requestVolume,
							Threshold:     threshold,
						}
					}
					var gatewayFailures *shared.GatewayFailures
					if fromItem.Default.OutlierDetection.Detectors.GatewayFailures != nil {
						consecutive := new(int)
						if !fromItem.Default.OutlierDetection.Detectors.GatewayFailures.Consecutive.IsUnknown() && !fromItem.Default.OutlierDetection.Detectors.GatewayFailures.Consecutive.IsNull() {
							*consecutive = int(fromItem.Default.OutlierDetection.Detectors.GatewayFailures.Consecutive.ValueInt32())
						} else {
							consecutive = nil
						}
						gatewayFailures = &shared.GatewayFailures{
							Consecutive: consecutive,
						}
					}
					var localOriginFailures *shared.LocalOriginFailures
					if fromItem.Default.OutlierDetection.Detectors.LocalOriginFailures != nil {
						consecutive1 := new(int)
						if !fromItem.Default.OutlierDetection.Detectors.LocalOriginFailures.Consecutive.IsUnknown() && !fromItem.Default.OutlierDetection.Detectors.LocalOriginFailures.Consecutive.IsNull() {
							*consecutive1 = int(fromItem.Default.OutlierDetection.Detectors.LocalOriginFailures.Consecutive.ValueInt32())
						} else {
							consecutive1 = nil
						}
						localOriginFailures = &shared.LocalOriginFailures{
							Consecutive: consecutive1,
						}
					}
					var successRate *shared.SuccessRate
					if fromItem.Default.OutlierDetection.Detectors.SuccessRate != nil {
						minimumHosts1 := new(int)
						if !fromItem.Default.OutlierDetection.Detectors.SuccessRate.MinimumHosts.IsUnknown() && !fromItem.Default.OutlierDetection.Detectors.SuccessRate.MinimumHosts.IsNull() {
							*minimumHosts1 = int(fromItem.Default.OutlierDetection.Detectors.SuccessRate.MinimumHosts.ValueInt32())
						} else {
							minimumHosts1 = nil
						}
						requestVolume1 := new(int)
						if !fromItem.Default.OutlierDetection.Detectors.SuccessRate.RequestVolume.IsUnknown() && !fromItem.Default.OutlierDetection.Detectors.SuccessRate.RequestVolume.IsNull() {
							*requestVolume1 = int(fromItem.Default.OutlierDetection.Detectors.SuccessRate.RequestVolume.ValueInt32())
						} else {
							requestVolume1 = nil
						}
						var standardDeviationFactor *shared.StandardDeviationFactor
						if fromItem.Default.OutlierDetection.Detectors.SuccessRate.StandardDeviationFactor != nil {
							integer := new(int64)
							if !fromItem.Default.OutlierDetection.Detectors.SuccessRate.StandardDeviationFactor.Integer.IsUnknown() && !fromItem.Default.OutlierDetection.Detectors.SuccessRate.StandardDeviationFactor.Integer.IsNull() {
								*integer = fromItem.Default.OutlierDetection.Detectors.SuccessRate.StandardDeviationFactor.Integer.ValueInt64()
							} else {
								integer = nil
							}
							if integer != nil {
								standardDeviationFactor = &shared.StandardDeviationFactor{
									Integer: integer,
								}
							}
							str := new(string)
							if !fromItem.Default.OutlierDetection.Detectors.SuccessRate.StandardDeviationFactor.Str.IsUnknown() && !fromItem.Default.OutlierDetection.Detectors.SuccessRate.StandardDeviationFactor.Str.IsNull() {
								*str = fromItem.Default.OutlierDetection.Detectors.SuccessRate.StandardDeviationFactor.Str.ValueString()
							} else {
								str = nil
							}
							if str != nil {
								standardDeviationFactor = &shared.StandardDeviationFactor{
									Str: str,
								}
							}
						}
						successRate = &shared.SuccessRate{
							MinimumHosts:            minimumHosts1,
							RequestVolume:           requestVolume1,
							StandardDeviationFactor: standardDeviationFactor,
						}
					}
					var totalFailures *shared.TotalFailures
					if fromItem.Default.OutlierDetection.Detectors.TotalFailures != nil {
						consecutive2 := new(int)
						if !fromItem.Default.OutlierDetection.Detectors.TotalFailures.Consecutive.IsUnknown() && !fromItem.Default.OutlierDetection.Detectors.TotalFailures.Consecutive.IsNull() {
							*consecutive2 = int(fromItem.Default.OutlierDetection.Detectors.TotalFailures.Consecutive.ValueInt32())
						} else {
							consecutive2 = nil
						}
						totalFailures = &shared.TotalFailures{
							Consecutive: consecutive2,
						}
					}
					detectors = &shared.Detectors{
						FailurePercentage:   failurePercentage,
						GatewayFailures:     gatewayFailures,
						LocalOriginFailures: localOriginFailures,
						SuccessRate:         successRate,
						TotalFailures:       totalFailures,
					}
				}
				disabled := new(bool)
				if !fromItem.Default.OutlierDetection.Disabled.IsUnknown() && !fromItem.Default.OutlierDetection.Disabled.IsNull() {
					*disabled = fromItem.Default.OutlierDetection.Disabled.ValueBool()
				} else {
					disabled = nil
				}
				var healthyPanicThreshold *shared.MeshCircuitBreakerItemSpecFromHealthyPanicThreshold
				if fromItem.Default.OutlierDetection.HealthyPanicThreshold != nil {
					integer1 := new(int64)
					if !fromItem.Default.OutlierDetection.HealthyPanicThreshold.Integer.IsUnknown() && !fromItem.Default.OutlierDetection.HealthyPanicThreshold.Integer.IsNull() {
						*integer1 = fromItem.Default.OutlierDetection.HealthyPanicThreshold.Integer.ValueInt64()
					} else {
						integer1 = nil
					}
					if integer1 != nil {
						healthyPanicThreshold = &shared.MeshCircuitBreakerItemSpecFromHealthyPanicThreshold{
							Integer: integer1,
						}
					}
					str1 := new(string)
					if !fromItem.Default.OutlierDetection.HealthyPanicThreshold.Str.IsUnknown() && !fromItem.Default.OutlierDetection.HealthyPanicThreshold.Str.IsNull() {
						*str1 = fromItem.Default.OutlierDetection.HealthyPanicThreshold.Str.ValueString()
					} else {
						str1 = nil
					}
					if str1 != nil {
						healthyPanicThreshold = &shared.MeshCircuitBreakerItemSpecFromHealthyPanicThreshold{
							Str: str1,
						}
					}
				}
				interval := new(string)
				if !fromItem.Default.OutlierDetection.Interval.IsUnknown() && !fromItem.Default.OutlierDetection.Interval.IsNull() {
					*interval = fromItem.Default.OutlierDetection.Interval.ValueString()
				} else {
					interval = nil
				}
				maxEjectionPercent := new(int)
				if !fromItem.Default.OutlierDetection.MaxEjectionPercent.IsUnknown() && !fromItem.Default.OutlierDetection.MaxEjectionPercent.IsNull() {
					*maxEjectionPercent = int(fromItem.Default.OutlierDetection.MaxEjectionPercent.ValueInt32())
				} else {
					maxEjectionPercent = nil
				}
				splitExternalAndLocalErrors := new(bool)
				if !fromItem.Default.OutlierDetection.SplitExternalAndLocalErrors.IsUnknown() && !fromItem.Default.OutlierDetection.SplitExternalAndLocalErrors.IsNull() {
					*splitExternalAndLocalErrors = fromItem.Default.OutlierDetection.SplitExternalAndLocalErrors.ValueBool()
				} else {
					splitExternalAndLocalErrors = nil
				}
				outlierDetection = &shared.OutlierDetection{
					BaseEjectionTime:            baseEjectionTime,
					Detectors:                   detectors,
					Disabled:                    disabled,
					HealthyPanicThreshold:       healthyPanicThreshold,
					Interval:                    interval,
					MaxEjectionPercent:          maxEjectionPercent,
					SplitExternalAndLocalErrors: splitExternalAndLocalErrors,
				}
			}
			defaultVar = &shared.MeshCircuitBreakerItemDefault{
				ConnectionLimits: connectionLimits,
				OutlierDetection: outlierDetection,
			}
		}
		kind := shared.MeshCircuitBreakerItemSpecKind(fromItem.TargetRef.Kind.ValueString())
		labels1 := make(map[string]string)
		for labelsKey, labelsValue := range fromItem.TargetRef.Labels {
			var labelsInst string
			labelsInst = labelsValue.ValueString()

			labels1[labelsKey] = labelsInst
		}
		mesh1 := new(string)
		if !fromItem.TargetRef.Mesh.IsUnknown() && !fromItem.TargetRef.Mesh.IsNull() {
			*mesh1 = fromItem.TargetRef.Mesh.ValueString()
		} else {
			mesh1 = nil
		}
		name1 := new(string)
		if !fromItem.TargetRef.Name.IsUnknown() && !fromItem.TargetRef.Name.IsNull() {
			*name1 = fromItem.TargetRef.Name.ValueString()
		} else {
			name1 = nil
		}
		namespace := new(string)
		if !fromItem.TargetRef.Namespace.IsUnknown() && !fromItem.TargetRef.Namespace.IsNull() {
			*namespace = fromItem.TargetRef.Namespace.ValueString()
		} else {
			namespace = nil
		}
		proxyTypes := make([]shared.MeshCircuitBreakerItemSpecProxyTypes, 0, len(fromItem.TargetRef.ProxyTypes))
		for _, proxyTypesItem := range fromItem.TargetRef.ProxyTypes {
			proxyTypes = append(proxyTypes, shared.MeshCircuitBreakerItemSpecProxyTypes(proxyTypesItem.ValueString()))
		}
		sectionName := new(string)
		if !fromItem.TargetRef.SectionName.IsUnknown() && !fromItem.TargetRef.SectionName.IsNull() {
			*sectionName = fromItem.TargetRef.SectionName.ValueString()
		} else {
			sectionName = nil
		}
		tags := make(map[string]string)
		for tagsKey, tagsValue := range fromItem.TargetRef.Tags {
			var tagsInst string
			tagsInst = tagsValue.ValueString()

			tags[tagsKey] = tagsInst
		}
		targetRef := shared.MeshCircuitBreakerItemSpecTargetRef{
			Kind:        kind,
			Labels:      labels1,
			Mesh:        mesh1,
			Name:        name1,
			Namespace:   namespace,
			ProxyTypes:  proxyTypes,
			SectionName: sectionName,
			Tags:        tags,
		}
		from = append(from, shared.MeshCircuitBreakerItemFrom{
			Default:   defaultVar,
			TargetRef: targetRef,
		})
	}
	rules := make([]shared.MeshCircuitBreakerItemRules, 0, len(r.Spec.Rules))
	for _, rulesItem := range r.Spec.Rules {
		var default1 *shared.MeshCircuitBreakerItemSpecDefault
		if rulesItem.Default != nil {
			var connectionLimits1 *shared.MeshCircuitBreakerItemConnectionLimits
			if rulesItem.Default.ConnectionLimits != nil {
				maxConnectionPools1 := new(int)
				if !rulesItem.Default.ConnectionLimits.MaxConnectionPools.IsUnknown() && !rulesItem.Default.ConnectionLimits.MaxConnectionPools.IsNull() {
					*maxConnectionPools1 = int(rulesItem.Default.ConnectionLimits.MaxConnectionPools.ValueInt32())
				} else {
					maxConnectionPools1 = nil
				}
				maxConnections1 := new(int)
				if !rulesItem.Default.ConnectionLimits.MaxConnections.IsUnknown() && !rulesItem.Default.ConnectionLimits.MaxConnections.IsNull() {
					*maxConnections1 = int(rulesItem.Default.ConnectionLimits.MaxConnections.ValueInt32())
				} else {
					maxConnections1 = nil
				}
				maxPendingRequests1 := new(int)
				if !rulesItem.Default.ConnectionLimits.MaxPendingRequests.IsUnknown() && !rulesItem.Default.ConnectionLimits.MaxPendingRequests.IsNull() {
					*maxPendingRequests1 = int(rulesItem.Default.ConnectionLimits.MaxPendingRequests.ValueInt32())
				} else {
					maxPendingRequests1 = nil
				}
				maxRequests1 := new(int)
				if !rulesItem.Default.ConnectionLimits.MaxRequests.IsUnknown() && !rulesItem.Default.ConnectionLimits.MaxRequests.IsNull() {
					*maxRequests1 = int(rulesItem.Default.ConnectionLimits.MaxRequests.ValueInt32())
				} else {
					maxRequests1 = nil
				}
				maxRetries1 := new(int)
				if !rulesItem.Default.ConnectionLimits.MaxRetries.IsUnknown() && !rulesItem.Default.ConnectionLimits.MaxRetries.IsNull() {
					*maxRetries1 = int(rulesItem.Default.ConnectionLimits.MaxRetries.ValueInt32())
				} else {
					maxRetries1 = nil
				}
				connectionLimits1 = &shared.MeshCircuitBreakerItemConnectionLimits{
					MaxConnectionPools: maxConnectionPools1,
					MaxConnections:     maxConnections1,
					MaxPendingRequests: maxPendingRequests1,
					MaxRequests:        maxRequests1,
					MaxRetries:         maxRetries1,
				}
			}
			var outlierDetection1 *shared.MeshCircuitBreakerItemOutlierDetection
			if rulesItem.Default.OutlierDetection != nil {
				baseEjectionTime1 := new(string)
				if !rulesItem.Default.OutlierDetection.BaseEjectionTime.IsUnknown() && !rulesItem.Default.OutlierDetection.BaseEjectionTime.IsNull() {
					*baseEjectionTime1 = rulesItem.Default.OutlierDetection.BaseEjectionTime.ValueString()
				} else {
					baseEjectionTime1 = nil
				}
				var detectors1 *shared.MeshCircuitBreakerItemDetectors
				if rulesItem.Default.OutlierDetection.Detectors != nil {
					var failurePercentage1 *shared.MeshCircuitBreakerItemFailurePercentage
					if rulesItem.Default.OutlierDetection.Detectors.FailurePercentage != nil {
						minimumHosts2 := new(int)
						if !rulesItem.Default.OutlierDetection.Detectors.FailurePercentage.MinimumHosts.IsUnknown() && !rulesItem.Default.OutlierDetection.Detectors.FailurePercentage.MinimumHosts.IsNull() {
							*minimumHosts2 = int(rulesItem.Default.OutlierDetection.Detectors.FailurePercentage.MinimumHosts.ValueInt32())
						} else {
							minimumHosts2 = nil
						}
						requestVolume2 := new(int)
						if !rulesItem.Default.OutlierDetection.Detectors.FailurePercentage.RequestVolume.IsUnknown() && !rulesItem.Default.OutlierDetection.Detectors.FailurePercentage.RequestVolume.IsNull() {
							*requestVolume2 = int(rulesItem.Default.OutlierDetection.Detectors.FailurePercentage.RequestVolume.ValueInt32())
						} else {
							requestVolume2 = nil
						}
						threshold1 := new(int)
						if !rulesItem.Default.OutlierDetection.Detectors.FailurePercentage.Threshold.IsUnknown() && !rulesItem.Default.OutlierDetection.Detectors.FailurePercentage.Threshold.IsNull() {
							*threshold1 = int(rulesItem.Default.OutlierDetection.Detectors.FailurePercentage.Threshold.ValueInt32())
						} else {
							threshold1 = nil
						}
						failurePercentage1 = &shared.MeshCircuitBreakerItemFailurePercentage{
							MinimumHosts:  minimumHosts2,
							RequestVolume: requestVolume2,
							Threshold:     threshold1,
						}
					}
					var gatewayFailures1 *shared.MeshCircuitBreakerItemGatewayFailures
					if rulesItem.Default.OutlierDetection.Detectors.GatewayFailures != nil {
						consecutive3 := new(int)
						if !rulesItem.Default.OutlierDetection.Detectors.GatewayFailures.Consecutive.IsUnknown() && !rulesItem.Default.OutlierDetection.Detectors.GatewayFailures.Consecutive.IsNull() {
							*consecutive3 = int(rulesItem.Default.OutlierDetection.Detectors.GatewayFailures.Consecutive.ValueInt32())
						} else {
							consecutive3 = nil
						}
						gatewayFailures1 = &shared.MeshCircuitBreakerItemGatewayFailures{
							Consecutive: consecutive3,
						}
					}
					var localOriginFailures1 *shared.MeshCircuitBreakerItemLocalOriginFailures
					if rulesItem.Default.OutlierDetection.Detectors.LocalOriginFailures != nil {
						consecutive4 := new(int)
						if !rulesItem.Default.OutlierDetection.Detectors.LocalOriginFailures.Consecutive.IsUnknown() && !rulesItem.Default.OutlierDetection.Detectors.LocalOriginFailures.Consecutive.IsNull() {
							*consecutive4 = int(rulesItem.Default.OutlierDetection.Detectors.LocalOriginFailures.Consecutive.ValueInt32())
						} else {
							consecutive4 = nil
						}
						localOriginFailures1 = &shared.MeshCircuitBreakerItemLocalOriginFailures{
							Consecutive: consecutive4,
						}
					}
					var successRate1 *shared.MeshCircuitBreakerItemSuccessRate
					if rulesItem.Default.OutlierDetection.Detectors.SuccessRate != nil {
						minimumHosts3 := new(int)
						if !rulesItem.Default.OutlierDetection.Detectors.SuccessRate.MinimumHosts.IsUnknown() && !rulesItem.Default.OutlierDetection.Detectors.SuccessRate.MinimumHosts.IsNull() {
							*minimumHosts3 = int(rulesItem.Default.OutlierDetection.Detectors.SuccessRate.MinimumHosts.ValueInt32())
						} else {
							minimumHosts3 = nil
						}
						requestVolume3 := new(int)
						if !rulesItem.Default.OutlierDetection.Detectors.SuccessRate.RequestVolume.IsUnknown() && !rulesItem.Default.OutlierDetection.Detectors.SuccessRate.RequestVolume.IsNull() {
							*requestVolume3 = int(rulesItem.Default.OutlierDetection.Detectors.SuccessRate.RequestVolume.ValueInt32())
						} else {
							requestVolume3 = nil
						}
						var standardDeviationFactor1 *shared.MeshCircuitBreakerItemStandardDeviationFactor
						if rulesItem.Default.OutlierDetection.Detectors.SuccessRate.StandardDeviationFactor != nil {
							integer2 := new(int64)
							if !rulesItem.Default.OutlierDetection.Detectors.SuccessRate.StandardDeviationFactor.Integer.IsUnknown() && !rulesItem.Default.OutlierDetection.Detectors.SuccessRate.StandardDeviationFactor.Integer.IsNull() {
								*integer2 = rulesItem.Default.OutlierDetection.Detectors.SuccessRate.StandardDeviationFactor.Integer.ValueInt64()
							} else {
								integer2 = nil
							}
							if integer2 != nil {
								standardDeviationFactor1 = &shared.MeshCircuitBreakerItemStandardDeviationFactor{
									Integer: integer2,
								}
							}
							str2 := new(string)
							if !rulesItem.Default.OutlierDetection.Detectors.SuccessRate.StandardDeviationFactor.Str.IsUnknown() && !rulesItem.Default.OutlierDetection.Detectors.SuccessRate.StandardDeviationFactor.Str.IsNull() {
								*str2 = rulesItem.Default.OutlierDetection.Detectors.SuccessRate.StandardDeviationFactor.Str.ValueString()
							} else {
								str2 = nil
							}
							if str2 != nil {
								standardDeviationFactor1 = &shared.MeshCircuitBreakerItemStandardDeviationFactor{
									Str: str2,
								}
							}
						}
						successRate1 = &shared.MeshCircuitBreakerItemSuccessRate{
							MinimumHosts:            minimumHosts3,
							RequestVolume:           requestVolume3,
							StandardDeviationFactor: standardDeviationFactor1,
						}
					}
					var totalFailures1 *shared.MeshCircuitBreakerItemTotalFailures
					if rulesItem.Default.OutlierDetection.Detectors.TotalFailures != nil {
						consecutive5 := new(int)
						if !rulesItem.Default.OutlierDetection.Detectors.TotalFailures.Consecutive.IsUnknown() && !rulesItem.Default.OutlierDetection.Detectors.TotalFailures.Consecutive.IsNull() {
							*consecutive5 = int(rulesItem.Default.OutlierDetection.Detectors.TotalFailures.Consecutive.ValueInt32())
						} else {
							consecutive5 = nil
						}
						totalFailures1 = &shared.MeshCircuitBreakerItemTotalFailures{
							Consecutive: consecutive5,
						}
					}
					detectors1 = &shared.MeshCircuitBreakerItemDetectors{
						FailurePercentage:   failurePercentage1,
						GatewayFailures:     gatewayFailures1,
						LocalOriginFailures: localOriginFailures1,
						SuccessRate:         successRate1,
						TotalFailures:       totalFailures1,
					}
				}
				disabled1 := new(bool)
				if !rulesItem.Default.OutlierDetection.Disabled.IsUnknown() && !rulesItem.Default.OutlierDetection.Disabled.IsNull() {
					*disabled1 = rulesItem.Default.OutlierDetection.Disabled.ValueBool()
				} else {
					disabled1 = nil
				}
				var healthyPanicThreshold1 *shared.MeshCircuitBreakerItemHealthyPanicThreshold
				if rulesItem.Default.OutlierDetection.HealthyPanicThreshold != nil {
					integer3 := new(int64)
					if !rulesItem.Default.OutlierDetection.HealthyPanicThreshold.Integer.IsUnknown() && !rulesItem.Default.OutlierDetection.HealthyPanicThreshold.Integer.IsNull() {
						*integer3 = rulesItem.Default.OutlierDetection.HealthyPanicThreshold.Integer.ValueInt64()
					} else {
						integer3 = nil
					}
					if integer3 != nil {
						healthyPanicThreshold1 = &shared.MeshCircuitBreakerItemHealthyPanicThreshold{
							Integer: integer3,
						}
					}
					str3 := new(string)
					if !rulesItem.Default.OutlierDetection.HealthyPanicThreshold.Str.IsUnknown() && !rulesItem.Default.OutlierDetection.HealthyPanicThreshold.Str.IsNull() {
						*str3 = rulesItem.Default.OutlierDetection.HealthyPanicThreshold.Str.ValueString()
					} else {
						str3 = nil
					}
					if str3 != nil {
						healthyPanicThreshold1 = &shared.MeshCircuitBreakerItemHealthyPanicThreshold{
							Str: str3,
						}
					}
				}
				interval1 := new(string)
				if !rulesItem.Default.OutlierDetection.Interval.IsUnknown() && !rulesItem.Default.OutlierDetection.Interval.IsNull() {
					*interval1 = rulesItem.Default.OutlierDetection.Interval.ValueString()
				} else {
					interval1 = nil
				}
				maxEjectionPercent1 := new(int)
				if !rulesItem.Default.OutlierDetection.MaxEjectionPercent.IsUnknown() && !rulesItem.Default.OutlierDetection.MaxEjectionPercent.IsNull() {
					*maxEjectionPercent1 = int(rulesItem.Default.OutlierDetection.MaxEjectionPercent.ValueInt32())
				} else {
					maxEjectionPercent1 = nil
				}
				splitExternalAndLocalErrors1 := new(bool)
				if !rulesItem.Default.OutlierDetection.SplitExternalAndLocalErrors.IsUnknown() && !rulesItem.Default.OutlierDetection.SplitExternalAndLocalErrors.IsNull() {
					*splitExternalAndLocalErrors1 = rulesItem.Default.OutlierDetection.SplitExternalAndLocalErrors.ValueBool()
				} else {
					splitExternalAndLocalErrors1 = nil
				}
				outlierDetection1 = &shared.MeshCircuitBreakerItemOutlierDetection{
					BaseEjectionTime:            baseEjectionTime1,
					Detectors:                   detectors1,
					Disabled:                    disabled1,
					HealthyPanicThreshold:       healthyPanicThreshold1,
					Interval:                    interval1,
					MaxEjectionPercent:          maxEjectionPercent1,
					SplitExternalAndLocalErrors: splitExternalAndLocalErrors1,
				}
			}
			default1 = &shared.MeshCircuitBreakerItemSpecDefault{
				ConnectionLimits: connectionLimits1,
				OutlierDetection: outlierDetection1,
			}
		}
		rules = append(rules, shared.MeshCircuitBreakerItemRules{
			Default: default1,
		})
	}
	var targetRef1 *shared.MeshCircuitBreakerItemTargetRef
	if r.Spec.TargetRef != nil {
		kind1 := shared.MeshCircuitBreakerItemKind(r.Spec.TargetRef.Kind.ValueString())
		labels2 := make(map[string]string)
		for labelsKey1, labelsValue1 := range r.Spec.TargetRef.Labels {
			var labelsInst1 string
			labelsInst1 = labelsValue1.ValueString()

			labels2[labelsKey1] = labelsInst1
		}
		mesh2 := new(string)
		if !r.Spec.TargetRef.Mesh.IsUnknown() && !r.Spec.TargetRef.Mesh.IsNull() {
			*mesh2 = r.Spec.TargetRef.Mesh.ValueString()
		} else {
			mesh2 = nil
		}
		name2 := new(string)
		if !r.Spec.TargetRef.Name.IsUnknown() && !r.Spec.TargetRef.Name.IsNull() {
			*name2 = r.Spec.TargetRef.Name.ValueString()
		} else {
			name2 = nil
		}
		namespace1 := new(string)
		if !r.Spec.TargetRef.Namespace.IsUnknown() && !r.Spec.TargetRef.Namespace.IsNull() {
			*namespace1 = r.Spec.TargetRef.Namespace.ValueString()
		} else {
			namespace1 = nil
		}
		proxyTypes1 := make([]shared.MeshCircuitBreakerItemProxyTypes, 0, len(r.Spec.TargetRef.ProxyTypes))
		for _, proxyTypesItem1 := range r.Spec.TargetRef.ProxyTypes {
			proxyTypes1 = append(proxyTypes1, shared.MeshCircuitBreakerItemProxyTypes(proxyTypesItem1.ValueString()))
		}
		sectionName1 := new(string)
		if !r.Spec.TargetRef.SectionName.IsUnknown() && !r.Spec.TargetRef.SectionName.IsNull() {
			*sectionName1 = r.Spec.TargetRef.SectionName.ValueString()
		} else {
			sectionName1 = nil
		}
		tags1 := make(map[string]string)
		for tagsKey1, tagsValue1 := range r.Spec.TargetRef.Tags {
			var tagsInst1 string
			tagsInst1 = tagsValue1.ValueString()

			tags1[tagsKey1] = tagsInst1
		}
		targetRef1 = &shared.MeshCircuitBreakerItemTargetRef{
			Kind:        kind1,
			Labels:      labels2,
			Mesh:        mesh2,
			Name:        name2,
			Namespace:   namespace1,
			ProxyTypes:  proxyTypes1,
			SectionName: sectionName1,
			Tags:        tags1,
		}
	}
	to := make([]shared.MeshCircuitBreakerItemTo, 0, len(r.Spec.To))
	for _, toItem := range r.Spec.To {
		var default2 *shared.MeshCircuitBreakerItemSpecToDefault
		if toItem.Default != nil {
			var connectionLimits2 *shared.MeshCircuitBreakerItemSpecConnectionLimits
			if toItem.Default.ConnectionLimits != nil {
				maxConnectionPools2 := new(int)
				if !toItem.Default.ConnectionLimits.MaxConnectionPools.IsUnknown() && !toItem.Default.ConnectionLimits.MaxConnectionPools.IsNull() {
					*maxConnectionPools2 = int(toItem.Default.ConnectionLimits.MaxConnectionPools.ValueInt32())
				} else {
					maxConnectionPools2 = nil
				}
				maxConnections2 := new(int)
				if !toItem.Default.ConnectionLimits.MaxConnections.IsUnknown() && !toItem.Default.ConnectionLimits.MaxConnections.IsNull() {
					*maxConnections2 = int(toItem.Default.ConnectionLimits.MaxConnections.ValueInt32())
				} else {
					maxConnections2 = nil
				}
				maxPendingRequests2 := new(int)
				if !toItem.Default.ConnectionLimits.MaxPendingRequests.IsUnknown() && !toItem.Default.ConnectionLimits.MaxPendingRequests.IsNull() {
					*maxPendingRequests2 = int(toItem.Default.ConnectionLimits.MaxPendingRequests.ValueInt32())
				} else {
					maxPendingRequests2 = nil
				}
				maxRequests2 := new(int)
				if !toItem.Default.ConnectionLimits.MaxRequests.IsUnknown() && !toItem.Default.ConnectionLimits.MaxRequests.IsNull() {
					*maxRequests2 = int(toItem.Default.ConnectionLimits.MaxRequests.ValueInt32())
				} else {
					maxRequests2 = nil
				}
				maxRetries2 := new(int)
				if !toItem.Default.ConnectionLimits.MaxRetries.IsUnknown() && !toItem.Default.ConnectionLimits.MaxRetries.IsNull() {
					*maxRetries2 = int(toItem.Default.ConnectionLimits.MaxRetries.ValueInt32())
				} else {
					maxRetries2 = nil
				}
				connectionLimits2 = &shared.MeshCircuitBreakerItemSpecConnectionLimits{
					MaxConnectionPools: maxConnectionPools2,
					MaxConnections:     maxConnections2,
					MaxPendingRequests: maxPendingRequests2,
					MaxRequests:        maxRequests2,
					MaxRetries:         maxRetries2,
				}
			}
			var outlierDetection2 *shared.MeshCircuitBreakerItemSpecOutlierDetection
			if toItem.Default.OutlierDetection != nil {
				baseEjectionTime2 := new(string)
				if !toItem.Default.OutlierDetection.BaseEjectionTime.IsUnknown() && !toItem.Default.OutlierDetection.BaseEjectionTime.IsNull() {
					*baseEjectionTime2 = toItem.Default.OutlierDetection.BaseEjectionTime.ValueString()
				} else {
					baseEjectionTime2 = nil
				}
				var detectors2 *shared.MeshCircuitBreakerItemSpecDetectors
				if toItem.Default.OutlierDetection.Detectors != nil {
					var failurePercentage2 *shared.MeshCircuitBreakerItemSpecFailurePercentage
					if toItem.Default.OutlierDetection.Detectors.FailurePercentage != nil {
						minimumHosts4 := new(int)
						if !toItem.Default.OutlierDetection.Detectors.FailurePercentage.MinimumHosts.IsUnknown() && !toItem.Default.OutlierDetection.Detectors.FailurePercentage.MinimumHosts.IsNull() {
							*minimumHosts4 = int(toItem.Default.OutlierDetection.Detectors.FailurePercentage.MinimumHosts.ValueInt32())
						} else {
							minimumHosts4 = nil
						}
						requestVolume4 := new(int)
						if !toItem.Default.OutlierDetection.Detectors.FailurePercentage.RequestVolume.IsUnknown() && !toItem.Default.OutlierDetection.Detectors.FailurePercentage.RequestVolume.IsNull() {
							*requestVolume4 = int(toItem.Default.OutlierDetection.Detectors.FailurePercentage.RequestVolume.ValueInt32())
						} else {
							requestVolume4 = nil
						}
						threshold2 := new(int)
						if !toItem.Default.OutlierDetection.Detectors.FailurePercentage.Threshold.IsUnknown() && !toItem.Default.OutlierDetection.Detectors.FailurePercentage.Threshold.IsNull() {
							*threshold2 = int(toItem.Default.OutlierDetection.Detectors.FailurePercentage.Threshold.ValueInt32())
						} else {
							threshold2 = nil
						}
						failurePercentage2 = &shared.MeshCircuitBreakerItemSpecFailurePercentage{
							MinimumHosts:  minimumHosts4,
							RequestVolume: requestVolume4,
							Threshold:     threshold2,
						}
					}
					var gatewayFailures2 *shared.MeshCircuitBreakerItemSpecGatewayFailures
					if toItem.Default.OutlierDetection.Detectors.GatewayFailures != nil {
						consecutive6 := new(int)
						if !toItem.Default.OutlierDetection.Detectors.GatewayFailures.Consecutive.IsUnknown() && !toItem.Default.OutlierDetection.Detectors.GatewayFailures.Consecutive.IsNull() {
							*consecutive6 = int(toItem.Default.OutlierDetection.Detectors.GatewayFailures.Consecutive.ValueInt32())
						} else {
							consecutive6 = nil
						}
						gatewayFailures2 = &shared.MeshCircuitBreakerItemSpecGatewayFailures{
							Consecutive: consecutive6,
						}
					}
					var localOriginFailures2 *shared.MeshCircuitBreakerItemSpecLocalOriginFailures
					if toItem.Default.OutlierDetection.Detectors.LocalOriginFailures != nil {
						consecutive7 := new(int)
						if !toItem.Default.OutlierDetection.Detectors.LocalOriginFailures.Consecutive.IsUnknown() && !toItem.Default.OutlierDetection.Detectors.LocalOriginFailures.Consecutive.IsNull() {
							*consecutive7 = int(toItem.Default.OutlierDetection.Detectors.LocalOriginFailures.Consecutive.ValueInt32())
						} else {
							consecutive7 = nil
						}
						localOriginFailures2 = &shared.MeshCircuitBreakerItemSpecLocalOriginFailures{
							Consecutive: consecutive7,
						}
					}
					var successRate2 *shared.MeshCircuitBreakerItemSpecSuccessRate
					if toItem.Default.OutlierDetection.Detectors.SuccessRate != nil {
						minimumHosts5 := new(int)
						if !toItem.Default.OutlierDetection.Detectors.SuccessRate.MinimumHosts.IsUnknown() && !toItem.Default.OutlierDetection.Detectors.SuccessRate.MinimumHosts.IsNull() {
							*minimumHosts5 = int(toItem.Default.OutlierDetection.Detectors.SuccessRate.MinimumHosts.ValueInt32())
						} else {
							minimumHosts5 = nil
						}
						requestVolume5 := new(int)
						if !toItem.Default.OutlierDetection.Detectors.SuccessRate.RequestVolume.IsUnknown() && !toItem.Default.OutlierDetection.Detectors.SuccessRate.RequestVolume.IsNull() {
							*requestVolume5 = int(toItem.Default.OutlierDetection.Detectors.SuccessRate.RequestVolume.ValueInt32())
						} else {
							requestVolume5 = nil
						}
						var standardDeviationFactor2 *shared.MeshCircuitBreakerItemSpecStandardDeviationFactor
						if toItem.Default.OutlierDetection.Detectors.SuccessRate.StandardDeviationFactor != nil {
							integer4 := new(int64)
							if !toItem.Default.OutlierDetection.Detectors.SuccessRate.StandardDeviationFactor.Integer.IsUnknown() && !toItem.Default.OutlierDetection.Detectors.SuccessRate.StandardDeviationFactor.Integer.IsNull() {
								*integer4 = toItem.Default.OutlierDetection.Detectors.SuccessRate.StandardDeviationFactor.Integer.ValueInt64()
							} else {
								integer4 = nil
							}
							if integer4 != nil {
								standardDeviationFactor2 = &shared.MeshCircuitBreakerItemSpecStandardDeviationFactor{
									Integer: integer4,
								}
							}
							str4 := new(string)
							if !toItem.Default.OutlierDetection.Detectors.SuccessRate.StandardDeviationFactor.Str.IsUnknown() && !toItem.Default.OutlierDetection.Detectors.SuccessRate.StandardDeviationFactor.Str.IsNull() {
								*str4 = toItem.Default.OutlierDetection.Detectors.SuccessRate.StandardDeviationFactor.Str.ValueString()
							} else {
								str4 = nil
							}
							if str4 != nil {
								standardDeviationFactor2 = &shared.MeshCircuitBreakerItemSpecStandardDeviationFactor{
									Str: str4,
								}
							}
						}
						successRate2 = &shared.MeshCircuitBreakerItemSpecSuccessRate{
							MinimumHosts:            minimumHosts5,
							RequestVolume:           requestVolume5,
							StandardDeviationFactor: standardDeviationFactor2,
						}
					}
					var totalFailures2 *shared.MeshCircuitBreakerItemSpecTotalFailures
					if toItem.Default.OutlierDetection.Detectors.TotalFailures != nil {
						consecutive8 := new(int)
						if !toItem.Default.OutlierDetection.Detectors.TotalFailures.Consecutive.IsUnknown() && !toItem.Default.OutlierDetection.Detectors.TotalFailures.Consecutive.IsNull() {
							*consecutive8 = int(toItem.Default.OutlierDetection.Detectors.TotalFailures.Consecutive.ValueInt32())
						} else {
							consecutive8 = nil
						}
						totalFailures2 = &shared.MeshCircuitBreakerItemSpecTotalFailures{
							Consecutive: consecutive8,
						}
					}
					detectors2 = &shared.MeshCircuitBreakerItemSpecDetectors{
						FailurePercentage:   failurePercentage2,
						GatewayFailures:     gatewayFailures2,
						LocalOriginFailures: localOriginFailures2,
						SuccessRate:         successRate2,
						TotalFailures:       totalFailures2,
					}
				}
				disabled2 := new(bool)
				if !toItem.Default.OutlierDetection.Disabled.IsUnknown() && !toItem.Default.OutlierDetection.Disabled.IsNull() {
					*disabled2 = toItem.Default.OutlierDetection.Disabled.ValueBool()
				} else {
					disabled2 = nil
				}
				var healthyPanicThreshold2 *shared.MeshCircuitBreakerItemSpecHealthyPanicThreshold
				if toItem.Default.OutlierDetection.HealthyPanicThreshold != nil {
					integer5 := new(int64)
					if !toItem.Default.OutlierDetection.HealthyPanicThreshold.Integer.IsUnknown() && !toItem.Default.OutlierDetection.HealthyPanicThreshold.Integer.IsNull() {
						*integer5 = toItem.Default.OutlierDetection.HealthyPanicThreshold.Integer.ValueInt64()
					} else {
						integer5 = nil
					}
					if integer5 != nil {
						healthyPanicThreshold2 = &shared.MeshCircuitBreakerItemSpecHealthyPanicThreshold{
							Integer: integer5,
						}
					}
					str5 := new(string)
					if !toItem.Default.OutlierDetection.HealthyPanicThreshold.Str.IsUnknown() && !toItem.Default.OutlierDetection.HealthyPanicThreshold.Str.IsNull() {
						*str5 = toItem.Default.OutlierDetection.HealthyPanicThreshold.Str.ValueString()
					} else {
						str5 = nil
					}
					if str5 != nil {
						healthyPanicThreshold2 = &shared.MeshCircuitBreakerItemSpecHealthyPanicThreshold{
							Str: str5,
						}
					}
				}
				interval2 := new(string)
				if !toItem.Default.OutlierDetection.Interval.IsUnknown() && !toItem.Default.OutlierDetection.Interval.IsNull() {
					*interval2 = toItem.Default.OutlierDetection.Interval.ValueString()
				} else {
					interval2 = nil
				}
				maxEjectionPercent2 := new(int)
				if !toItem.Default.OutlierDetection.MaxEjectionPercent.IsUnknown() && !toItem.Default.OutlierDetection.MaxEjectionPercent.IsNull() {
					*maxEjectionPercent2 = int(toItem.Default.OutlierDetection.MaxEjectionPercent.ValueInt32())
				} else {
					maxEjectionPercent2 = nil
				}
				splitExternalAndLocalErrors2 := new(bool)
				if !toItem.Default.OutlierDetection.SplitExternalAndLocalErrors.IsUnknown() && !toItem.Default.OutlierDetection.SplitExternalAndLocalErrors.IsNull() {
					*splitExternalAndLocalErrors2 = toItem.Default.OutlierDetection.SplitExternalAndLocalErrors.ValueBool()
				} else {
					splitExternalAndLocalErrors2 = nil
				}
				outlierDetection2 = &shared.MeshCircuitBreakerItemSpecOutlierDetection{
					BaseEjectionTime:            baseEjectionTime2,
					Detectors:                   detectors2,
					Disabled:                    disabled2,
					HealthyPanicThreshold:       healthyPanicThreshold2,
					Interval:                    interval2,
					MaxEjectionPercent:          maxEjectionPercent2,
					SplitExternalAndLocalErrors: splitExternalAndLocalErrors2,
				}
			}
			default2 = &shared.MeshCircuitBreakerItemSpecToDefault{
				ConnectionLimits: connectionLimits2,
				OutlierDetection: outlierDetection2,
			}
		}
		kind2 := shared.MeshCircuitBreakerItemSpecToKind(toItem.TargetRef.Kind.ValueString())
		labels3 := make(map[string]string)
		for labelsKey2, labelsValue2 := range toItem.TargetRef.Labels {
			var labelsInst2 string
			labelsInst2 = labelsValue2.ValueString()

			labels3[labelsKey2] = labelsInst2
		}
		mesh3 := new(string)
		if !toItem.TargetRef.Mesh.IsUnknown() && !toItem.TargetRef.Mesh.IsNull() {
			*mesh3 = toItem.TargetRef.Mesh.ValueString()
		} else {
			mesh3 = nil
		}
		name3 := new(string)
		if !toItem.TargetRef.Name.IsUnknown() && !toItem.TargetRef.Name.IsNull() {
			*name3 = toItem.TargetRef.Name.ValueString()
		} else {
			name3 = nil
		}
		namespace2 := new(string)
		if !toItem.TargetRef.Namespace.IsUnknown() && !toItem.TargetRef.Namespace.IsNull() {
			*namespace2 = toItem.TargetRef.Namespace.ValueString()
		} else {
			namespace2 = nil
		}
		proxyTypes2 := make([]shared.MeshCircuitBreakerItemSpecToProxyTypes, 0, len(toItem.TargetRef.ProxyTypes))
		for _, proxyTypesItem2 := range toItem.TargetRef.ProxyTypes {
			proxyTypes2 = append(proxyTypes2, shared.MeshCircuitBreakerItemSpecToProxyTypes(proxyTypesItem2.ValueString()))
		}
		sectionName2 := new(string)
		if !toItem.TargetRef.SectionName.IsUnknown() && !toItem.TargetRef.SectionName.IsNull() {
			*sectionName2 = toItem.TargetRef.SectionName.ValueString()
		} else {
			sectionName2 = nil
		}
		tags2 := make(map[string]string)
		for tagsKey2, tagsValue2 := range toItem.TargetRef.Tags {
			var tagsInst2 string
			tagsInst2 = tagsValue2.ValueString()

			tags2[tagsKey2] = tagsInst2
		}
		targetRef2 := shared.MeshCircuitBreakerItemSpecToTargetRef{
			Kind:        kind2,
			Labels:      labels3,
			Mesh:        mesh3,
			Name:        name3,
			Namespace:   namespace2,
			ProxyTypes:  proxyTypes2,
			SectionName: sectionName2,
			Tags:        tags2,
		}
		to = append(to, shared.MeshCircuitBreakerItemTo{
			Default:   default2,
			TargetRef: targetRef2,
		})
	}
	spec := shared.MeshCircuitBreakerItemSpec{
		From:      from,
		Rules:     rules,
		TargetRef: targetRef1,
		To:        to,
	}
	out := shared.MeshCircuitBreakerItemInput{
		Type:   typeVar,
		Mesh:   mesh,
		Name:   name,
		Labels: labels,
		Spec:   spec,
	}

	return &out, diags
}

func (r *MeshCircuitBreakerResourceModel) ToOperationsCreateMeshCircuitBreakerRequest(ctx context.Context) (*operations.CreateMeshCircuitBreakerRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var mesh string
	mesh = r.Mesh.ValueString()

	var name string
	name = r.Name.ValueString()

	meshCircuitBreakerItem, meshCircuitBreakerItemDiags := r.ToSharedMeshCircuitBreakerItemInput(ctx)
	diags.Append(meshCircuitBreakerItemDiags...)

	if diags.HasError() {
		return nil, diags
	}

	out := operations.CreateMeshCircuitBreakerRequest{
		Mesh:                   mesh,
		Name:                   name,
		MeshCircuitBreakerItem: *meshCircuitBreakerItem,
	}

	return &out, diags
}

func (r *MeshCircuitBreakerResourceModel) ToOperationsUpdateMeshCircuitBreakerRequest(ctx context.Context) (*operations.UpdateMeshCircuitBreakerRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var mesh string
	mesh = r.Mesh.ValueString()

	var name string
	name = r.Name.ValueString()

	meshCircuitBreakerItem, meshCircuitBreakerItemDiags := r.ToSharedMeshCircuitBreakerItemInput(ctx)
	diags.Append(meshCircuitBreakerItemDiags...)

	if diags.HasError() {
		return nil, diags
	}

	out := operations.UpdateMeshCircuitBreakerRequest{
		Mesh:                   mesh,
		Name:                   name,
		MeshCircuitBreakerItem: *meshCircuitBreakerItem,
	}

	return &out, diags
}

func (r *MeshCircuitBreakerResourceModel) ToOperationsGetMeshCircuitBreakerRequest(ctx context.Context) (*operations.GetMeshCircuitBreakerRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var mesh string
	mesh = r.Mesh.ValueString()

	var name string
	name = r.Name.ValueString()

	out := operations.GetMeshCircuitBreakerRequest{
		Mesh: mesh,
		Name: name,
	}

	return &out, diags
}

func (r *MeshCircuitBreakerResourceModel) ToOperationsDeleteMeshCircuitBreakerRequest(ctx context.Context) (*operations.DeleteMeshCircuitBreakerRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var mesh string
	mesh = r.Mesh.ValueString()

	var name string
	name = r.Name.ValueString()

	out := operations.DeleteMeshCircuitBreakerRequest{
		Mesh: mesh,
		Name: name,
	}

	return &out, diags
}

func (r *MeshCircuitBreakerResourceModel) RefreshFromSharedMeshCircuitBreakerCreateOrUpdateSuccessResponse(ctx context.Context, resp *shared.MeshCircuitBreakerCreateOrUpdateSuccessResponse) diag.Diagnostics {
	var diags diag.Diagnostics

	if resp != nil {
		r.Warnings = make([]types.String, 0, len(resp.Warnings))
		for _, v := range resp.Warnings {
			r.Warnings = append(r.Warnings, types.StringValue(v))
		}
	}

	return diags
}

func (r *MeshCircuitBreakerResourceModel) RefreshFromSharedMeshCircuitBreakerItem(ctx context.Context, resp *shared.MeshCircuitBreakerItem) diag.Diagnostics {
	var diags diag.Diagnostics

	if resp != nil {
		r.CreationTime = types.StringPointerValue(typeconvert.TimePointerToStringPointer(resp.CreationTime))
		labelsValue, labelsDiags := types.MapValueFrom(ctx, types.StringType, resp.Labels)
		diags.Append(labelsDiags...)
		labelsValuable, labelsDiags := kumalabels.KumaLabelsMapType{MapType: types.MapType{ElemType: types.StringType}}.ValueFromMap(ctx, labelsValue)
		diags.Append(labelsDiags...)
		r.Labels, _ = labelsValuable.(kumalabels.KumaLabelsMapValue)
		r.Mesh = types.StringPointerValue(resp.Mesh)
		r.ModificationTime = types.StringPointerValue(typeconvert.TimePointerToStringPointer(resp.ModificationTime))
		r.Name = types.StringValue(resp.Name)
		r.Spec.From = []tfTypes.MeshCircuitBreakerItemFrom{}
		if len(r.Spec.From) > len(resp.Spec.From) {
			r.Spec.From = r.Spec.From[:len(resp.Spec.From)]
		}
		for fromCount, fromItem := range resp.Spec.From {
			var from tfTypes.MeshCircuitBreakerItemFrom
			if fromItem.Default == nil {
				from.Default = nil
			} else {
				from.Default = &tfTypes.MeshCircuitBreakerItemDefault{}
				if fromItem.Default.ConnectionLimits == nil {
					from.Default.ConnectionLimits = nil
				} else {
					from.Default.ConnectionLimits = &tfTypes.ConnectionLimits{}
					from.Default.ConnectionLimits.MaxConnectionPools = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(fromItem.Default.ConnectionLimits.MaxConnectionPools))
					from.Default.ConnectionLimits.MaxConnections = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(fromItem.Default.ConnectionLimits.MaxConnections))
					from.Default.ConnectionLimits.MaxPendingRequests = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(fromItem.Default.ConnectionLimits.MaxPendingRequests))
					from.Default.ConnectionLimits.MaxRequests = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(fromItem.Default.ConnectionLimits.MaxRequests))
					from.Default.ConnectionLimits.MaxRetries = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(fromItem.Default.ConnectionLimits.MaxRetries))
				}
				if fromItem.Default.OutlierDetection == nil {
					from.Default.OutlierDetection = nil
				} else {
					from.Default.OutlierDetection = &tfTypes.OutlierDetection{}
					from.Default.OutlierDetection.BaseEjectionTime = types.StringPointerValue(fromItem.Default.OutlierDetection.BaseEjectionTime)
					if fromItem.Default.OutlierDetection.Detectors == nil {
						from.Default.OutlierDetection.Detectors = nil
					} else {
						from.Default.OutlierDetection.Detectors = &tfTypes.Detectors{}
						if fromItem.Default.OutlierDetection.Detectors.FailurePercentage == nil {
							from.Default.OutlierDetection.Detectors.FailurePercentage = nil
						} else {
							from.Default.OutlierDetection.Detectors.FailurePercentage = &tfTypes.FailurePercentage{}
							from.Default.OutlierDetection.Detectors.FailurePercentage.MinimumHosts = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(fromItem.Default.OutlierDetection.Detectors.FailurePercentage.MinimumHosts))
							from.Default.OutlierDetection.Detectors.FailurePercentage.RequestVolume = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(fromItem.Default.OutlierDetection.Detectors.FailurePercentage.RequestVolume))
							from.Default.OutlierDetection.Detectors.FailurePercentage.Threshold = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(fromItem.Default.OutlierDetection.Detectors.FailurePercentage.Threshold))
						}
						if fromItem.Default.OutlierDetection.Detectors.GatewayFailures == nil {
							from.Default.OutlierDetection.Detectors.GatewayFailures = nil
						} else {
							from.Default.OutlierDetection.Detectors.GatewayFailures = &tfTypes.GatewayFailures{}
							from.Default.OutlierDetection.Detectors.GatewayFailures.Consecutive = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(fromItem.Default.OutlierDetection.Detectors.GatewayFailures.Consecutive))
						}
						if fromItem.Default.OutlierDetection.Detectors.LocalOriginFailures == nil {
							from.Default.OutlierDetection.Detectors.LocalOriginFailures = nil
						} else {
							from.Default.OutlierDetection.Detectors.LocalOriginFailures = &tfTypes.GatewayFailures{}
							from.Default.OutlierDetection.Detectors.LocalOriginFailures.Consecutive = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(fromItem.Default.OutlierDetection.Detectors.LocalOriginFailures.Consecutive))
						}
						if fromItem.Default.OutlierDetection.Detectors.SuccessRate == nil {
							from.Default.OutlierDetection.Detectors.SuccessRate = nil
						} else {
							from.Default.OutlierDetection.Detectors.SuccessRate = &tfTypes.SuccessRate{}
							from.Default.OutlierDetection.Detectors.SuccessRate.MinimumHosts = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(fromItem.Default.OutlierDetection.Detectors.SuccessRate.MinimumHosts))
							from.Default.OutlierDetection.Detectors.SuccessRate.RequestVolume = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(fromItem.Default.OutlierDetection.Detectors.SuccessRate.RequestVolume))
							if fromItem.Default.OutlierDetection.Detectors.SuccessRate.StandardDeviationFactor != nil {
								from.Default.OutlierDetection.Detectors.SuccessRate.StandardDeviationFactor = &tfTypes.Mode{}
								if fromItem.Default.OutlierDetection.Detectors.SuccessRate.StandardDeviationFactor.Integer != nil {
									from.Default.OutlierDetection.Detectors.SuccessRate.StandardDeviationFactor.Integer = types.Int64PointerValue(fromItem.Default.OutlierDetection.Detectors.SuccessRate.StandardDeviationFactor.Integer)
								}
								if fromItem.Default.OutlierDetection.Detectors.SuccessRate.StandardDeviationFactor.Str != nil {
									from.Default.OutlierDetection.Detectors.SuccessRate.StandardDeviationFactor.Str = types.StringPointerValue(fromItem.Default.OutlierDetection.Detectors.SuccessRate.StandardDeviationFactor.Str)
								}
							}
						}
						if fromItem.Default.OutlierDetection.Detectors.TotalFailures == nil {
							from.Default.OutlierDetection.Detectors.TotalFailures = nil
						} else {
							from.Default.OutlierDetection.Detectors.TotalFailures = &tfTypes.GatewayFailures{}
							from.Default.OutlierDetection.Detectors.TotalFailures.Consecutive = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(fromItem.Default.OutlierDetection.Detectors.TotalFailures.Consecutive))
						}
					}
					from.Default.OutlierDetection.Disabled = types.BoolPointerValue(fromItem.Default.OutlierDetection.Disabled)
					if fromItem.Default.OutlierDetection.HealthyPanicThreshold != nil {
						from.Default.OutlierDetection.HealthyPanicThreshold = &tfTypes.Mode{}
						if fromItem.Default.OutlierDetection.HealthyPanicThreshold.Integer != nil {
							from.Default.OutlierDetection.HealthyPanicThreshold.Integer = types.Int64PointerValue(fromItem.Default.OutlierDetection.HealthyPanicThreshold.Integer)
						}
						if fromItem.Default.OutlierDetection.HealthyPanicThreshold.Str != nil {
							from.Default.OutlierDetection.HealthyPanicThreshold.Str = types.StringPointerValue(fromItem.Default.OutlierDetection.HealthyPanicThreshold.Str)
						}
					}
					from.Default.OutlierDetection.Interval = types.StringPointerValue(fromItem.Default.OutlierDetection.Interval)
					from.Default.OutlierDetection.MaxEjectionPercent = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(fromItem.Default.OutlierDetection.MaxEjectionPercent))
					from.Default.OutlierDetection.SplitExternalAndLocalErrors = types.BoolPointerValue(fromItem.Default.OutlierDetection.SplitExternalAndLocalErrors)
				}
			}
			from.TargetRef.Kind = types.StringValue(string(fromItem.TargetRef.Kind))
			if len(fromItem.TargetRef.Labels) > 0 {
				from.TargetRef.Labels = make(map[string]types.String, len(fromItem.TargetRef.Labels))
				for key, value := range fromItem.TargetRef.Labels {
					from.TargetRef.Labels[key] = types.StringValue(value)
				}
			}
			from.TargetRef.Mesh = types.StringPointerValue(fromItem.TargetRef.Mesh)
			from.TargetRef.Name = types.StringPointerValue(fromItem.TargetRef.Name)
			from.TargetRef.Namespace = types.StringPointerValue(fromItem.TargetRef.Namespace)
			from.TargetRef.ProxyTypes = make([]types.String, 0, len(fromItem.TargetRef.ProxyTypes))
			for _, v := range fromItem.TargetRef.ProxyTypes {
				from.TargetRef.ProxyTypes = append(from.TargetRef.ProxyTypes, types.StringValue(string(v)))
			}
			from.TargetRef.SectionName = types.StringPointerValue(fromItem.TargetRef.SectionName)
			if len(fromItem.TargetRef.Tags) > 0 {
				from.TargetRef.Tags = make(map[string]types.String, len(fromItem.TargetRef.Tags))
				for key1, value1 := range fromItem.TargetRef.Tags {
					from.TargetRef.Tags[key1] = types.StringValue(value1)
				}
			}
			if fromCount+1 > len(r.Spec.From) {
				r.Spec.From = append(r.Spec.From, from)
			} else {
				r.Spec.From[fromCount].Default = from.Default
				r.Spec.From[fromCount].TargetRef = from.TargetRef
			}
		}
		r.Spec.Rules = []tfTypes.MeshCircuitBreakerItemRules{}
		if len(r.Spec.Rules) > len(resp.Spec.Rules) {
			r.Spec.Rules = r.Spec.Rules[:len(resp.Spec.Rules)]
		}
		for rulesCount, rulesItem := range resp.Spec.Rules {
			var rules tfTypes.MeshCircuitBreakerItemRules
			if rulesItem.Default == nil {
				rules.Default = nil
			} else {
				rules.Default = &tfTypes.MeshCircuitBreakerItemDefault{}
				if rulesItem.Default.ConnectionLimits == nil {
					rules.Default.ConnectionLimits = nil
				} else {
					rules.Default.ConnectionLimits = &tfTypes.ConnectionLimits{}
					rules.Default.ConnectionLimits.MaxConnectionPools = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(rulesItem.Default.ConnectionLimits.MaxConnectionPools))
					rules.Default.ConnectionLimits.MaxConnections = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(rulesItem.Default.ConnectionLimits.MaxConnections))
					rules.Default.ConnectionLimits.MaxPendingRequests = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(rulesItem.Default.ConnectionLimits.MaxPendingRequests))
					rules.Default.ConnectionLimits.MaxRequests = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(rulesItem.Default.ConnectionLimits.MaxRequests))
					rules.Default.ConnectionLimits.MaxRetries = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(rulesItem.Default.ConnectionLimits.MaxRetries))
				}
				if rulesItem.Default.OutlierDetection == nil {
					rules.Default.OutlierDetection = nil
				} else {
					rules.Default.OutlierDetection = &tfTypes.OutlierDetection{}
					rules.Default.OutlierDetection.BaseEjectionTime = types.StringPointerValue(rulesItem.Default.OutlierDetection.BaseEjectionTime)
					if rulesItem.Default.OutlierDetection.Detectors == nil {
						rules.Default.OutlierDetection.Detectors = nil
					} else {
						rules.Default.OutlierDetection.Detectors = &tfTypes.Detectors{}
						if rulesItem.Default.OutlierDetection.Detectors.FailurePercentage == nil {
							rules.Default.OutlierDetection.Detectors.FailurePercentage = nil
						} else {
							rules.Default.OutlierDetection.Detectors.FailurePercentage = &tfTypes.FailurePercentage{}
							rules.Default.OutlierDetection.Detectors.FailurePercentage.MinimumHosts = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(rulesItem.Default.OutlierDetection.Detectors.FailurePercentage.MinimumHosts))
							rules.Default.OutlierDetection.Detectors.FailurePercentage.RequestVolume = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(rulesItem.Default.OutlierDetection.Detectors.FailurePercentage.RequestVolume))
							rules.Default.OutlierDetection.Detectors.FailurePercentage.Threshold = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(rulesItem.Default.OutlierDetection.Detectors.FailurePercentage.Threshold))
						}
						if rulesItem.Default.OutlierDetection.Detectors.GatewayFailures == nil {
							rules.Default.OutlierDetection.Detectors.GatewayFailures = nil
						} else {
							rules.Default.OutlierDetection.Detectors.GatewayFailures = &tfTypes.GatewayFailures{}
							rules.Default.OutlierDetection.Detectors.GatewayFailures.Consecutive = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(rulesItem.Default.OutlierDetection.Detectors.GatewayFailures.Consecutive))
						}
						if rulesItem.Default.OutlierDetection.Detectors.LocalOriginFailures == nil {
							rules.Default.OutlierDetection.Detectors.LocalOriginFailures = nil
						} else {
							rules.Default.OutlierDetection.Detectors.LocalOriginFailures = &tfTypes.GatewayFailures{}
							rules.Default.OutlierDetection.Detectors.LocalOriginFailures.Consecutive = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(rulesItem.Default.OutlierDetection.Detectors.LocalOriginFailures.Consecutive))
						}
						if rulesItem.Default.OutlierDetection.Detectors.SuccessRate == nil {
							rules.Default.OutlierDetection.Detectors.SuccessRate = nil
						} else {
							rules.Default.OutlierDetection.Detectors.SuccessRate = &tfTypes.SuccessRate{}
							rules.Default.OutlierDetection.Detectors.SuccessRate.MinimumHosts = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(rulesItem.Default.OutlierDetection.Detectors.SuccessRate.MinimumHosts))
							rules.Default.OutlierDetection.Detectors.SuccessRate.RequestVolume = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(rulesItem.Default.OutlierDetection.Detectors.SuccessRate.RequestVolume))
							if rulesItem.Default.OutlierDetection.Detectors.SuccessRate.StandardDeviationFactor != nil {
								rules.Default.OutlierDetection.Detectors.SuccessRate.StandardDeviationFactor = &tfTypes.Mode{}
								if rulesItem.Default.OutlierDetection.Detectors.SuccessRate.StandardDeviationFactor.Integer != nil {
									rules.Default.OutlierDetection.Detectors.SuccessRate.StandardDeviationFactor.Integer = types.Int64PointerValue(rulesItem.Default.OutlierDetection.Detectors.SuccessRate.StandardDeviationFactor.Integer)
								}
								if rulesItem.Default.OutlierDetection.Detectors.SuccessRate.StandardDeviationFactor.Str != nil {
									rules.Default.OutlierDetection.Detectors.SuccessRate.StandardDeviationFactor.Str = types.StringPointerValue(rulesItem.Default.OutlierDetection.Detectors.SuccessRate.StandardDeviationFactor.Str)
								}
							}
						}
						if rulesItem.Default.OutlierDetection.Detectors.TotalFailures == nil {
							rules.Default.OutlierDetection.Detectors.TotalFailures = nil
						} else {
							rules.Default.OutlierDetection.Detectors.TotalFailures = &tfTypes.GatewayFailures{}
							rules.Default.OutlierDetection.Detectors.TotalFailures.Consecutive = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(rulesItem.Default.OutlierDetection.Detectors.TotalFailures.Consecutive))
						}
					}
					rules.Default.OutlierDetection.Disabled = types.BoolPointerValue(rulesItem.Default.OutlierDetection.Disabled)
					if rulesItem.Default.OutlierDetection.HealthyPanicThreshold != nil {
						rules.Default.OutlierDetection.HealthyPanicThreshold = &tfTypes.Mode{}
						if rulesItem.Default.OutlierDetection.HealthyPanicThreshold.Integer != nil {
							rules.Default.OutlierDetection.HealthyPanicThreshold.Integer = types.Int64PointerValue(rulesItem.Default.OutlierDetection.HealthyPanicThreshold.Integer)
						}
						if rulesItem.Default.OutlierDetection.HealthyPanicThreshold.Str != nil {
							rules.Default.OutlierDetection.HealthyPanicThreshold.Str = types.StringPointerValue(rulesItem.Default.OutlierDetection.HealthyPanicThreshold.Str)
						}
					}
					rules.Default.OutlierDetection.Interval = types.StringPointerValue(rulesItem.Default.OutlierDetection.Interval)
					rules.Default.OutlierDetection.MaxEjectionPercent = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(rulesItem.Default.OutlierDetection.MaxEjectionPercent))
					rules.Default.OutlierDetection.SplitExternalAndLocalErrors = types.BoolPointerValue(rulesItem.Default.OutlierDetection.SplitExternalAndLocalErrors)
				}
			}
			if rulesCount+1 > len(r.Spec.Rules) {
				r.Spec.Rules = append(r.Spec.Rules, rules)
			} else {
				r.Spec.Rules[rulesCount].Default = rules.Default
			}
		}
		if resp.Spec.TargetRef == nil {
			r.Spec.TargetRef = nil
		} else {
			r.Spec.TargetRef = &tfTypes.MeshAccessLogItemTargetRef{}
			r.Spec.TargetRef.Kind = types.StringValue(string(resp.Spec.TargetRef.Kind))
			if len(resp.Spec.TargetRef.Labels) > 0 {
				r.Spec.TargetRef.Labels = make(map[string]types.String, len(resp.Spec.TargetRef.Labels))
				for key2, value2 := range resp.Spec.TargetRef.Labels {
					r.Spec.TargetRef.Labels[key2] = types.StringValue(value2)
				}
			}
			r.Spec.TargetRef.Mesh = types.StringPointerValue(resp.Spec.TargetRef.Mesh)
			r.Spec.TargetRef.Name = types.StringPointerValue(resp.Spec.TargetRef.Name)
			r.Spec.TargetRef.Namespace = types.StringPointerValue(resp.Spec.TargetRef.Namespace)
			r.Spec.TargetRef.ProxyTypes = make([]types.String, 0, len(resp.Spec.TargetRef.ProxyTypes))
			for _, v := range resp.Spec.TargetRef.ProxyTypes {
				r.Spec.TargetRef.ProxyTypes = append(r.Spec.TargetRef.ProxyTypes, types.StringValue(string(v)))
			}
			r.Spec.TargetRef.SectionName = types.StringPointerValue(resp.Spec.TargetRef.SectionName)
			if len(resp.Spec.TargetRef.Tags) > 0 {
				r.Spec.TargetRef.Tags = make(map[string]types.String, len(resp.Spec.TargetRef.Tags))
				for key3, value3 := range resp.Spec.TargetRef.Tags {
					r.Spec.TargetRef.Tags[key3] = types.StringValue(value3)
				}
			}
		}
		r.Spec.To = []tfTypes.MeshCircuitBreakerItemFrom{}
		if len(r.Spec.To) > len(resp.Spec.To) {
			r.Spec.To = r.Spec.To[:len(resp.Spec.To)]
		}
		for toCount, toItem := range resp.Spec.To {
			var to tfTypes.MeshCircuitBreakerItemFrom
			if toItem.Default == nil {
				to.Default = nil
			} else {
				to.Default = &tfTypes.MeshCircuitBreakerItemDefault{}
				if toItem.Default.ConnectionLimits == nil {
					to.Default.ConnectionLimits = nil
				} else {
					to.Default.ConnectionLimits = &tfTypes.ConnectionLimits{}
					to.Default.ConnectionLimits.MaxConnectionPools = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(toItem.Default.ConnectionLimits.MaxConnectionPools))
					to.Default.ConnectionLimits.MaxConnections = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(toItem.Default.ConnectionLimits.MaxConnections))
					to.Default.ConnectionLimits.MaxPendingRequests = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(toItem.Default.ConnectionLimits.MaxPendingRequests))
					to.Default.ConnectionLimits.MaxRequests = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(toItem.Default.ConnectionLimits.MaxRequests))
					to.Default.ConnectionLimits.MaxRetries = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(toItem.Default.ConnectionLimits.MaxRetries))
				}
				if toItem.Default.OutlierDetection == nil {
					to.Default.OutlierDetection = nil
				} else {
					to.Default.OutlierDetection = &tfTypes.OutlierDetection{}
					to.Default.OutlierDetection.BaseEjectionTime = types.StringPointerValue(toItem.Default.OutlierDetection.BaseEjectionTime)
					if toItem.Default.OutlierDetection.Detectors == nil {
						to.Default.OutlierDetection.Detectors = nil
					} else {
						to.Default.OutlierDetection.Detectors = &tfTypes.Detectors{}
						if toItem.Default.OutlierDetection.Detectors.FailurePercentage == nil {
							to.Default.OutlierDetection.Detectors.FailurePercentage = nil
						} else {
							to.Default.OutlierDetection.Detectors.FailurePercentage = &tfTypes.FailurePercentage{}
							to.Default.OutlierDetection.Detectors.FailurePercentage.MinimumHosts = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(toItem.Default.OutlierDetection.Detectors.FailurePercentage.MinimumHosts))
							to.Default.OutlierDetection.Detectors.FailurePercentage.RequestVolume = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(toItem.Default.OutlierDetection.Detectors.FailurePercentage.RequestVolume))
							to.Default.OutlierDetection.Detectors.FailurePercentage.Threshold = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(toItem.Default.OutlierDetection.Detectors.FailurePercentage.Threshold))
						}
						if toItem.Default.OutlierDetection.Detectors.GatewayFailures == nil {
							to.Default.OutlierDetection.Detectors.GatewayFailures = nil
						} else {
							to.Default.OutlierDetection.Detectors.GatewayFailures = &tfTypes.GatewayFailures{}
							to.Default.OutlierDetection.Detectors.GatewayFailures.Consecutive = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(toItem.Default.OutlierDetection.Detectors.GatewayFailures.Consecutive))
						}
						if toItem.Default.OutlierDetection.Detectors.LocalOriginFailures == nil {
							to.Default.OutlierDetection.Detectors.LocalOriginFailures = nil
						} else {
							to.Default.OutlierDetection.Detectors.LocalOriginFailures = &tfTypes.GatewayFailures{}
							to.Default.OutlierDetection.Detectors.LocalOriginFailures.Consecutive = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(toItem.Default.OutlierDetection.Detectors.LocalOriginFailures.Consecutive))
						}
						if toItem.Default.OutlierDetection.Detectors.SuccessRate == nil {
							to.Default.OutlierDetection.Detectors.SuccessRate = nil
						} else {
							to.Default.OutlierDetection.Detectors.SuccessRate = &tfTypes.SuccessRate{}
							to.Default.OutlierDetection.Detectors.SuccessRate.MinimumHosts = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(toItem.Default.OutlierDetection.Detectors.SuccessRate.MinimumHosts))
							to.Default.OutlierDetection.Detectors.SuccessRate.RequestVolume = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(toItem.Default.OutlierDetection.Detectors.SuccessRate.RequestVolume))
							if toItem.Default.OutlierDetection.Detectors.SuccessRate.StandardDeviationFactor != nil {
								to.Default.OutlierDetection.Detectors.SuccessRate.StandardDeviationFactor = &tfTypes.Mode{}
								if toItem.Default.OutlierDetection.Detectors.SuccessRate.StandardDeviationFactor.Integer != nil {
									to.Default.OutlierDetection.Detectors.SuccessRate.StandardDeviationFactor.Integer = types.Int64PointerValue(toItem.Default.OutlierDetection.Detectors.SuccessRate.StandardDeviationFactor.Integer)
								}
								if toItem.Default.OutlierDetection.Detectors.SuccessRate.StandardDeviationFactor.Str != nil {
									to.Default.OutlierDetection.Detectors.SuccessRate.StandardDeviationFactor.Str = types.StringPointerValue(toItem.Default.OutlierDetection.Detectors.SuccessRate.StandardDeviationFactor.Str)
								}
							}
						}
						if toItem.Default.OutlierDetection.Detectors.TotalFailures == nil {
							to.Default.OutlierDetection.Detectors.TotalFailures = nil
						} else {
							to.Default.OutlierDetection.Detectors.TotalFailures = &tfTypes.GatewayFailures{}
							to.Default.OutlierDetection.Detectors.TotalFailures.Consecutive = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(toItem.Default.OutlierDetection.Detectors.TotalFailures.Consecutive))
						}
					}
					to.Default.OutlierDetection.Disabled = types.BoolPointerValue(toItem.Default.OutlierDetection.Disabled)
					if toItem.Default.OutlierDetection.HealthyPanicThreshold != nil {
						to.Default.OutlierDetection.HealthyPanicThreshold = &tfTypes.Mode{}
						if toItem.Default.OutlierDetection.HealthyPanicThreshold.Integer != nil {
							to.Default.OutlierDetection.HealthyPanicThreshold.Integer = types.Int64PointerValue(toItem.Default.OutlierDetection.HealthyPanicThreshold.Integer)
						}
						if toItem.Default.OutlierDetection.HealthyPanicThreshold.Str != nil {
							to.Default.OutlierDetection.HealthyPanicThreshold.Str = types.StringPointerValue(toItem.Default.OutlierDetection.HealthyPanicThreshold.Str)
						}
					}
					to.Default.OutlierDetection.Interval = types.StringPointerValue(toItem.Default.OutlierDetection.Interval)
					to.Default.OutlierDetection.MaxEjectionPercent = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(toItem.Default.OutlierDetection.MaxEjectionPercent))
					to.Default.OutlierDetection.SplitExternalAndLocalErrors = types.BoolPointerValue(toItem.Default.OutlierDetection.SplitExternalAndLocalErrors)
				}
			}
			to.TargetRef.Kind = types.StringValue(string(toItem.TargetRef.Kind))
			if len(toItem.TargetRef.Labels) > 0 {
				to.TargetRef.Labels = make(map[string]types.String, len(toItem.TargetRef.Labels))
				for key4, value4 := range toItem.TargetRef.Labels {
					to.TargetRef.Labels[key4] = types.StringValue(value4)
				}
			}
			to.TargetRef.Mesh = types.StringPointerValue(toItem.TargetRef.Mesh)
			to.TargetRef.Name = types.StringPointerValue(toItem.TargetRef.Name)
			to.TargetRef.Namespace = types.StringPointerValue(toItem.TargetRef.Namespace)
			to.TargetRef.ProxyTypes = make([]types.String, 0, len(toItem.TargetRef.ProxyTypes))
			for _, v := range toItem.TargetRef.ProxyTypes {
				to.TargetRef.ProxyTypes = append(to.TargetRef.ProxyTypes, types.StringValue(string(v)))
			}
			to.TargetRef.SectionName = types.StringPointerValue(toItem.TargetRef.SectionName)
			if len(toItem.TargetRef.Tags) > 0 {
				to.TargetRef.Tags = make(map[string]types.String, len(toItem.TargetRef.Tags))
				for key5, value5 := range toItem.TargetRef.Tags {
					to.TargetRef.Tags[key5] = types.StringValue(value5)
				}
			}
			if toCount+1 > len(r.Spec.To) {
				r.Spec.To = append(r.Spec.To, to)
			} else {
				r.Spec.To[toCount].Default = to.Default
				r.Spec.To[toCount].TargetRef = to.TargetRef
			}
		}
		r.Type = types.StringValue(string(resp.Type))
	}

	return diags
}
