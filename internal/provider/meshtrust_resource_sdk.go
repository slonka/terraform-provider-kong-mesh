// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package provider

import (
	"context"
	"github.com/Kong/shared-speakeasy/customtypes/kumalabels"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/kong/terraform-provider-kong-mesh/internal/provider/typeconvert"
	tfTypes "github.com/kong/terraform-provider-kong-mesh/internal/provider/types"
	"github.com/kong/terraform-provider-kong-mesh/internal/sdk/models/operations"
	"github.com/kong/terraform-provider-kong-mesh/internal/sdk/models/shared"
)

func (r *MeshTrustResourceModel) ToSharedMeshTrustItemInput(ctx context.Context) (*shared.MeshTrustItemInput, diag.Diagnostics) {
	var diags diag.Diagnostics

	typeVar := shared.MeshTrustItemType(r.Type.ValueString())
	mesh := new(string)
	if !r.Mesh.IsUnknown() && !r.Mesh.IsNull() {
		*mesh = r.Mesh.ValueString()
	} else {
		mesh = nil
	}
	var name string
	name = r.Name.ValueString()

	var labels map[string]string
	if !r.Labels.IsUnknown() && !r.Labels.IsNull() {
		diags.Append(r.Labels.ElementsAs(ctx, &labels, true)...)
	}
	caBundles := make([]shared.CaBundles, 0, len(r.Spec.CaBundles))
	for _, caBundlesItem := range r.Spec.CaBundles {
		var pem *shared.Pem
		if caBundlesItem.Pem != nil {
			var value string
			value = caBundlesItem.Pem.Value.ValueString()

			pem = &shared.Pem{
				Value: value,
			}
		}
		type1 := shared.MeshTrustItemSpecType(caBundlesItem.Type.ValueString())
		caBundles = append(caBundles, shared.CaBundles{
			Pem:  pem,
			Type: type1,
		})
	}
	var origin *shared.Origin
	if r.Spec.Origin != nil {
		kri := new(string)
		if !r.Spec.Origin.Kri.IsUnknown() && !r.Spec.Origin.Kri.IsNull() {
			*kri = r.Spec.Origin.Kri.ValueString()
		} else {
			kri = nil
		}
		origin = &shared.Origin{
			Kri: kri,
		}
	}
	var trustDomain string
	trustDomain = r.Spec.TrustDomain.ValueString()

	spec := shared.MeshTrustItemSpec{
		CaBundles:   caBundles,
		Origin:      origin,
		TrustDomain: trustDomain,
	}
	out := shared.MeshTrustItemInput{
		Type:   typeVar,
		Mesh:   mesh,
		Name:   name,
		Labels: labels,
		Spec:   spec,
	}

	return &out, diags
}

func (r *MeshTrustResourceModel) ToOperationsPutMeshTrustRequest(ctx context.Context) (*operations.PutMeshTrustRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var mesh string
	mesh = r.Mesh.ValueString()

	var name string
	name = r.Name.ValueString()

	meshTrustItem, meshTrustItemDiags := r.ToSharedMeshTrustItemInput(ctx)
	diags.Append(meshTrustItemDiags...)

	if diags.HasError() {
		return nil, diags
	}

	out := operations.PutMeshTrustRequest{
		Mesh:          mesh,
		Name:          name,
		MeshTrustItem: *meshTrustItem,
	}

	return &out, diags
}

func (r *MeshTrustResourceModel) ToOperationsGetMeshTrustRequest(ctx context.Context) (*operations.GetMeshTrustRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var mesh string
	mesh = r.Mesh.ValueString()

	var name string
	name = r.Name.ValueString()

	out := operations.GetMeshTrustRequest{
		Mesh: mesh,
		Name: name,
	}

	return &out, diags
}

func (r *MeshTrustResourceModel) ToOperationsDeleteMeshTrustRequest(ctx context.Context) (*operations.DeleteMeshTrustRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var mesh string
	mesh = r.Mesh.ValueString()

	var name string
	name = r.Name.ValueString()

	out := operations.DeleteMeshTrustRequest{
		Mesh: mesh,
		Name: name,
	}

	return &out, diags
}

func (r *MeshTrustResourceModel) RefreshFromSharedMeshTrustCreateOrUpdateSuccessResponse(ctx context.Context, resp *shared.MeshTrustCreateOrUpdateSuccessResponse) diag.Diagnostics {
	var diags diag.Diagnostics

	if resp != nil {
		r.Warnings = make([]types.String, 0, len(resp.Warnings))
		for _, v := range resp.Warnings {
			r.Warnings = append(r.Warnings, types.StringValue(v))
		}
	}

	return diags
}

func (r *MeshTrustResourceModel) RefreshFromSharedMeshTrustItem(ctx context.Context, resp *shared.MeshTrustItem) diag.Diagnostics {
	var diags diag.Diagnostics

	if resp != nil {
		r.CreationTime = types.StringPointerValue(typeconvert.TimePointerToStringPointer(resp.CreationTime))
		labelsValue, labelsDiags := types.MapValueFrom(ctx, types.StringType, resp.Labels)
		diags.Append(labelsDiags...)
		labelsValuable, labelsDiags := kumalabels.KumaLabelsMapType{MapType: types.MapType{ElemType: types.StringType}}.ValueFromMap(ctx, labelsValue)
		diags.Append(labelsDiags...)
		r.Labels, _ = labelsValuable.(kumalabels.KumaLabelsMapValue)
		r.Mesh = types.StringPointerValue(resp.Mesh)
		r.ModificationTime = types.StringPointerValue(typeconvert.TimePointerToStringPointer(resp.ModificationTime))
		r.Name = types.StringValue(resp.Name)
		r.Spec.CaBundles = []tfTypes.CaBundles{}
		if len(r.Spec.CaBundles) > len(resp.Spec.CaBundles) {
			r.Spec.CaBundles = r.Spec.CaBundles[:len(resp.Spec.CaBundles)]
		}
		for caBundlesCount, caBundlesItem := range resp.Spec.CaBundles {
			var caBundles tfTypes.CaBundles
			if caBundlesItem.Pem == nil {
				caBundles.Pem = nil
			} else {
				caBundles.Pem = &tfTypes.InsecureInline{}
				caBundles.Pem.Value = types.StringValue(caBundlesItem.Pem.Value)
			}
			caBundles.Type = types.StringValue(string(caBundlesItem.Type))
			if caBundlesCount+1 > len(r.Spec.CaBundles) {
				r.Spec.CaBundles = append(r.Spec.CaBundles, caBundles)
			} else {
				r.Spec.CaBundles[caBundlesCount].Pem = caBundles.Pem
				r.Spec.CaBundles[caBundlesCount].Type = caBundles.Type
			}
		}
		if resp.Spec.Origin == nil {
			r.Spec.Origin = nil
		} else {
			r.Spec.Origin = &tfTypes.Origin{}
			r.Spec.Origin.Kri = types.StringPointerValue(resp.Spec.Origin.Kri)
		}
		r.Spec.TrustDomain = types.StringValue(resp.Spec.TrustDomain)
		r.Type = types.StringValue(string(resp.Type))
	}

	return diags
}
